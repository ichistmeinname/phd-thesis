
@misc{2019reasonml,
  title = {{{ReasonML}}},
  year = {2019},
  abstract = {Simple, fast \& type safe code that leverages the JavaScript \& OCaml ecosystems},
  howpublished = {https://reasonml.github.io/}
}

@inproceedings{abbott2003categories,
  title = {Categories of {{Containers}}},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil},
  editor = {Gordon, Andrew D.},
  year = {2003},
  volume = {2620},
  pages = {23--38},
  publisher = {{Springer}},
  abstract = {We introduce the notion of containers as a mathematical formalisation of the idea that many important datatypes consist of templates where data is stored. We show that containers have good closure properties under a variety of constructions including the formation of initial algebras and final coalgebras. We also show that containers include strictly positive types and shapely types but that there are containers which do not correspond to either of these. Further, we derive a representation result classifying the nature of polymorphic functions between containers. We finish this paper with an application to the theory of shapely types and refer to a forthcoming paper which applies this theory to differentiable types.},
  isbn = {978-3-540-36576-1},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{abbott2005containers,
  title = {Containers: {{Constructing}} Strictly Positive Types},
  author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil},
  year = {2005},
  volume = {342},
  pages = {3--27},
  issn = {0304-3975},
  doi = {https://doi.org/10.1016/j.tcs.2005.06.002},
  abstract = {We introduce the notion of a Martin-L{\"o}f category\textemdash{}a locally cartesian closed category with disjoint coproducts and initial algebras of container functors (the categorical analogue of W-types)\textemdash{}and then establish that nested strictly positive inductive and coinductive types, which we call strictly positive types, exist in any Martin-L{\"o}f category. Central to our development are the notions of containers and container functors. These provide a new conceptual analysis of data structures and polymorphic functions by exploiting dependent type theory as a convenient way to define constructions in Martin-L{\"o}f categories. We also show that morphisms between containers can be full and faithfully interpreted as polymorphic functions (i.e.natural transformations) and that, in the presence of W-types, all strictly positive types (including nested inductive and coinductive types) give rise to containers.},
  journal = {Theoretical Computer Science},
  keywords = {Category theory,Coinduction,Container functors,Final coalgebras,Induction,Initial algebras,Type theory,W-Types},
  number = {1}
}

@inproceedings{abel2005verifying,
  title = {Verifying {{Haskell Programs Using Constructive Type Theory}}},
  booktitle = {Proceedings of the 2005 {{ACM SIGPLAN Workshop}} on {{Haskell}}},
  author = {Abel, Andreas and Benke, Marcin and Bove, Ana and Hughes, John and Norell, Ulf},
  year = {2005},
  pages = {62--73},
  publisher = {{ACM}},
  address = {{Tallinn, Estonia}},
  doi = {10.1145/1088348.1088355},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QWy4uLy4uL1BhcGVycy9UaGVvcmVtIFByb3ZpbmcvVmVyaWZ5aW5nIEhhc2tlbGwgcHJvZ3JhbXMgdXNpbmcgY29uc3RydWN0aXZlIHR5cGUgdGhlb3J5IC5wZGbSFwsYGVdOUy5kYXRhTxECWAAAAAACWAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA0rzi3UgrAAAAxsF3H1ZlcmlmeWluZyBIYXNrZWxsIHByIzE2Qzc5RS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWx57SOaQOAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAA9UaGVvcmVtIFByb3ZpbmcAABAACAAA0rzUzQAAABEACAAA0jmH7gAAAAEAFADGwXcAFsd2AAlddgAJXXUABiyjAAIAXE1hY2ludG9zaCBIRDpVc2VyczoAamFjOgBEb2N1bWVudHM6AFBhcGVyczoAVGhlb3JlbSBQcm92aW5nOgBWZXJpZnlpbmcgSGFza2VsbCBwciMxNkM3OUUucGRmAA4AfgA+AFYAZQByAGkAZgB5AGkAbgBnACAASABhAHMAawBlAGwAbAAgAHAAcgBvAGcAcgBhAG0AcwAgAHUAcwBpAG4AZwAgAGMAbwBuAHMAdAByAHUAYwB0AGkAdgBlACAAdAB5AHAAZQAgAHQAaABlAG8AcgB5ACAALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAGlVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9UaGVvcmVtIFByb3ZpbmcvVmVyaWZ5aW5nIEhhc2tlbGwgcHJvZ3JhbXMgdXNpbmcgY29uc3RydWN0aXZlIHR5cGUgdGhlb3J5IC5wZGYAABMAAS8AABUAAgAK//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A7ADxAPkDVQNXA1wDZwNwA34DggOJA5IDlwOkA6cDuQO8A8EAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADww==},
  isbn = {1-59593-071-X},
  keywords = {GHC core,haskell,monadic translation,partiality,type theory,verification},
  numpages = {12},
  series = {Haskell '05}
}

@incollection{abramsky1994domain,
  title = {Domain Theory},
  booktitle = {Handbook of {{Logic}} in {{Computer Science}}},
  author = {Abramsky, Samson and Jung, Achim},
  year = {1994},
  pages = {1---168},
  publisher = {{Clarendon Press}},
  isbn = {0-19-853762-X}
}

@inproceedings{affeldt2018experimenting,
  title = {Experimenting with {{Monadic Equational Reasoning}} in {{Coq}}},
  booktitle = {Proceedings of the 35th {{Meeting}} of the {{Japan Society}} for {{Software Science}} and {{Technology}}},
  author = {Affeldt, Reynald and Nowak, David},
  year = {2018},
  pages = {14},
  address = {{Osaka, Japan}},
  language = {English}
}

@inproceedings{affeldt2019monadic,
  title = {A {{Hierarchy}} of {{Monadic Effects}} for {{Program Verification Using Equational Reasoning}}},
  booktitle = {Mathematics of {{Program Construction}}},
  author = {Affeldt, Reynald and Nowak, David and Saikawa, Takafumi},
  editor = {Hutton, Graham},
  year = {2019},
  volume = {11825},
  pages = {226--254},
  publisher = {{Springer}},
  doi = {10.1007/978-3-030-33636-3_9},
  abstract = {One can perform equational reasoning about computational effects with a purely functional programming language thanks to monads. Even though equational reasoning for effectful programs is desirable, it is not yet mainstream. This is partly because it is difficult to maintain pencil-and-paper proofs of large examples. We propose a formalization of a hierarchy of effects using monads in the Coq proof assistant that makes equational reasoning practical. Our main idea is to formalize the hierarchy of effects and algebraic laws like it is done when formalizing hierarchy of traditional algebras. We can then take advantage of the sophisticated rewriting capabilities of Coq to achieve concise proofs of programs. We also show how to ensure the consistency of our hierarchy by providing rigorous models. We explain the various techniques we use to formalize a rich hierarchy of effects (with nondeterminism, state, probability, and more), to mechanize numerous examples from the literature, and we furthermore discuss extensions and new applications.},
  isbn = {978-3-030-33636-3},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{alqaddoumi2010pull,
  title = {The Pull-Tab Transformation},
  booktitle = {Proceedings of the {{Third International Workshop}} on {{Graph Computation Models}}},
  author = {Alqaddoumi, Abdulla and Antoy, Sergio and Fischer, Sebastian and Reck, Fabian},
  year = {2010},
  pages = {127--132}
}

@incollection{altenkirch2003generic,
  title = {Generic Programming within Dependently Typed Programming},
  booktitle = {Generic Programming},
  author = {Altenkirch, Thorsten and McBride, Conor},
  year = {2003},
  volume = {115},
  pages = {1--20},
  publisher = {{Springer}},
  isbn = {978-0-387-35672-3},
  series = {{{IFIP}} \textemdash{} {{The International Federation}} for {{Information Processing}}}
}

@article{altenkirch2015indexed,
  title = {Indexed Containers},
  author = {Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and McBride, Conor and Morris, Peter},
  year = {2015},
  volume = {25},
  issn = {0956-7968},
  doi = {10.1017/S095679681500009X},
  abstract = {We show that the syntactically rich notion of strictly positive families can be reduced to a core type theory with a fixed number of type constructors exploiting the novel notion of indexed containers. As a result, we show indexed containers provide normal forms for strictly positive families in much the same way that containers provide normal forms for strictly positive types. Interestingly, this step from containers to indexed containers is achieved without having to extend the core type theory. Most of the construction presented here has been formalized using the Agda system.},
  journal = {Journal of Functional Programming}
}

@inproceedings{altenkirch2017monadic,
  title = {Monadic {{Containers}} and {{Universes}} ({{Abstract}})},
  booktitle = {Abstracts of 23rd {{International Conference}} on {{Types}} for {{Proofs}} and {{Programs}}},
  author = {Altenkirch, Thorsten and Pinyo, Gun},
  year = {2017},
  volume = {10608},
  pages = {20--21},
  publisher = {{Springer}},
  address = {{Budapest, Hungary}},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{antoy2005evaluation,
  title = {Evaluation {{Strategies}} for {{Functional Logic Programming}}},
  author = {Antoy, Sergio},
  year = {2005},
  volume = {40},
  pages = {875--903},
  issn = {0747-7171},
  doi = {10.1016/j.jsc.2004.12.007},
  abstract = {Recent advances in the foundations and the implementations of functional logic programming languages originate from far-reaching results on narrowing evaluation strategies. Narrowing is a computation similar to rewriting which yields substitutions in addition to normal forms. In functional logic programming, the classes of rewrite systems to which narrowing is applied are, for the most part, subclasses of the constructor-based, possibly conditional, rewrite systems. Many interesting narrowing strategies, particularly for the smallest subclasses of the constructor-based rewrite systems, are generalizations of well-known rewrite strategies. However, some strategies for larger non-confluent subclasses have been developed just for functional logic computations. This paper discusses the elements that play a relevant role in evaluation strategies for functional logic computations, describes some important classes of rewrite systems that model functional logic programs, shows examples of the differences in expressiveness provided by these classes, and reviews the characteristics of narrowing strategies proposed for each class of rewrite systems.},
  journal = {Journal of Symbolic Computation},
  keywords = {Constructor-based rewrite systems,Definitional trees,Evaluation strategies,Functional logic programming,Narrowing},
  number = {1}
}

@article{antoy2010functional,
  title = {Functional {{Logic Programming}}},
  author = {Antoy, Sergio and Hanus, Michael},
  year = {2010},
  volume = {53},
  pages = {74--85},
  publisher = {{ACM}},
  issn = {0001-0782},
  doi = {10.1145/1721654.1721675},
  journal = {Communications of the ACM},
  number = {4},
  numpages = {12}
}

@inproceedings{antoy2017proving,
  title = {Proving {{Non}}-{{Deterministic Computations}} in {{Agda}}},
  booktitle = {Proceedings of the 24th {{International Workshop}} on {{Functional}} and ({{Constraint}}) {{Logic Programming}}},
  author = {Antoy, Sergio and Hanus, Michael and Libby, Steven},
  year = {2017},
  volume = {234},
  pages = {180--195},
  publisher = {{Open Publishing Association}},
  series = {Electronic {{Proceedings}} in {{Theoretical Computer Science}}}
}

@article{ariola1997call,
  title = {The Call-by-Need Lambda Calculus},
  author = {Ariola, Zena M. and Felleisen, Matthias},
  year = {1997},
  volume = {7},
  pages = {265--301},
  issn = {0956-7968},
  doi = {10.1017/S0956796897002724},
  abstract = {Plotkin (1975) showed that the lambda calculus is a good model

of the evaluation process for

call-by-name functional programs. Reducing programs to constants or

lambda abstractions

according to the leftmost-outermost strategy exactly mirrors execution on

an abstract machine

like Landin's SECD machine. The machine-based evaluator returns a

constant or the token

closure if and only if the standard reduction sequence starting at the

same program will end

in the same constant or in some lambda abstraction. However, the calculus

does not capture

the sharing of the evaluation of arguments that lazy implementations use to

speed up the

execution. More precisely, a lazy implementation evaluates procedure

arguments only when

needed and then only once. All other references to the formal procedure

parameter re-use the

value of the first argument evaluation. The mismatch between the

operational semantics of

the lambda calculus and the actual behavior of the prototypical

implementation is a major

obstacle for compiler writers. Unlike implementors of the leftmost-outermost

strategy or of

a call-by-value language, implementors of lazy systems cannot easily

explain the behavior

of their evaluator in terms of source level syntax. Hence, they often

cannot explain why a

certain syntactic transformation `works' and why another

doesn't. In this paper we develop an

equational characterization of the most popular lazy implementation

technique \textendash{} traditionally

called `call-by-need' \textendash{} and prove it correct with

respect to the original lambda calculus. The

theory is a strictly smaller theory than Plotkin's call-by-name

lambda calculus. Immediate

applications of the theory concern the correctness proofs of a number

of implementation

strategies, e.g. the call-by-need continuation passing transformation

and the realization of

sharing via assignments. Some of this material first appeared in a paper

presented at the 1995

ACM Conference on the Principles of Programming Languages. The paper

was a joint effort

with Maraist, Odersky and Wadler, who had independently developed a

different equational

characterization of call-by-need. We contrast our work with that of

Maraist et al. in the body of this paper where appropriate.},
  journal = {Journal of Functional Programming},
  number = {3}
}

@book{arnold2005java,
  title = {The Java Programming Language},
  author = {Arnold, Ken and Gosling, James and Holmes, David},
  year = {2005},
  publisher = {{Addison Wesley Professional}}
}

@inproceedings{arvidsson2019proving,
  title = {Proving {{Type Class Laws}} for {{Haskell}}},
  booktitle = {Trends in {{Functional Programming}}},
  author = {Arvidsson, Andreas and Johansson, Moa and Touche, Robin},
  editor = {Van Horn, David and Hughes, John},
  year = {2019},
  volume = {10447},
  pages = {61--74},
  publisher = {{Springer}},
  doi = {10.1007/978-3-030-14805-8_4},
  abstract = {Type classes in Haskell are used to implement ad-hoc polymorphism, i.e. a way to ensure both to the programmer and the compiler that a set of functions are defined for a specific data type. All instances of such type classes are expected to behave in a certain way and satisfy laws associated with the respective class. These are however typically just stated in comments and as such, there is no real way to enforce that they hold. In this paper we describe a system which allows the user to write down type class laws which are then automatically instantiated and sent to an inductive theorem prover when declaring a new instance of a type class.},
  isbn = {978-3-030-14805-8},
  keywords = {Computer Science - Programming Languages},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{atkey2015interleaving,
  title = {Interleaving Data and Effects},
  author = {Atkey, Robert and Johann, Patricia},
  year = {2015},
  volume = {25},
  issn = {0956-7968},
  doi = {10.1017/S0956796815000209},
  abstract = {The study of programming with and reasoning about inductive datatypes such as lists and trees has benefited from the simple categorical principle of initial algebras. In initial algebra semantics, each inductive datatype is represented by an initial f-algebra for an appropriate functor f. The initial algebra principle then supports the straightforward derivation of definitional principles and proof principles for these datatypes. This technique has been expanded to a whole methodology of structured functional programming, often called origami programming.In this article we show how to extend initial algebra semantics from pure inductive datatypes to inductive datatypes interleaved with computational effects. Inductive datatypes interleaved with effects arise naturally in many computational settings. For example, incrementally reading characters from a file generates a list of characters interleaved with input/output actions, and lazily constructed infinite values can be represented by pure data interleaved with the possibility of non-terminating computation. Straightforward application of initial algebra techniques to effectful datatypes leads either to unsound conclusions if we ignore the possibility of effects, or to unnecessarily complicated reasoning because the pure and effectful concerns must be considered simultaneously. We show how pure and effectful concerns can be separated using the abstraction of initial f-and-m-algebras, where the functor f describes the pure part of a datatype and the monad m describes the interleaved effects. Because initial f-and-m-algebras are the analogue for the effectful setting of initial f-algebras, they support the extension of the standard definitional and proof principles to the effectful setting.Initial f-and-m-algebras are originally due to Filinski and St{\o}vring, who studied them in the category Cpo. They were subsequently generalised to arbitrary categories by Atkey, Ghani, Jacobs, and Johann in a FoSSaCS 2012 paper. In this article we aim to introduce the general concept of initial f-and-m-algebras to a general functional programming audience.},
  journal = {Journal of Functional Programming},
  number = {E20}
}

@article{austin2010haskhol,
  title = {{{HaskHOL}}: {{A Haskell Hosted Domain Specific Language Representation}} of {{HOL Light}}},
  author = {Austin, Evan and Alexander, Perry},
  year = {2010},
  month = jan,
  pages = {13},
  abstract = {Traditionally, members of the higher-order logic (HOL) theorem proving family have been implemented in the Standard ML programming language or one of its derivatives. This paper presents a description of a recently initiated project intended to break with tradition and implement a lightweight HOL theorem prover library, HaskHOL, as a Haskell hosted domain specific language. The goal of this work is to provide the ability for Haskell users to reason about their code directly without having to transform it or otherwise export it to an external tool. The paper also presents a verification technique leveraging popular Haskell tools QuickCheck and Haskell Program Coverage to increase confidence that the logical kernel of HaskHOL is implemented correctly.},
  journal = {Trends in Functional Programming Draft Proceedings}
}

@techreport{barras1997coq,
  title = {The {{Coq Proof Assistant Reference Manual}}: {{Version}} 6.1},
  author = {Barras, Bruno and Boutin, Samuel and Cornes, Cristina and Courant, Judicael and Filliatre, Jean-Christophe and Gimenez, Eduardo and Herbelin, Hugo and Huet, Gerard and Munoz, Cesar and Murthy, Chetan and others},
  year = {1997},
  pages = {214},
  institution = {{INRIA}},
  type = {Research}
}

@book{bird2010pearls,
  title = {Pearls of {{Functional Algorithm Design}}},
  author = {Bird, Richard},
  year = {2010},
  publisher = {{Cambridge University Press}},
  isbn = {978-0-521-51338-8}
}

@article{blanqui2002inductivedatatype,
  ids = {blanqui2002inductivedatatype},
  title = {Inductive-Data-Type Systems},
  author = {Blanqui, Fr{\'e}d{\'e}ric and Jouannaud, Jean-Pierre and Okada, Mitsuhiro},
  year = {2002},
  volume = {272},
  pages = {41--68},
  issn = {0304-3975},
  doi = {10.1016/S0304-3975(00)00347-9},
  abstract = {In a previous work (``Abstract Data Type Systems'', TCS 173(2), 1997), the last two authors presented a combined language made of a (strongly normalizing) algebraic rewrite system and a typed {$\lambda$}-calculus enriched by pattern-matching definitions following a certain format, called the ``General Schema'', which generalizes the usual recursor definitions for natural numbers and similar ``basic inductive types''. This combined language was shown to be strongly normalizing. The purpose of this paper is to reformulate and extend the General Schema in order to make it easily extensible, to capture a more general class of inductive types, called ``strictly positive'', and to ease the strong normalization proof of the resulting system. This result provides a computation model for the combination of an algebraic specification language based on abstract data types and of a strongly typed functional language with strictly positive inductive types.},
  journal = {Theories of Types and Proofs 1997},
  keywords = {Higher-order rewriting,Inductive types,Recursive definitions,Strong normalization,Typed lambda-calculus},
  number = {1}
}

@incollection{bove2007computation,
  title = {Computation by {{Prophecy}}},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}},
  author = {Bove, Ana and Capretta, Venanzio},
  year = {2007},
  volume = {4583},
  pages = {70--83},
  publisher = {{Springer}},
  abstract = {We describe a new method to represent (partial) recursive functions in type theory. For every recursive definition, we define a co-inductive type of prophecies that characterises the traces of the computation of the function. The structure of a prophecy is a possibly infinite tree, which is coerced by linearisation to a type of partial results defined by applying the delay monad to the co-domain of the function. Using induction on a weight relation defined on the prophecies, we can reason about them and prove that the formal type-theoretic version of the recursive function, resulting from the present method, satisfies the recursive equations of the original function. The advantages of this technique over the method previously developed by the authors via a special-purpose accessibility (domain) predicate are: there is no need of extra logical arguments in the definition of the recursive function; the function can be applied to any element in its domain, regardless of termination properties; we obtain a type of partial recursive functions between any two given types; and composition of recursive functions can be easily defined.},
  isbn = {978-3-540-73228-0},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{brachthauser2017effekt,
  title = {Effekt: {{Extensible}} Algebraic Effects in {{Scala}} (Short Paper)},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN International Symposium}} on {{Scala}}},
  author = {Brachth{\"a}user, Jonathan Immanuel and Schuster, Philipp},
  year = {2017},
  pages = {67--72},
  publisher = {{ACM}},
  address = {{Vancouver, BC, Canada}},
  doi = {10.1145/3136000.3136007},
  isbn = {978-1-4503-5529-2},
  keywords = {algebraic effects,capabilities,continuations,effect handlers,implicits,shallow embedding},
  series = {{{SCALA}} 2017}
}

@inproceedings{brady2013programming,
  title = {Programming and {{Reasoning}} with {{Algebraic Effects}} and {{Dependent Types}}},
  booktitle = {Proceedings of the 18th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Brady, Edwin},
  year = {2013},
  pages = {133--144},
  publisher = {{ACM}},
  address = {{Boston, Massachusetts, USA}},
  doi = {10.1145/2500365.2500581},
  isbn = {978-1-4503-2326-0},
  keywords = {algebraic effects,dependent types},
  number = {9},
  numpages = {12},
  series = {{{ICFP}} '13}
}

@article{brassel2004encapsulating,
  title = {Encapsulating {{Non}}-{{Determinism}} in {{Functional Logic Computations}}},
  author = {Bra{\ss}el, Bernd and Hanus, Michael and Huch, Frank},
  year = {2004},
  volume = {2004},
  journal = {Journal of Functional and Logic Programming},
  number = {6}
}

@article{brassel2009technique,
  title = {A {{Technique}} to {{Build Debugging Tools}} for {{Lazy Functional Logic Languages}}},
  author = {Bra{\ss}el, Bernd},
  year = {2009},
  volume = {246},
  pages = {39--53},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2009.07.014},
  abstract = {This paper is based on a recently developed technique to build debugging tools for lazy functional programming languages. With this technique it is possible to replay the execution of a lazy program with a strict semantics by recording information of unevaluated expressions. The recorded information is called an oracle and is very compact. Oracles contain the number of strict steps between discarding unevaluated expressions. The technique has already been successfully employed to construct a debugger for lazy functional languages. This paper extends the technique to include also lazy functional logic languages. A debugging tool built with the technique can be downloaded at www-ps.informatik.uni-kiel.de/\textasciitilde{}bbr.},
  journal = {Proceedings of the 17th International Workshop on Functional and (Constraint) Logic Programming (WFLP 2008)},
  keywords = {debugging tools,Lazy functional languages,logic languages}
}

@inproceedings{brassel2011kics2,
  title = {{{KiCS2}}: {{A New Compiler}} from {{Curry}} to {{Haskell}}},
  booktitle = {Proceedings of the 20th {{International Conference}} on {{Functional}} and {{Constraint Logic Programming}}},
  author = {Bra{\ss}el, Bernd and Hanus, Michael and Peem{\"o}ller, Bj{\"o}rn and Reck, Fabian},
  editor = {Kuchen, Herbert},
  year = {2011},
  volume = {6816},
  pages = {1--18},
  publisher = {{Springer}},
  address = {{Odense, Denmark}},
  doi = {10.1007/978-3-642-22531-4_1},
  isbn = {978-3-642-22530-7},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{breitner2018ready,
  title = {Ready, {{Set}}, {{Verify}}! {{Applying Hs}}-to-Coq to {{Real}}-World {{Haskell Code}} ({{Experience Report}})},
  author = {Breitner, Joachim and {Spector-Zabusky}, Antal and Li, Yao and Rizkallah, Christine and Wiegley, John and Weirich, Stephanie},
  year = {2018},
  month = jul,
  volume = {2},
  publisher = {{ACM}},
  doi = {10.1145/3236784},
  articleno = {Article 89},
  issue_date = {July 2018},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {Coq,Haskell,verification},
  number = {ICFP},
  numpages = {16}
}

@inproceedings{brus1987clean,
  title = {Clean \textemdash{} a {{Language}} for {{Functional Graph Rewriting}}},
  booktitle = {Conference on {{Functional Programming Languages}} and {{Computer Architecture}}},
  author = {Brus, TH and {van Eekelen}, Marko CJD and Van Leer, MO and Plasmeijer, Marinus J},
  year = {1987},
  volume = {247},
  pages = {364--384},
  publisher = {{Springer}},
  doi = {10.1007/3-540-18317-5_20},
  isbn = {978-3-540-47879-9},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@phdthesis{bunkenburg2019modeling,
  title = {Modeling {{Call}}-{{Time Choice}} as {{Effect}} Using {{Scoped Free Monads}}},
  author = {Bunkenburg, Niels},
  year = {2019},
  school = {Christian-Albrechts University of Kiel},
  type = {Master's {{Thesis}}}
}

@book{chlipala2013certified,
  title = {Certified {{Programming}} with {{Dependent Types}}: {{A Pragmatic Introduction}} to the {{Coq Proof Assistant}}},
  author = {Chlipala, Adam},
  year = {2013},
  publisher = {{The MIT Press}},
  isbn = {0-262-02665-1}
}

@inproceedings{christiansen2008easycheck,
  title = {{{EasyCheck}} --- {{Test Data}} for {{Free}}},
  booktitle = {Proceedings of the {{International Symposium}} on {{Functional}} and {{Logic Programming}}},
  author = {Christiansen, Jan and Fischer, Sebastian},
  year = {2008},
  volume = {4989},
  pages = {322--336},
  publisher = {{Springer}},
  doi = {10.1007/978-3-540-78969-7_23},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QNy4uLy4uL1BhcGVycy9UZXN0aW5nL0Vhc3lDaGVjayAtIFRlc3QgRGF0YSBmb3IgRnJlZS5wZGbSFwsYGVdOUy5kYXRhTxEB7AAAAAAB7AACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA0rzi3UgrAAAAqOwCH0Vhc3lDaGVjayAtIFRlc3QgRGEjMjMxRjYyMy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIx9iPWvJlCUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAdUZXN0aW5nAAAQAAgAANK81M0AAAARAAgAANa8izIAAAABABQAqOwCABbHdgAJXXYACV11AAYsowACAFRNYWNpbnRvc2ggSEQ6VXNlcnM6AGphYzoARG9jdW1lbnRzOgBQYXBlcnM6AFRlc3Rpbmc6AEVhc3lDaGVjayAtIFRlc3QgRGEjMjMxRjYyMy5wZGYADgBGACIARQBhAHMAeQBDAGgAZQBjAGsAIAAtACAAVABlAHMAdAAgAEQAYQB0AGEAIABmAG8AcgAgAEYAcgBlAGUALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAEVVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9UZXN0aW5nL0Vhc3lDaGVjayAtIFRlc3QgRGF0YSBmb3IgRnJlZS5wZGYAABMAAS8AABUAAgAK//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4AyADNANUCxQLHAswC1wLgAu4C8gL5AwIDBwMUAxcDKQMsAzEAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADMw==},
  isbn = {978-3-540-78969-7},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{christiansen2010free,
  title = {Free {{Theorems For Functional Logic Programs}}},
  booktitle = {Proceedings of the 4th {{ACM SIGPLAN Workshop}} on {{Programming Languages Meets Program Verification}}},
  author = {Christiansen, Jan and Seidel, Daniel and Voigtl{\"a}nder, Janis},
  year = {2010},
  pages = {39--48},
  publisher = {{ACM}},
  address = {{Madrid, Spain}},
  doi = {10.1145/1707790.1707797},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QJy4uLy4uL1BhcGVycy9DdXJyeS9wMzktY2hyaXN0aWFuc2VuLnBkZtIXCxgZV05TLmRhdGFPEQGyAAAAAAGyAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADSvOLdSCsAAAAWx3oUcDM5LWNocmlzdGlhbnNlbi5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGpsUNNr0sYAAAAAAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUN1cnJ5AAAQAAgAANK81M0AAAARAAgAANNrtqYAAAABABQAFsd6ABbHdgAJXXYACV11AAYsowACAEdNYWNpbnRvc2ggSEQ6VXNlcnM6AGphYzoARG9jdW1lbnRzOgBQYXBlcnM6AEN1cnJ5OgBwMzktY2hyaXN0aWFuc2VuLnBkZgAADgAqABQAcAAzADkALQBjAGgAcgBpAHMAdABpAGEAbgBzAGUAbgAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIANVVzZXJzL2phYy9Eb2N1bWVudHMvUGFwZXJzL0N1cnJ5L3AzOS1jaHJpc3RpYW5zZW4ucGRmAAATAAEvAAAVAAIACv//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOALgAvQDFAnsCfQKCAo0ClgKkAqgCrwK4Ar0CygLNAt8C4gLnAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAuk=},
  isbn = {978-1-60558-890-2},
  keywords = {curry,haskell,relational parametricity},
  series = {{{PLPV}} '10}
}

@inproceedings{christiansen2011sloth,
  title = {Sloth \textendash{} {{A Tool}} for {{Checking Minimal}}-{{Strictness}}},
  booktitle = {Practical {{Aspects}} of {{Declarative Languages}}},
  author = {Christiansen, Jan},
  year = {2011},
  volume = {6539},
  pages = {160--174},
  publisher = {{Springer}},
  doi = {10.1007/978-3-642-18378-2_14},
  abstract = {We present a light-weight tool called Sloth which assists programmers in identifying unnecessarily strict first order functions. Sloth reports counterexamples in form of a partial value, the corresponding result of the tested function and a recommended result. We present examples where the hints reported by Sloth can be used to improve a function with respect to memory behaviour, non-termination, and performance in the context of functional-logic programming. Furthermore we give an example-driven introduction into the basics of the implementation of Sloth. To improve the results in comparison to an existing approach we use additional constraints to assure that Sloth's suggestions are implementable without employing parallelism.},
  isbn = {978-3-642-18377-5},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{christiansen2016all,
  title = {All {{Sorts}} of {{Permutations}} ({{Functional Pearl}})},
  booktitle = {Proceedings of the 21st {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Christiansen, Jan and Danilenko, Nikita and Dylus, Sandra},
  year = {2016},
  pages = {168--179},
  publisher = {{ACM}},
  doi = {10.1145/2951913.2951949},
  isbn = {978-1-4503-4219-3},
  keywords = {free theorems,Haskell,monads,non-determinism,permutation,sorting},
  series = {{{ICFP}} 2016}
}

@misc{christiansen2019proving,
  title = {Proving {{Inequational Propositions}} about {{Haskell Programs}} in {{Coq}}},
  author = {Christiansen, Jan and Dylus, Sandra},
  year = {2019},
  month = apr,
  howpublished = {International Conference on the Art, Science, and Engineering of Programming},
  type = {Poster}
}

@inproceedings{christiansen2019verifying,
  title = {Verifying {{Effectful Haskell Programs}} in {{Coq}}},
  booktitle = {Proceedings of the 12th {{ACM SIGPLAN International Symposium}} on {{Haskell}}},
  author = {Christiansen, Jan and Dylus, Sandra and Bunkenburg, Niels},
  year = {2019},
  pages = {125--138},
  publisher = {{ACM}},
  address = {{Berlin, Germany}},
  doi = {10.1145/3331545.3342592},
  isbn = {978-1-4503-6813-1},
  keywords = {Coq,free monad,Haskell,monads,verification},
  numpages = {14},
  series = {Haskell 2019}
}

@inproceedings{cleva2004logic,
  title = {A Logic Programming Approach to the Verification of Functional-Logic Programs},
  booktitle = {Proceedings of the 6th {{ACM SIGPLAN}} International Conference on Principles and Practice of Declarative Programming},
  author = {Cleva, Jos{\'e} Miguel and Leach, Javier and {L{\'o}pez-Fraguas}, Francisco J.},
  year = {2004},
  pages = {9--19},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1013963.1013969},
  isbn = {1-58113-819-9},
  keywords = {functional logic programming,logic programming,verification},
  series = {{{PPDP}} '04}
}

@inproceedings{clinger1982nondeterministic,
  title = {Nondeterministic Call by Need Is Neither Lazy nor by Name},
  booktitle = {Proceedings of the 1982 {{ACM}} Symposium on {{LISP}} and Functional Programming},
  author = {Clinger, William},
  year = {1982},
  pages = {226--234},
  publisher = {{ACM}},
  address = {{Pittsburgh, Pennsylvania, USA}},
  doi = {10.1145/800068.802154},
  isbn = {0-89791-082-6},
  numpages = {9},
  series = {{{LFP}} '82}
}

@phdthesis{coquand1986calculus,
  title = {The {{Calculus}} of {{Constructions}}},
  author = {Coquand, Thierry and Huet, G{\'e}rard},
  year = {1986},
  school = {INRIA},
  type = {{{PhD Thesis}}}
}

@inproceedings{coquand1988inductively,
  title = {Inductively {{Defined Types}}},
  booktitle = {Proceedings of the {{International Conference}} on {{Computer Logic}}},
  author = {Coquand, Thierry and Paulin, Christine},
  year = {1988},
  volume = {417},
  pages = {50--66},
  publisher = {{Springer}},
  doi = {10.1007/3-540-52335-9_47},
  isbn = {978-3-540-46963-6},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@phdthesis{czaplicki2012elm,
  title = {Elm: {{Concurrent FRP}} for Functional {{GUIs}}},
  author = {Czaplicki, Evan},
  year = {2012},
  school = {Harvard University},
  type = {Senior {{Thesis}}}
}

@inproceedings{danielsson2006fast,
  title = {Fast and {{Loose Reasoning}} Is {{Morally Correct}}},
  booktitle = {Conference {{Record}} of the 33rd {{ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  author = {Danielsson, Nils Anders and Hughes, John and Jansson, Patrik and Gibbons, Jeremy},
  year = {2006},
  pages = {206--217},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1111037.1111056},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QRi4uLy4uL1BhcGVycy9SZWFzb25pbmcvRmFzdCBhbmQgTG9vc2UgUmVhc29uaW5nIGlzIE1vcmFsbHkgQ29ycmVjdC5wZGbSFwsYGVdOUy5kYXRhTxECGAAAAAACGAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA0rzi3UgrAAACNWYvH0Zhc3QgYW5kIExvb3NlIFJlYXMjMjM1NjYwRS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI1Zg7WxViqUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAAlSZWFzb25pbmcAABAACAAA0rzUzQAAABEACAAA1sVKmgAAAAEAFAI1Zi8AFsd2AAlddgAJXXUABiyjAAIAVk1hY2ludG9zaCBIRDpVc2VyczoAamFjOgBEb2N1bWVudHM6AFBhcGVyczoAUmVhc29uaW5nOgBGYXN0IGFuZCBMb29zZSBSZWFzIzIzNTY2MEUucGRmAA4AYAAvAEYAYQBzAHQAIABhAG4AZAAgAEwAbwBvAHMAZQAgAFIAZQBhAHMAbwBuAGkAbgBnACAAaQBzACAATQBvAHIAYQBsAGwAeQAgAEMAbwByAHIAZQBjAHQALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAFRVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9SZWFzb25pbmcvRmFzdCBhbmQgTG9vc2UgUmVhc29uaW5nIGlzIE1vcmFsbHkgQ29ycmVjdC5wZGYAEwABLwAAFQACAAr//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDXANwA5AMAAwIDBwMSAxsDKQMtAzQDPQNCA08DUgNkA2cDbAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAANu},
  isbn = {1-59593-027-2},
  keywords = {equational reasoning,inductive and coinductive types,lifted types,non-strict and strict languages,partial and infinite values,partial and total languages},
  series = {{{POPL}} '06}
}

@inproceedings{delaware2013metatheory,
  title = {Meta-{{Theory}} {\`a} {{La Carte}}},
  booktitle = {Proceedings of the 40th {{Annual ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  author = {Delaware, Benjamin and {d S Oliveira}, Bruno C and Schrijvers, Tom},
  year = {2013},
  volume = {48},
  pages = {207--218},
  publisher = {{ACM}},
  address = {{Rome, Italy}},
  doi = {10.1145/2429069.2429094},
  isbn = {978-1-4503-1832-7},
  keywords = {coq,extensible church encodings,modular mechanized meta-theory},
  numpages = {12},
  series = {{{POPL}} '13}
}

@inproceedings{delaware2013modular,
  title = {Modular {{Monadic Meta}}-{{Theory}}},
  booktitle = {Proceedings of the 18th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Delaware, Benjamin and Keuchel, Steven and Schrijvers, Tom and Oliveira, Bruno C.d.S.},
  year = {2013},
  pages = {319--330},
  publisher = {{ACM}},
  address = {{Boston, Massachusetts, USA}},
  doi = {10.1145/2500365.2500587},
  abstract = {This paper presents 3MT, a framework for modular mechanized meta-theory of languages with effects. Using 3MT, individual language features and their corresponding definitions \textendash{} semantic functions, theorem statements and proofs \textendash{} can be built separately and then reused to create different languages with fully mechanized meta-theory. 3MT combines modular datatypes and monads to define denotational semantics with effects on a per-feature basis, without fixing the particular set of effects or language constructs.},
  isbn = {978-1-4503-2326-0},
  keywords = {mechanized meta-theory,modularity,monads,side-effects},
  language = {English},
  numpages = {12},
  series = {{{ICFP}} '13}
}

@incollection{demol2002theorem,
  title = {Theorem {{Proving}} for {{Functional Programmers}}},
  booktitle = {Implementation of {{Functional Languages}}},
  author = {{de Mol}, Maarten and {van Eekelen}, Marko and Plasmeijer, Rinus},
  year = {2002},
  volume = {2312},
  pages = {55--71},
  publisher = {{Springer}},
  abstract = {Sparkle is a new theorem prover written and specialized in the functional programming language Clean. It is in the first place intended to be used by programmers on small parts of Clean-programs, combining theorem proving and programming into one process. It should of course also be usable by logicians interested in proving properties of larger programs.},
  isbn = {978-3-540-46028-2},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@incollection{demol2008proving,
  title = {Proving {{Properties}} of {{Lazy Functional Programs}} with {{Sparkle}}},
  booktitle = {Central {{European Functional Programming School}}},
  author = {{de Mol}, Maarten and {van Eekelen}, Marko and Plasmeijer, Rinus},
  year = {2008},
  volume = {5161},
  pages = {41--86},
  publisher = {{Springer}},
  isbn = {978-3-540-88059-2},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{deraedt2007problog,
  title = {{{ProbLog}}: {{A Probabilistic Prolog}} and {{Its Application}} in {{Link Discovery}}},
  booktitle = {Proceedings of the 20th {{International Joint Conference}} on {{Artifical Intelligence}}},
  author = {De Raedt, Luc and Kimmig, Angelika and Toivonen, Hannu},
  year = {2007},
  pages = {2468--2473},
  publisher = {{Morgan Kaufmann Publishers Inc.}},
  address = {{Hyderabad, India}},
  series = {{{IJCAI}} '07}
}

@article{deraedt2015probabilistic,
  title = {Probabilistic (Logic) Programming Concepts},
  author = {De Raedt, Luc and Kimmig, Angelika},
  year = {2015},
  volume = {100},
  pages = {5--47},
  publisher = {{Kluwer Academic Publishers}},
  issn = {0885-6125},
  doi = {10.1007/s10994-015-5494-z},
  issue_date = {July 2015},
  journal = {Machine Learning},
  keywords = {Inference in probabilistic languages,Probabilistic logic programming,Probabilistic programming languages,Statistical relational learning},
  number = {1},
  numpages = {43}
}

@techreport{dijkstra2012experimentation,
  title = {Experimentation {{Project Report}}: {{Translating Haskell Programs}} to {{Coq Programs}}},
  author = {Dijkstra, Gabe},
  year = {2012},
  pages = {17},
  institution = {{Utrecht University}},
  type = {Experimentation {{Project}}}
}

@inproceedings{dylus2018probabilistic,
  title = {Probabilistic {{Functional Logic Programming}}},
  booktitle = {Practical {{Aspects}} of {{Declarative Languages}}},
  author = {Dylus, Sandra and Christiansen, Jan and Teegen, Finn},
  year = {2018},
  volume = {10702},
  pages = {3--19},
  publisher = {{Springer}},
  doi = {10.1007/978-3-319-73305-0},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QWC4uLy4uL1BhcGVycy9GdW5jdGlvbmFsIExvZ2ljIFByb2dyYW1taW5nL1Byb2JhYmlsaXN0aWMgRnVuY3Rpb25hbCBMb2dpYyBQcm9ncmFtbWluZy5wZGbSFwsYGVdOUy5kYXRhTxECTgAAAAACTgACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA0rzi3UgrAAACJsASH1Byb2JhYmlsaXN0aWMgRnVuY3QjMjI2QkZGNy5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAImv/fWm3heUERGIAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAABxGdW5jdGlvbmFsIExvZ2ljIFByb2dyYW1taW5nABAACAAA0rzUzQAAABEACAAA1ptqTgAAAAEAFAImwBIAFsd2AAlddgAJXXUABiyjAAIAaU1hY2ludG9zaCBIRDpVc2VyczoAamFjOgBEb2N1bWVudHM6AFBhcGVyczoARnVuY3Rpb25hbCBMb2dpYyBQcm9ncmFtbWluZzoAUHJvYmFiaWxpc3RpYyBGdW5jdCMyMjZCRkY3LnBkZgAADgBeAC4AUAByAG8AYgBhAGIAaQBsAGkAcwB0AGkAYwAgAEYAdQBuAGMAdABpAG8AbgBhAGwAIABMAG8AZwBpAGMAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAGZVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9GdW5jdGlvbmFsIExvZ2ljIFByb2dyYW1taW5nL1Byb2JhYmlsaXN0aWMgRnVuY3Rpb25hbCBMb2dpYyBQcm9ncmFtbWluZy5wZGYAEwABLwAAFQACAAr//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDpAO4A9gNIA0oDTwNaA2MDcQN1A3wDhQOKA5cDmgOsA68DtAAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAO2},
  isbn = {978-3-319-73305-0},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{dylus2019one,
  title = {One {{Monad}} to {{Prove Them All}}},
  author = {Dylus, Sandra and Christiansen, Jan and Teegen, Finn},
  year = {2019},
  volume = {3},
  doi = {10.22152/programming-journal.org/2019/3/8},
  abstract = {One Monad to Prove Them All is a modern fairy tale about curiosity and perseverance, two important properties of a successful PhD student. We follow the PhD student Mona on her adventure of proving properties about Haskell programs in the proof assistant Coq. On the one hand, as a PhD student in computer science Mona observes an increasing demand for correct software products. In particular, because of the large amount of existing software, verifying existing software products becomes more important. Verifying programs in the functional programming language Haskell is no exception. On the other hand, Mona is delighted to see that communities in the area of theorem proving are becoming popular. Thus, Mona sets out to learn more about the interactive theorem prover Coq and verifying Haskell programs in Coq.},
  journal = {The Art, Science, and Engineering of Programming},
  number = {3-8}
}

@article{dylus2020implementing,
  title = {Implementing a {{Library}} for {{Probabilistic Programming Using Non}}-Strict {{Non}}-Determinism},
  author = {Dylus, Sandra and Christiansen, Jan and Teegen, Finn},
  year = {2020},
  edition = {2019/07/02},
  volume = {20},
  pages = {147--175},
  publisher = {{Cambridge University Press}},
  issn = {1471-0684},
  doi = {10.1017/S1471068419000085},
  abstract = {This paper presents PFLP, a library for probabilistic programming in the functional logic programming language Curry. It demonstrates how the concepts of a functional logic programming language support the implementation of a library for probabilistic programming. In fact, the paradigms of functional logic and probabilistic programming are closely connected. That is, language characteristics from one area exist in the other and vice versa. For example, the concepts of non-deterministic choice and call-time choice as known from functional logic programming are related to and coincide with stochastic memoization and probabilistic choice in probabilistic programming, respectively. We will further see that an implementation based on the concepts of functional logic programming can have benefits with respect to performance compared to a standard list-based implementation and can even compete with full-blown probabilistic programming languages, which we illustrate by several benchmarks.},
  journal = {Theory and Practice of Logic Programming},
  keywords = {call-time choice,functional logic programming,laziness,non-determinism,probabilistic programming},
  number = {1}
}

@article{erwig2006functional,
  title = {Functional {{Pearls}}: {{Probabilistic Functional Programming}} in {{Haskell}}},
  author = {Erwig, Martin and Kollmansberger, Steve},
  year = {2006},
  volume = {16},
  pages = {21--34},
  issn = {0956-7968},
  doi = {10.1017/S0956796805005721},
  abstract = {At the heart of functional programming rests the principle of referential transparency, which in particular means that a function f applied to a value x always yields one and the same value y=f(x). This principle seems to be violated when contemplating the use of functions to describe probabilistic events, such as rolling a die: It is not clear at all what exactly the outcome will be, and neither is it guaranteed that the same value will be produced repeatedly. However, these two seemingly incompatible notions can be reconciled if probabilistic values are encapsulated in a data type.},
  journal = {Journal of Functional Programming},
  number = {1}
}

@inproceedings{farmer2015reasoning,
  title = {Reasoning with the {{HERMIT}}: {{Tool Support}} for {{Equational Reasoning}} on {{GHC Core Programs}}},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  author = {Farmer, Andrew and Sculthorpe, Neil and Gill, Andy},
  year = {2015},
  pages = {23--34},
  publisher = {{ACM}},
  address = {{Vancouver, BC, Canada}},
  doi = {10.1145/2804302.2804303},
  isbn = {978-1-4503-3808-0},
  keywords = {Equational Reasoning,HERMIT,Type Class Laws},
  numpages = {12},
  series = {Haskell '15}
}

@phdthesis{filinski1996controlling,
  title = {Controlling {{Effects}}},
  author = {Filinski, Andrezej},
  year = {1996},
  abstract = {Many computational effects, such as exceptions, state, or nondeterminism, can be conveniently specified in terms of monads. We investigate a technique for uniformly adding arbitrary such effects to ML-like languages, without requiring any structural changes to the programs themselves. Instead, we use monadic reflection, a new language construct for explicitly converting back and forth between representations of effects as behavior and as data. Using monadic reflection to characterize concisely all effects expressible with a given monad, we can give a precise meaning to the notion of simulating one effect by another, more general one. We isolate a simple condition allowing such a simulation, and in particular show that any monadic effect can be simulated by a continuation monad. In other words, under relatively mild assumptions on the base language (allowing formation of a suitably large answer type), control becomes a universal effect. Concluding the development, we show that this universal effect can itself be explicitly implemented in terms of only standard first-class continuations (call/cc) and a piece of global state. This means that we can specify an effect such as nondeterminism abstractly, in terms of result lists, then directly obtain from this description a nondeterministic-choice operator performing imperatively-implemented backtracking. We include a full realization of the general construction in Standard ML of New Jersey, and give several programming examples.},
  school = {Carnegie-Mellon University Pittsburgh}
}

@inproceedings{fischer2009purely,
  title = {Purely {{Functional Lazy Non}}-Deterministic {{Programming}}},
  booktitle = {Proceedings of the 14th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Fischer, Sebastian and Kiselyov, Oleg and Shan, Chung-chieh},
  year = {2009},
  pages = {11--22},
  publisher = {{ACM}},
  address = {{Edinburgh, United Kingdom}},
  doi = {10.1145/1596550.1596556},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QSy4uLy4uL1BhcGVycy9DdXJyeS9QdXJlbHkgRnVuY3Rpb25hbCBMYXp5IE5vbi1kZXRlcm1pbmlzdGljIFByb2dyYW1taW5nLnBkZtIXCxgZV05TLmRhdGFPEQIoAAAAAAIoAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADSvOLdSCsAAAAWx3ofUHVyZWx5IEZ1bmN0aW9uYWwgTCMxMUQ1RTBCLnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1eC9TTajVQREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAABUN1cnJ5AAAQAAgAANK81M0AAAARAAgAANTTXCUAAAABABQAFsd6ABbHdgAJXXYACV11AAYsowACAFJNYWNpbnRvc2ggSEQ6VXNlcnM6AGphYzoARG9jdW1lbnRzOgBQYXBlcnM6AEN1cnJ5OgBQdXJlbHkgRnVuY3Rpb25hbCBMIzExRDVFMEIucGRmAA4AcgA4AFAAdQByAGUAbAB5ACAARgB1AG4AYwB0AGkAbwBuAGEAbAAgAEwAYQB6AHkAIABOAG8AbgAtAGQAZQB0AGUAcgBtAGkAbgBpAHMAdABpAGMAIABQAHIAbwBnAHIAYQBtAG0AaQBuAGcALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAFlVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9DdXJyeS9QdXJlbHkgRnVuY3Rpb25hbCBMYXp5IE5vbi1kZXRlcm1pbmlzdGljIFByb2dyYW1taW5nLnBkZgAAEwABLwAAFQACAAr//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDcAOEA6QMVAxcDHAMnAzADPgNCA0kDUgNXA2QDZwN5A3wDgQAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAOD},
  isbn = {978-1-60558-332-7},
  keywords = {call-time choice,continuations,monads,side effects},
  numpages = {12},
  series = {{{ICFP}} '09}
}

@phdthesis{fischer2010functional,
  title = {On {{Functional Logic Programming}} and Its {{Application}} to {{Testing}}},
  author = {Fischer, Sebastian},
  year = {2010},
  school = {Christian-Albrechts University of Kiel},
  type = {{{PhD Thesis}}}
}

@inproceedings{ghani2007higher,
  ids = {ghani2007higher},
  title = {Higher {{Dimensional Trees}}, {{Algebraically}}},
  booktitle = {Algebra and {{Coalgebra}} in {{Computer Science}}},
  author = {Ghani, Neil and Kurz, Alexander},
  editor = {Mossakowski, Till and Montanari, Ugo and Haveraaen, Magne},
  year = {2007},
  volume = {4624},
  pages = {226--241},
  publisher = {{Springer}},
  doi = {10.1007/978-3-540-73859-6_16},
  abstract = {In formal language theory, James Rogers published a series of innovative papers generalising strings and trees to higher dimensions. Motivated by applications in linguistics, his goal was to smoothly extend the core theory of the formal languages of strings and trees to higher dimensions.},
  isbn = {978-3-540-73859-6},
  organization = {{Springer}},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{gibbons1999proof,
  title = {Proof {{Methods}} for {{Structured Corecursive Programs}}},
  booktitle = {Trends in Functional Programming},
  author = {Gibbons, Jeremy and Hutton, Graham},
  year = {1999},
  pages = {15},
  abstract = {Corecursive programs produce values of greatest fixpoint types, in contrast to recursive programs, which consume values of least fixpoint types. There are a number of widely used methods for proving properties of corecursive programs, including fixpoint induction, the take lemma, and coinduction. However, these methods are all rather low-level, in that they do not exploit the common structure that is often present in corecursive definitions. We argue for a more structured approach to proving properties of corecursive programs. In particular, we show that by writing corecursive programs using a simple operator that encapsulates a common pattern of corecursive definition, we can then use high-level algebraic properties of this operator to conduct proofs in a purely calculational style that avoids the use of inductive or coinductive methods.},
  language = {English}
}

@inproceedings{gibbons2011just,
  title = {Just Do It: {{Simple Monadic Equational Reasoning}}},
  booktitle = {Proceedings of the 16th {{ACM SIGPLAN}} International Conference on Functional Programming},
  author = {Gibbons, Jeremy and Hinze, Ralf},
  year = {2011},
  pages = {2--14},
  publisher = {{ACM}},
  address = {{Tokyo, Japan}},
  doi = {10.1145/2034773.2034777},
  isbn = {978-1-4503-0865-6},
  keywords = {algebraic specification,equational reasoning,lawvere theories,monads},
  numpages = {13},
  series = {{{ICFP}} '11}
}

@inproceedings{gonzalez-moreno1996rewriting,
  title = {A Rewriting Logic for Declarative Programming},
  booktitle = {European {{Symposium}} on {{Programming}}},
  author = {{Gonz{\'a}lez-Moreno}, Juan C and {Hortal{\'a}-Gonz{\'a}lez}, Maria Teresa and {L{\'o}pez-Fraguas}, Francisco Javier and {Rodr{\'i}guez-Artalejo}, Mario},
  year = {1996},
  volume = {1058},
  pages = {156--172},
  publisher = {{Springer}},
  doi = {10.1007/3-540-61055-3_35},
  isbn = {978-3-540-49942-8},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{goodman2008church,
  ids = {goodman2008churcha},
  title = {Church: A {{Language}} for {{Generative Models}}},
  booktitle = {Proceedings of the 24th {{Conference}} in {{Uncertainty}} in {{Artificial Intelligence}}},
  author = {Goodman, Noah D. and Mansinghka, Vikash K. and Roy, Daniel M. and Bonawitz, Keith and Tenenbaum, Joshua B.},
  editor = {McAllester, David A. and Myllym{\"a}ki, Petri},
  year = {2008},
  pages = {220--229},
  publisher = {{AUAI Press}},
  address = {{Helsinki, Finland}},
  series = {{{UAI}} 2008}
}

@misc{goodman2014design,
  title = {The {{Design}} and {{Implementation}} of {{Probabilistic Programming Languages}}},
  author = {Goodman, Noah D. and Stuhlm{\"u}ller, Andreas},
  year = {2014},
  howpublished = {http://dippl.org}
}

@inproceedings{gordon2014probabilistic,
  title = {Probabilistic {{Programming}}},
  booktitle = {Proceedings of the on {{Future}} of {{Software Engineering}}},
  author = {Gordon, Andrew D. and Henzinger, Thomas A. and Nori, Aditya V. and Rajamani, Sriram K.},
  year = {2014},
  pages = {167--181},
  publisher = {{ACM}},
  address = {{Hyderabad, India}},
  doi = {10.1145/2593882.2593900},
  isbn = {978-1-4503-2865-4},
  keywords = {Machine learning,Probabilistic programming,Program analysis},
  numpages = {15},
  series = {{{FOSE}} 2014}
}

@article{hanus1994integration,
  title = {The {{Integration}} of {{Functions}} into {{Logic Programming}}: {{From Theory}} to {{Practice}}},
  author = {Hanus, Michael},
  year = {1994},
  month = may,
  volume = {19/20},
  pages = {583--628},
  issn = {0743-1066},
  doi = {10.1016/0743-1066(94)90034-5},
  abstract = {Functional and logic programming are the most important declarative programming paradigms, and interest in combining them has grown over the last decade. Early research concentrated on the definition and improvement of execution principles for such integrated languages, while more recently efficient implementations of these execution principles have been developed so that these languages became relevant for practical applications. In this paper, we survey the development of the operational semantics as well as the improvement of the implementation of functional logic languages.},
  journal = {Journal of Logic Programming}
}

@inproceedings{hanus1995curry,
  title = {Curry: {{A}} Truly Functional Logic Language},
  booktitle = {Proceedings of the {{ILPS}} '95 {{Postconference Workshop}} on {{Visions}} for the {{Future}} of {{Logic Programming}}},
  author = {Hanus, Michael and Kuchen, Herbert and {Moreno-Navarro}, Juan Jose},
  year = {1995},
  pages = {95--107},
  number = {5}
}

@book{hanus2014kics2,
  title = {{{KiCS2}} - {{The Kiel Curry System User Manual Version}} 0.3.2 of 2014-07-30},
  author = {Hanus, Michael and Bra{\ss}el, Bernd and Peem{\"o}ller, Bj{\"o}rn and Reck, Fabian},
  year = {2014}
}

@book{hanus2017pakcs,
  title = {{{PAKCS}}: {{The Portland Aachen Kiel Curry System}}},
  author = {Hanus, Michael},
  year = {2017}
}

@inproceedings{hinze2000new,
  title = {A New Approach to Generic Functional Programming},
  booktitle = {Proceedings of the 27th {{ACM SIGPLAN}}-{{SIGACT}} Symposium on Principles of Programming Languages},
  author = {Hinze, Ralf},
  year = {2000},
  pages = {119--132},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/325694.325709},
  isbn = {1-58113-125-9},
  series = {{{POPL}} '00}
}

@book{horowitz1983fundamentals,
  title = {Fundamentals of Programming Languages},
  author = {Horowitz, Ellis},
  year = {1983},
  edition = {Second},
  publisher = {{Springer}},
  isbn = {978-3-642-69406-6}
}

@inproceedings{hudak2007history,
  title = {A {{History}} of {{Haskell}}: {{Being Lazy}} with {{Class}}},
  booktitle = {Proceedings of the Third {{ACM SIGPLAN Conference}} on {{History}} of {{Programming Languages}}},
  author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
  year = {2007},
  pages = {12-1-12-55},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1238844.1238856},
  isbn = {978-1-59593-766-7},
  series = {{{HOPL III}}}
}

@inproceedings{huffman2012formal,
  title = {Formal {{Verification}} of {{Monad Transformers}}},
  booktitle = {Proceedings of the 17th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Huffman, Brian},
  year = {2012},
  pages = {15--16},
  publisher = {{ACM}},
  address = {{Copenhagen, Denmark}},
  doi = {10.1145/2364527.2364532},
  archivePrefix = {arXiv},
  eprint = {1207.3208},
  eprinttype = {arxiv},
  isbn = {978-1-4503-1054-3},
  keywords = {Computer Science - Logic in Computer Science,denotational semantics,F.3.1,monads,polymorphism,theorem proving,type classes},
  numpages = {2},
  primaryClass = {cs},
  series = {{{ICFP}} '12}
}

@inproceedings{hutton2008reasoning,
  title = {Reasoning about Effects: {{Seeing}} the Wood through the Trees},
  booktitle = {Proceedings of the {{Ninth Symposium}} on {{Trends}} in {{Functional Programming}}},
  author = {Hutton, Graham and Fulger, Diana},
  year = {2008}
}

@book{hutton2016programming,
  title = {Programming in Haskell},
  author = {Hutton, Graham},
  year = {2016},
  edition = {Second},
  publisher = {{Cambridge University Press}},
  isbn = {978-1-316-62622-1}
}

@inproceedings{jeuring2012testing,
  title = {Testing {{Type Class Laws}}},
  booktitle = {Proceedings of the 2012 {{Haskell Symposium}}},
  author = {Jeuring, Johan and Jansson, Patrik and Amaral, Cl{\'a}udio},
  year = {2012},
  volume = {12},
  pages = {49--60},
  publisher = {{ACM}},
  address = {{Copenhagen, Denmark}},
  doi = {10.1145/2364506.2364514},
  isbn = {978-1-4503-1574-6},
  keywords = {classes,laws,state monad,testing},
  number = {12},
  numpages = {12},
  series = {Haskell '12}
}

@inproceedings{johann2004free,
  title = {Free {{Theorems}} in the {{Presence}} of Seq},
  booktitle = {Proceedings of the 31st {{ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  author = {Johann, Patricia and Voigtl{\"a}nder, Janis},
  year = {2004},
  pages = {99--110},
  publisher = {{ACM}},
  address = {{Venice, Italy}},
  doi = {10.1145/964001.964010},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QQy4uLy4uL1BhcGVycy9GcmVlIFRoZW9yZW1zL0ZyZWUgVGhlb3JlbXMgaW4gdGhlIFByZXNlbmNlIG9mIHNlcS5wZGbSFwsYGVdOUy5kYXRhTxECEAAAAAACEAACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAA0rzi3UgrAAAAbiGkH0ZyZWUgVGhlb3JlbXMgaW4gdGgjMUVEQzFENS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHtwdXWIl3uAAAAAAAAAAAAAgADAAAJIAAAAAAAAAAAAAAAAAAAAA1GcmVlIFRoZW9yZW1zAAAQAAgAANK81M0AAAARAAgAANYiT94AAAABABQAbiGkABbHdgAJXXYACV11AAYsowACAFpNYWNpbnRvc2ggSEQ6VXNlcnM6AGphYzoARG9jdW1lbnRzOgBQYXBlcnM6AEZyZWUgVGhlb3JlbXM6AEZyZWUgVGhlb3JlbXMgaW4gdGgjMUVEQzFENS5wZGYADgBSACgARgByAGUAZQAgAFQAaABlAG8AcgBlAG0AcwAgAGkAbgAgAHQAaABlACAAUAByAGUAcwBlAG4AYwBlACAAbwBmACAAcwBlAHEALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAFFVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9GcmVlIFRoZW9yZW1zL0ZyZWUgVGhlb3JlbXMgaW4gdGhlIFByZXNlbmNlIG9mIHNlcS5wZGYAABMAAS8AABUAAgAK//8AAIAG0hscHR5aJGNsYXNzbmFtZVgkY2xhc3Nlc11OU011dGFibGVEYXRhox0fIFZOU0RhdGFYTlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVkQXJjaGl2ZXLRJidUcm9vdIABAAgAEQAaACMALQAyADcAQABGAE0AVQBgAGcAagBsAG4AcQBzAHUAdwCEAI4A1ADZAOEC9QL3AvwDBwMQAx4DIgMpAzIDNwNEA0cDWQNcA2EAAAAAAAACAQAAAAAAAAAoAAAAAAAAAAAAAAAAAAADYw==},
  isbn = {1-58113-729-X},
  keywords = {controlling strict evaluation,correctness proofs,denotational semantics,Haskell,logical relations,parametricity,program transformations,short cut fusion,theorems for free},
  series = {{{POPL}} '04}
}

@inproceedings{johann2010generic,
  title = {A {{Generic Operational Metatheory}} for {{Algebraic Effects}}},
  booktitle = {2010 25th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Johann, Patricia and Simpson, Alex and Voigtl{\"a}nder, Janis},
  year = {2010},
  pages = {209--218},
  address = {{Edinburgh}},
  doi = {10.1109/LICS.2010.29},
  isbn = {1043-6871},
  keywords = {algebra,algebraic effects,Context,contextual preorder,Equations,generic operational metatheory,Machinery,Manganese,Pediatrics,polymorphic programming language,programming language semantics,relational parametricity,Semantics,structural operational semantics,syntactic analysis,Syntactics}
}

@article{johnson1963generation,
  title = {Generation of {{Permutations}} by {{Adjacent Transposition}}},
  author = {Johnson, Selmer M.},
  year = {1963},
  volume = {17},
  pages = {282--285},
  publisher = {{American Mathematical Society}},
  issn = {00255718, 10886842},
  doi = {10.2307/2003846},
  journal = {Mathematics of Computation},
  number = {83}
}

@book{jones2002haskell,
  title = {Haskell 98 {{Language}} and {{Libraries}}: {{The Revised Report}}},
  author = {Peyton Jones, Simon},
  year = {2002},
  month = sep,
  keywords = {functional-programming haskell}
}

@inproceedings{kammar2013handlers,
  title = {Handlers in Action},
  booktitle = {Proceedings of the 18th {{ACM SIGPLAN}} International Conference on Functional Programming},
  author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
  year = {2013},
  pages = {145--158},
  publisher = {{ACM}},
  address = {{Boston, Massachusetts, USA}},
  doi = {10.1145/2500365.2500590},
  isbn = {978-1-4503-2326-0},
  keywords = {algebraic effects,continuations,effect handlers,effect typing,haskell,modularity,monads},
  number = {9},
  numpages = {14},
  series = {{{ICFP}} '13}
}

@article{kimmig2011implementation,
  title = {On the {{Implementation}} of the {{Probabilistic Logic Programming Language ProbLog}}},
  author = {Kimmig, Angelika and Demoen, Bart and De Raedt, Luc and Costa, V{\'i}tor Santos and Rocha, Ricardo},
  year = {2011},
  volume = {11},
  pages = {235--262},
  doi = {10.1017/S1471068410000566},
  journal = {Theory and Practice of Logic Programming},
  number = {2-3}
}

@inproceedings{kiselyov2009embedded,
  title = {Embedded {{Probabilistic Programming}}},
  booktitle = {Domain-{{Specific Languages}}},
  author = {Kiselyov, Oleg and Shan, Chung-chieh},
  year = {2009},
  volume = {5658},
  pages = {360---384},
  publisher = {{Springer}},
  doi = {10.1007/978-3-642-03034-5_17},
  abstract = {Two general techniques for implementing a domain-specific language (DSL) with less overhead are the finally-tagless embedding of object programs and the direct-style representation of side effects. We use these techniques to build a DSL for probabilistic programming, for expressing countable probabilistic models and performing exact inference and importance sampling on them. Our language is embedded as an ordinary OCaml library and represents probability distributions as ordinary OCaml programs. We use delimited continuations to reify probabilistic programs as lazy search trees, which inference algorithms may traverse without imposing any interpretive overhead on deterministic parts of a model. We thus take advantage of the existing OCaml implementation to achieve competitive performance and ease of use. Inference algorithms can easily be embedded in probabilistic programs themselves.},
  isbn = {978-3-642-03034-5},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{kiselyov2015freer,
  title = {Freer {{Monads}}, {{More Extensible Effects}}},
  booktitle = {Proceedings of the 2015 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  author = {Kiselyov, Oleg and Ishii, Hiromi},
  year = {2015},
  pages = {94--105},
  publisher = {{ACM}},
  address = {{Vancouver, BC, Canada}},
  doi = {10.1145/2804302.2804319},
  isbn = {978-1-4503-3808-0},
  keywords = {coroutine,effect handler,effect interaction,free monad,Kan extension,open union,type and effect system},
  numpages = {12},
  series = {Haskell '15}
}

@inproceedings{kiselyov2016eff,
  title = {Eff Directly in {{OCaml}}},
  booktitle = {Proceedings {{ML}} Family Workshop / {{OCaml}} Users and Developers Workshops, {{ML}}/{{OCAML}} 2016, Nara, Japan, September 22-23, 2016},
  author = {Kiselyov, Oleg and Sivaramakrishnan, K. C.},
  editor = {Asai, Kenichi and Shinwell, Mark R.},
  year = {2016},
  volume = {285},
  pages = {23--58},
  doi = {10.4204/EPTCS.285.2},
  series = {Electronic {{Proceedings}} in {{Theoretical Computer Science}}}
}

@inproceedings{koh2019interaction,
  ids = {10.1145/3293880.3294106},
  title = {From {{C}} to {{Interaction Trees}}: {{Specifying}}, {{Verifying}}, and {{Testing}} a {{Networked Server}}},
  shorttitle = {From {{C}} to {{Interaction Trees}}},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}} - {{CPP}} 2019},
  author = {Koh, Nicolas and Li, Yao and Li, Yishuai and Xia, Li-yao and Beringer, Lennart and Honor{\'e}, Wolf and Mansky, William and Pierce, Benjamin C. and Zdancewic, Steve},
  year = {2019},
  pages = {234--248},
  publisher = {{ACM Press}},
  address = {{Cascais, Portugal}},
  doi = {10.1145/3293880.3294106},
  abstract = {We present the first formal verification of a networked server implemented in C. Interaction trees, a general structure for representing reactive computations, are used to tie together disparate verification and testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of the operating system on which the server runs (CertiKOS). The main theorem connects a specification of acceptable server behaviors, written in a straightforward ``one client at a time'' style, with the CompCert semantics of the C program. The variability introduced by low-level buffering of messages and interleaving of multiple TCP connections is captured using network refinement, a variant of observational refinement.},
  isbn = {978-1-4503-6222-1},
  keywords = {formal verification,interaction trees,network refinement,QuickChick,TCP,testing,VST},
  language = {English},
  numpages = {15},
  place = {Cascais, Portugal},
  series = {{{CPP}} 2019}
}

@inproceedings{launchbury1993natural,
  title = {A Natural Semantics for Lazy Evaluation},
  booktitle = {Proceedings of the 20th {{ACM SIGPLAN}}-{{SIGACT}} Symposium on Principles of Programming Languages},
  author = {Launchbury, John},
  year = {1993},
  pages = {144--154},
  publisher = {{ACM}},
  address = {{New York, NY, USA}},
  doi = {10.1145/158511.158618},
  isbn = {0-89791-560-7},
  series = {{{POPL}} '93}
}

@techreport{leijen2016algebraic,
  title = {Algebraic {{Effects}} for {{Functional Programming}}},
  author = {Leijen, Daan},
  year = {2016},
  pages = {15},
  institution = {{Microsoft Research}},
  type = {Technical {{Report}}}
}

@inproceedings{letan2018modular,
  title = {Modular {{Verification}} of {{Programs}} with {{Effects}} and {{Effect Handlers}} in {{Coq}}},
  booktitle = {Formal {{Methods}}},
  author = {Letan, Thomas and {R{\'e}gis-Gianas}, Yann and Chifflier, Pierre and Hiet, Guillaume},
  year = {2018},
  volume = {10951},
  pages = {338--354},
  publisher = {{Springer}},
  doi = {10.1007/978-3-319-95582-7_20},
  abstract = {Modern computing systems have grown in complexity, and the attack surface has increased accordingly. Even though system components are generally carefully designed and even verified by different groups of people, the composition of these components is often regarded with less attention. This paves the way for ``architectural attacks'', a class of security vulnerabilities where the attacker is able to threaten the security of the system even if each of its components continues to act as expected. In this article, we introduce FreeSpec, a formalism built upon the key idea that components can be modelled as programs with algebraic effects to be realized by other components. FreeSpec allows for the modular modelling of a complex system, by defining idealized components connected together, and the modular verification of the properties of their composition. In addition, we have implemented a framework for the Coq proof assistant based on FreeSpec.},
  isbn = {978-3-319-95582-7},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{lindley2017be,
  title = {Do {{Be Do Be Do}}},
  booktitle = {Proceedings of the 44th {{ACM SIGPLAN Symposium}} on {{Principles}} of {{Programming Languages}}},
  author = {Lindley, Sam and McBride, Conor and McLaughlin, Craig},
  year = {2017},
  pages = {500--514},
  publisher = {{ACM}},
  address = {{Paris, France}},
  doi = {10.1145/3009837.3009897},
  acmid = {3009897},
  isbn = {978-1-4503-4660-3},
  keywords = {algebraic effects,bidirectional typing,call-by-push-value,continuations,effect handlers,effect polymorphism,pattern matching},
  numpages = {15},
  series = {{{POPL}} 2017}
}

@inproceedings{lopez2018basic,
  title = {Basic Operational Preorders for Algebraic Effects in General, and for Combined Probability and Nondeterminism in Particular},
  booktitle = {27th {{EACSL}} Annual Conference on Computer Science Logic ({{CSL}} 2018)},
  author = {Lopez, Aliaume and Simpson, Alex},
  editor = {Ghica, Dan and Jung, Achim},
  year = {2018},
  volume = {119},
  pages = {29:1-29:17},
  publisher = {{Schloss Dagstuhl\textendash{}Leibniz-Zentrum fuer Informatik}},
  address = {{Dagstuhl, Germany}},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.CSL.2018.29},
  isbn = {978-3-95977-088-0},
  series = {Leibniz International Proceedings in Informatics ({{LIPIcs}})},
  urn = {urn:nbn:de:0030-drops-96965}
}

@inproceedings{matthes2008recursion,
  title = {Recursion on {{Nested Datatypes}} in {{Dependent Type Theory}}},
  booktitle = {Logic and {{Theory}} of {{Algorithms}}},
  author = {Matthes, Ralph},
  year = {2008},
  volume = {5028},
  pages = {431--446},
  publisher = {{Springer}},
  doi = {10.1007/978-3-540-69407-6_47},
  isbn = {978-3-540-69407-6},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{mcbride2015turingcompleteness,
  title = {Turing-{{Completeness Totally Free}}},
  booktitle = {Mathematics of {{Program Construction}}},
  author = {McBride, Conor},
  year = {2015},
  volume = {9129},
  pages = {257--275},
  publisher = {{Springer}},
  doi = {10.1007/978-3-319-19797-5_13},
  abstract = {In this paper, I show that general recursive definitions can be represented in the free monad which supports the `effect' of making a recursive call, without saying how these calls should be executed. Diverse semantics can be given within a total framework by suitable monad morphisms. The Bove-Capretta construction of the domain of a general recursive function can be presented datatype-generically as an instance of this technique. The paper is literate Agda, but its key ideas are more broadly transferable.},
  isbn = {978-3-319-19797-5},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@incollection{mccallum2009factorie,
  title = {{{FACTORIE}}: {{Probabilistic Programming}} via {{Imperatively Defined Factor Graphs}}},
  booktitle = {Advances in {{Neural Information Processing Systems}} 22},
  author = {McCallum, Andrew and Schultz, Karl and Singh, Sameer},
  editor = {Bengio, Y. and Schuurmans, D. and Lafferty, J. D. and Williams, C. K. I. and Culotta, A.},
  year = {2009},
  pages = {1249--1257},
  publisher = {{Curran Associates, Inc.}},
  address = {{Vancouver, British Columbia, Canada}}
}

@inproceedings{mehner2014parametricity,
  title = {Parametricity and {{Proving Free Theorems}} for {{Functional}}-{{Logic Languages}}},
  booktitle = {Proceedings of the 16th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}}},
  author = {Mehner, Stefan and Seidel, Daniel and Stra{\ss}burger, Lutz and Voigtl{\"a}nder, Janis},
  year = {2014},
  pages = {19--30},
  publisher = {{ACM}},
  address = {{Canterbury, United Kingdom}},
  doi = {10.1145/2643135.2643147},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QZS4uLy4uL1BhcGVycy9GcmVlIFRoZW9yZW1zL1BhcmFtZXRyaWNpdHkgYW5kIFByb3ZpbmcgRnJlZSBUaGVvcmVtcyBmb3IgRnVuY3Rpb25hbC1Mb2dpYyBMYW5ndWFnZXMucGRm0hcLGBlXTlMuZGF0YU8RAnYAAAAAAnYAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAANK84t1IKwAAAG4hpB9QYXJhbWV0cmljaXR5IGFuZCBQIzExMjBBQjcucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEgq31MMfBVBERiAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAANRnJlZSBUaGVvcmVtcwAAEAAIAADSvNTNAAAAEQAIAADUwxD1AAAAAQAUAG4hpAAWx3YACV12AAlddQAGLKMAAgBaTWFjaW50b3NoIEhEOlVzZXJzOgBqYWM6AERvY3VtZW50czoAUGFwZXJzOgBGcmVlIFRoZW9yZW1zOgBQYXJhbWV0cmljaXR5IGFuZCBQIzExMjBBQjcucGRmAA4AlgBKAFAAYQByAGEAbQBlAHQAcgBpAGMAaQB0AHkAIABhAG4AZAAgAFAAcgBvAHYAaQBuAGcAIABGAHIAZQBlACAAVABoAGUAbwByAGUAbQBzACAAZgBvAHIAIABGAHUAbgBjAHQAaQBvAG4AYQBsAC0ATABvAGcAaQBjACAATABhAG4AZwB1AGEAZwBlAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAHNVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9GcmVlIFRoZW9yZW1zL1BhcmFtZXRyaWNpdHkgYW5kIFByb3ZpbmcgRnJlZSBUaGVvcmVtcyBmb3IgRnVuY3Rpb25hbC1Mb2dpYyBMYW5ndWFnZXMucGRmAAATAAEvAAAVAAIACv//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAPYA+wEDA30DfwOEA48DmAOmA6oDsQO6A78DzAPPA+ED5APpAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA+s=},
  isbn = {978-1-4503-2947-7},
  keywords = {Curry,free theorems,functional logic programming},
  numpages = {12},
  series = {{{PPDP}} '14}
}

@book{minsky2013real,
  title = {Real World {{OCaml}}: Functional Programming for the Masses},
  author = {Minsky, Yaron and Madhavapeddy, Anil and Hickey, Jason},
  year = {2013},
  publisher = {{O'Reilly Media, Inc.}}
}

@article{nampally2018constraintbased,
  ids = {nampally2015constraintbased},
  title = {Constraint-{{Based Inference}} in {{Probabilistic Logic Programs}}},
  author = {Nampally, Arun and Zhang, Timothy and Ramakrishan, C. R.},
  year = {2018},
  edition = {2018/08/10},
  volume = {18},
  pages = {638--655},
  publisher = {{Cambridge University Press}},
  issn = {1471-0684},
  doi = {10.1017/S1471068418000273},
  abstract = {Probabilistic Logic Programs (PLPs) generalize traditional logic programs and allow the encoding of models combining logical structure and uncertainty. In PLP, inference is performed by summarizing the possible worlds which entail the query in a suitable data structure, and using this data structure to compute the answer probability. Systems such as ProbLog, PITA, etc., use propositional data structures like explanation graphs, BDDs, SDDs, etc., to represent the possible worlds. While this approach saves inference time due to substructure sharing, there are a number of problems where a more compact data structure is possible. We propose a data structure called Ordered Symbolic Derivation Diagram (OSDD) which captures the possible worlds by means of constraint formulas. We describe a program transformation technique to construct OSDDs via query evaluation, and give procedures to perform exact and approximate inference over OSDDs. Our approach has two key properties. Firstly, the exact inference procedure is a generalization of traditional inference, and results in speedup over the latter in certain settings. Secondly, the approximate technique is a generalization of likelihood weighting in Bayesian Networks, and allows us to perform sampling-based inference with lower rejection rate and variance. We evaluate the effectiveness of the proposed techniques through experiments on several problems.},
  journal = {Theory and Practice of Logic Programming},
  number = {3-4}
}

@inproceedings{norell2009dependently,
  ids = {norell2009dependentlya},
  title = {Dependently {{Typed Programming}} in {{Agda}}},
  booktitle = {Proceedings of the 4th {{International Workshop}} on {{Types}} in {{Language Design}} and {{Implementation}}},
  author = {Norell, Ulf},
  year = {2009},
  pages = {1---2},
  publisher = {{ACM}},
  address = {{Savannah, GA, USA}},
  doi = {10.1145/1481861.1481862},
  isbn = {978-1-60558-420-1},
  keywords = {dependent types,programming},
  series = {{{TLDI}} '09}
}

@inproceedings{paige2014compilation,
  title = {A {{Compilation Target}} for {{Probabilistic Programming Languages}}},
  booktitle = {Proceedings of the 31st {{International Conference}} on {{Machine Learning}}},
  author = {Paige, Brooks and Wood, Frank},
  editor = {Eric P. Xing and {Tony Jebara}},
  year = {2014},
  month = jan,
  pages = {1935--1943},
  publisher = {{PMLR}},
  abstract = {Forward inference techniques such as sequential Monte Carlo and particle Markov chain Monte Carlo for probabilistic programming can be implemented in any programming language by creative use of standardized operating system functionality including processes, forking, mutexes, and shared memory.   Exploiting this we have defined, developed, and tested a probabilistic programming language intermediate representation language we call probabilistic C, which itself can be compiled to machine code by standard compilers and linked to operating system libraries yielding an efficient, scalable, portable probabilistic programming compilation target.  This opens up a new hardware and systems research path for optimizing probabilistic programming systems.}
}

@book{pearl2014probabilistic,
  title = {Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference},
  author = {Pearl, Judea},
  year = {1988},
  publisher = {{Morgan Kaufmann}},
  series = {Morgan {{Kaufmann Series}} in {{Representation}} and {{Reasoning}}}
}

@inproceedings{pfenning1988higherorder,
  title = {Higher-Order Abstract Syntax},
  booktitle = {Proceedings of the {{ACM SIGPLAN}} 1988 Conference on Programming Language Design and Implementation},
  author = {Pfenning, Frank and Elliott, Conal},
  year = {1988},
  volume = {23},
  pages = {199--208},
  publisher = {{ACM}},
  address = {{Atlanta, Georgia, USA}},
  doi = {10.1145/53990.54010},
  isbn = {0-89791-269-1},
  numpages = {10},
  series = {{{PLDI}} '88}
}

@unpublished{pierce2010software,
  title = {Software {{Foundations}}},
  author = {Pierce, Benjamin C and Casinghino, Chris and Gaboardi, Marco and Greenberg, Michael and Hri{\c t}cu, C{\u a}t{\u a}lin and Sj{\"o}berg, Vilhelm and Yorgey, Brent},
  year = {2010},
  type = {Electronic Textbook}
}

@article{pirog2012tracing,
  title = {Tracing {{Monadic Computations}} and {{Representing Effects}}},
  author = {Pir{\'o}g, Maciej and Gibbons, Jeremy},
  year = {2012},
  volume = {76},
  pages = {90--111},
  journal = {Electronic Proceedings in Theoretical Computer Science},
  language = {English}
}

@inproceedings{pirog2018syntax,
  title = {Syntax and {{Semantics}} for {{Operations}} with {{Scopes}}},
  booktitle = {Proceedings of the 33rd {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Pir{\'o}g, Maciej and Schrijvers, Tom and Wu, Nicolas and Jaskelioff, Mauro},
  year = {2018},
  pages = {809--818},
  publisher = {{ACM}},
  address = {{Oxford, United Kingdom}},
  doi = {10.1145/3209108.3209166},
  isbn = {978-1-4503-5583-4},
  keywords = {algebraic effects,effect handler,free monad},
  series = {{{LICS}} '18}
}

@inproceedings{plotkin2009handlers,
  ids = {plotkin2009handlers},
  title = {Handlers of {{Algebraic Effects}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Plotkin, Gordon and Pretnar, Matija},
  editor = {Castagna, Giuseppe},
  year = {2009},
  volume = {5502},
  pages = {80--94},
  publisher = {{Springer}},
  doi = {0.1007/978-3-642-00590-9_7},
  abstract = {We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.},
  isbn = {978-3-642-00590-9},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{pretnar2015introduction,
  title = {An {{Introduction}} to {{Algebraic Effects}} and {{Handlers}}. {{Invited}} Tutorial Paper},
  author = {Pretnar, Matija},
  year = {2015},
  volume = {319},
  pages = {19--35},
  publisher = {{Elsevier}},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2015.12.003},
  abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type \& effect system, show how one can reason about effects, and give pointers for further reading.},
  journal = {The 31st Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXI).},
  keywords = {algebraic effects,effect system,handlers,logic,semantics,tutorial}
}

@inproceedings{runciman2008smallcheck,
  title = {{{SmallCheck}} and {{Lazy SmallCheck}}: {{Automatic Exhaustive Testing}} for {{Small Values}}},
  booktitle = {Proceedings of the {{First ACM SIGPLAN Symposium}} on {{Haskell}}},
  author = {Runciman, Colin and Naylor, Matthew and Lindblad, Fredrik},
  year = {2008},
  pages = {37--48},
  publisher = {{ACM}},
  address = {{Victoria, BC, Canada}},
  doi = {10.1145/1411286.1411292},
  isbn = {978-1-60558-064-7},
  series = {Haskell '08}
}

@phdthesis{santos1995compilation,
  title = {Compilation by {{Transformation}} in {{Non}}-{{Strict Functional Languages}}},
  author = {Santos, Andr{\'e} Lu{\'i}s de Medeiros},
  year = {1995},
  publisher = {{Citeseer}},
  school = {University of Glasgow}
}

@inproceedings{scibior2015practical,
  title = {Practical {{Probabilistic Programming}} with {{Monads}}},
  booktitle = {Proceedings of the 2015 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  author = {{\'S}cibior, Adam and Ghahramani, Zoubin and Gordon, Andrew D.},
  year = {2015},
  pages = {165--176},
  publisher = {{ACM}},
  address = {{Vancouver, BC, Canada}},
  doi = {10.1145/2804302.2804317},
  isbn = {978-1-4503-3808-0},
  keywords = {Bayesian statistics,Haskell,monads,Monte Carlo,probabilistic programming},
  numpages = {12},
  place = {Vancouver, BC, Canada},
  series = {Haskell '15}
}

@article{sedgewick1977permutation,
  title = {Permutation {{Generation Methods}}},
  author = {Sedgewick, Robert},
  year = {1977},
  volume = {9},
  pages = {137--164},
  publisher = {{ACM}},
  issn = {0360-0300},
  doi = {10.1145/356689.356692},
  journal = {ACM Computing Surveys},
  number = {2},
  numpages = {28}
}

@article{sheard2004twolevel,
  ids = {sheard2004twolevela},
  title = {Two-{{Level Types}} and {{Parameterized Modules}}},
  author = {Sheard, Tim and Pasalic, Emir},
  year = {2004},
  edition = {2004/08/06},
  volume = {14},
  pages = {547--587},
  publisher = {{Cambridge University Press}},
  issn = {0956-7968},
  doi = {10.1017/S095679680300488X},
  abstract = {In this paper, we describe two techniques for the efficient, modularized implementation of a large class of algorithms. We illustrate these techniques using several examples, including efficient generic unification algorithms that use reference cells to encode substitutions, and highly modular language implementations.},
  journal = {Journal of Functional Programming},
  language = {English},
  number = {5}
}

@article{smyth1982category,
  title = {The {{Category}}-{{Theoretic Solution}} of {{Recursive Domain Equations}}},
  author = {Smyth, M. B. and Plotkin, G. D.},
  year = {1982},
  month = nov,
  volume = {11},
  pages = {761--783},
  publisher = {{SIAM}},
  issn = {0097-5397},
  doi = {10.1137/0211062},
  journal = {SIAM Journal on Computing},
  number = {4}
}

@inproceedings{spector-zabusky2018total,
  title = {Total {{Haskell}} Is {{Reasonable Coq}}},
  booktitle = {Proceedings of the 7th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {{Spector-Zabusky}, Antal and Breitner, Joachim and Rizkallah, Christine and Weirich, Stephanie},
  year = {2018},
  pages = {14---27},
  publisher = {{ACM}},
  address = {{Los Angeles, USA}},
  doi = {10.1145/3167092},
  abstract = {We would like to use the Coq proof assistant to mechanically verify properties of Haskell programs. To that end, we present a tool, named {$<$}tt{$>$}hs-to-coq{$<$}/tt{$>$}, that translates total Haskell programs into Coq programs via a shallow embedding. We apply our tool in three case studies \textendash{} a lawful {$<$}tt{$>$}Monad{$<$}/tt{$>$} instance, ``Hutton's razor'', and an existing data structure library \textendash{} and prove their correctness. These examples show that this approach is viable: both that {$<$}tt{$>$}hs-to-coq{$<$}/tt{$>$} applies to existing Haskell code, and that the output it produces is amenable to verification.},
  file = {/Users/sad/Zotero/storage/Z5QLKAF6/Spector-Zabusky et al. - 2018 - Total Haskell is Reasonable Coq.pdf},
  isbn = {978-1-4503-5586-5},
  keywords = {Coq,Haskell,verification},
  series = {{{CPP}} 2018}
}

@article{sternagel2013proof,
  title = {Proof {{Pearl}}\textemdash{{A Mechanized Proof}} of {{GHC}}'s {{Mergesort}}},
  author = {Sternagel, Christian},
  year = {2013},
  volume = {51},
  pages = {357--370},
  issn = {1573-0670},
  doi = {10.1007/s10817-012-9260-7},
  abstract = {We present our Isabelle/HOL formalization of GHC's sorting algorithm for lists, proving its correctness and stability. This constitutes another example of applying a state-of-the-art proof assistant to real-world code. Furthermore, it allows users to take advantage of the formalized algorithm in generated code.},
  journal = {Journal of Automated Reasoning},
  number = {4}
}

@inproceedings{swamy2016dependent,
  title = {Dependent {{Types}} and {{Multi}}-{{Monadic Effects}} in {{F}}*},
  booktitle = {Proceedings of the 43rd {{Annual ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  author = {Swamy, Nikhil and Hritcu, Catalin and Keller, Chantal and Rastogi, Aseem and {Delignat-Lavaud}, Antoine and Forest, Simon and Bhargavan, Karthikeyan and Fournet, C{\'e}dric and Strub, Pierre-Yves and Kohlweiss, Markulf and Zinzindohou{\'e}, Jean-Karim and {Zanella-B{\'e}guelin}, Santiago},
  year = {2016},
  pages = {256--270},
  publisher = {{ACM}},
  doi = {10.1145/2837614.2837655},
  ee = {http://dx.doi.org/10.1145/2837614.2837655},
  isbn = {978-1-4503-3549-2},
  series = {{{POPL}} '16},
  shortbooktitle = {POPL}
}

@article{swierstra2008data,
  title = {Data {{Types}} {\`a} La {{Carte}}},
  author = {Swierstra, Wouter},
  year = {2008},
  volume = {18},
  pages = {423--436},
  publisher = {Cambridge University Press},
  location = {New York, NY, USA},
  doi = {10.1017/S0956796808006758},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QMi4uLy4uL1BhcGVycy9EYXRhIFN0cnVjdHVyZXMvRGF0YVR5cGVzQUxhQ2FydGUucGRm0hcLGBlXTlMuZGF0YU8RAdIAAAAAAdIAAgAADE1hY2ludG9zaCBIRAAAAAAAAAAAAAAAAAAAANK84t1IKwAAAKjdYhVEYXRhVHlwZXNBTGFDYXJ0ZS5wZGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqYCM1A/uGgAAAAAAAAAAAAIAAwAACSAAAAAAAAAAAAAAAAAAAAAPRGF0YSBTdHJ1Y3R1cmVzAAAQAAgAANK81M0AAAARAAgAANQP0foAAAABABQAqN1iABbHdgAJXXYACV11AAYsowACAFJNYWNpbnRvc2ggSEQ6VXNlcnM6AGphYzoARG9jdW1lbnRzOgBQYXBlcnM6AERhdGEgU3RydWN0dXJlczoARGF0YVR5cGVzQUxhQ2FydGUucGRmAA4ALAAVAEQAYQB0AGEAVAB5AHAAZQBzAEEATABhAEMAYQByAHQAZQAuAHAAZABmAA8AGgAMAE0AYQBjAGkAbgB0AG8AcwBoACAASABEABIAQFVzZXJzL2phYy9Eb2N1bWVudHMvUGFwZXJzL0RhdGEgU3RydWN0dXJlcy9EYXRhVHlwZXNBTGFDYXJ0ZS5wZGYAEwABLwAAFQACAAr//wAAgAbSGxwdHlokY2xhc3NuYW1lWCRjbGFzc2VzXU5TTXV0YWJsZURhdGGjHR8gVk5TRGF0YVhOU09iamVjdNIbHCIjXE5TRGljdGlvbmFyeaIiIF8QD05TS2V5ZWRBcmNoaXZlctEmJ1Ryb290gAEACAARABoAIwAtADIANwBAAEYATQBVAGAAZwBqAGwAbgBxAHMAdQB3AIQAjgDDAMgA0AKmAqgCrQK4AsECzwLTAtoC4wLoAvUC+AMKAw0DEgAAAAAAAAIBAAAAAAAAACgAAAAAAAAAAAAAAAAAAAMU},
  journal = {Journal of Functional Programming},
  number = {4}
}

@article{trotter1962algorithm,
  title = {Algorithm 115: {{Perm}}},
  author = {Trotter, Hale F.},
  year = {1962},
  volume = {5},
  pages = {434--435},
  publisher = {{ACM}},
  issn = {0001-0782},
  doi = {10.1145/368637.368660},
  journal = {Communications of the ACM},
  number = {8},
  numpages = {2}
}

@inproceedings{uustalu2017container,
  ids = {uustalu2017container},
  title = {Container {{Combinatorics}}: {{Monads}} and {{Lax Monoidal Functors}}},
  booktitle = {Topics in {{Theoretical Computer Science}}},
  author = {Uustalu, Tarmo},
  editor = {Mousavi, Mohammad Reza and Sgall, Ji{\v r}{\'i}},
  year = {2017},
  volume = {10608},
  pages = {91--105},
  publisher = {{Springer}},
  doi = {10.1007/978-3-319-68953-1},
  abstract = {Abbott et al.'s containers are a ``syntax'' for a wide class of set functors in terms of shapes and positions. Containers whose ``denotation'' carries a comonad structure can be characterized as directed containers, or containers where a shape and a position in it determine another shape, intuitively a subshape of this shape rooted by this position. In this paper, we develop similar explicit characterizations for container functors with a monad structure and container functors with a lax monoidal functor structure as well as some variations. We argue that this type of characterizations make a tool, e.g., for enumerating the monad structures or lax monoidal functors that some set functor admits. Such explorations are of interest, e.g., in the semantics of effectful functional programming languages.},
  isbn = {978-3-319-68953-1},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{uustalu2017partiality,
  title = {Partiality and {{Container Monads}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Uustalu, Tarmo and Veltri, Niccol{\`o}},
  editor = {Chang, Bor-Yuh Evan},
  year = {2017},
  volume = {10695},
  pages = {406--425},
  publisher = {{Springer}},
  doi = {10.1007/978-3-319-71237-6_20},
  abstract = {We investigate monads of partiality in Martin-L{\"o}f type theory, following Moggi's general monad-based method for modelling effectful computations. These monads are often called lifting monads and appear in category theory with different but related definitions. In this paper, we unveil the relationship between containers and lifting monads. We show that the lifting monads usually employed in type theory can be specified in terms of containers. Moreover, we give a precise characterization of containers whose interpretations carry a lifting monad structure. We show that these conditions are tightly connected with Rosolini's notion of dominance. We provide several examples, putting particular emphasis on Capretta's delay monad and its quotiented variant, the non-termination monad.},
  isbn = {978-3-319-71237-6},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@incollection{vaneekelen2006proof,
  title = {Proof {{Tool Support}} for {{Explicit Strictness}}},
  booktitle = {Implementation and {{Application}} of {{Functional Languages}}},
  author = {{van Eekelen}, Marko and {de Mol}, Maarten},
  year = {2006},
  volume = {4015},
  pages = {37--54},
  publisher = {{Springer}},
  isbn = {978-3-540-69175-4},
  language = {English},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@book{vanlaarhoven2007haskell,
  title = {Haskell Mailing List},
  author = {{van Laarhoven}, Twan and others},
  year = {2007},
  month = dec
}

@article{varacca2006distributing,
  title = {Distributing {{Probability}} over {{Non}}-Determinism},
  author = {Varacca, Daniele and Winskel, Glynn},
  year = {2006},
  volume = {16},
  pages = {87--113},
  doi = {10.1017/S0960129505005074},
  journal = {Mathematical Structures in Computer Science},
  number = {1}
}

@misc{wadler1985replace,
  title = {How to Replace Failure by a List of Successes a Method for Exception Handling, Backtracking, and Pattern Matching in Lazy Functional Languages},
  author = {Wadler, Philip},
  year = {1985},
  pages = {113--128},
  publisher = {{Springer}},
  bdsk-file-1 = {YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QTi4uLy4uL1BhcGVycy9Ob24tRGV0ZXJtaW5pc20vSG93IHRvIHJlcGxhY2UgZmFpbHVyZSBieSBhIGxpc3Qgb2Ygc3VjY2Vzc2VzLnBkZtIXCxgZV05TLmRhdGFPEQIwAAAAAAIwAAIAAAxNYWNpbnRvc2ggSEQAAAAAAAAAAAAAAAAAAADSvOLdSCsAAAImrNofSG93IHRvIHJlcGxhY2UgZmFpbCMyMjZBQ0I5LnBkZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiasudaaXN9QREYgAAAAAAACAAMAAAkgAAAAAAAAAAAAAAAAAAAAD05vbi1EZXRlcm1pbmlzbQAAEAAIAADSvNTNAAAAEQAIAADWmk7PAAAAAQAUAias2gAWx3YACV12AAlddQAGLKMAAgBcTWFjaW50b3NoIEhEOlVzZXJzOgBqYWM6AERvY3VtZW50czoAUGFwZXJzOgBOb24tRGV0ZXJtaW5pc206AEhvdyB0byByZXBsYWNlIGZhaWwjMjI2QUNCOS5wZGYADgBkADEASABvAHcAIAB0AG8AIAByAGUAcABsAGEAYwBlACAAZgBhAGkAbAB1AHIAZQAgAGIAeQAgAGEAIABsAGkAcwB0ACAAbwBmACAAcwB1AGMAYwBlAHMAcwBlAHMALgBwAGQAZgAPABoADABNAGEAYwBpAG4AdABvAHMAaAAgAEgARAASAFxVc2Vycy9qYWMvRG9jdW1lbnRzL1BhcGVycy9Ob24tRGV0ZXJtaW5pc20vSG93IHRvIHJlcGxhY2UgZmFpbHVyZSBieSBhIGxpc3Qgb2Ygc3VjY2Vzc2VzLnBkZgATAAEvAAAVAAIACv//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAN8A5ADsAyADIgMnAzIDOwNJA00DVANdA2IDbwNyA4QDhwOMAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAA44=},
  journal = {Proceedings of the International Conference on Functional Programming Languages and Computer Architecture}
}

@inproceedings{wadler1989theorems,
  title = {Theorems for Free!},
  booktitle = {Proceedings of the {{Fourth International Conference}} on {{Functional Programming}} Languages and {{Computer Architecture}}},
  author = {Wadler, Philip},
  year = {1989},
  pages = {347--359},
  publisher = {{ACM}},
  address = {{London, United Kingdom}},
  doi = {10.1145/99370.99404},
  isbn = {0-89791-328-0},
  keywords = {free theorems,Haskell},
  numpages = {13},
  series = {{{FPCA}} '89}
}

@article{wadler1997declare,
  title = {How to Declare an Imperative},
  author = {Wadler, Philip},
  year = {1997},
  month = sep,
  volume = {29},
  pages = {240--263},
  publisher = {{ACM}},
  issn = {0360-0300},
  doi = {10.1145/262009.262011},
  journal = {ACM Computing Surveys},
  keywords = {functional programming,Haskell,monad},
  number = {3},
  numpages = {24}
}

@article{wadler2015propositions,
  title = {Propositions as {{Types}}},
  author = {Wadler, Philip},
  year = {2015},
  volume = {58},
  pages = {75--84},
  publisher = {{ACM}},
  issn = {0001-0782},
  doi = {10.1145/2699407},
  journal = {Communications of the ACM},
  number = {12},
  numpages = {10}
}

@inproceedings{wood2014new,
  title = {A {{New Approach}} to {{Probabilistic Programming Inference}}},
  booktitle = {Proceedings of the {{Seventeenth International Conference}} on {{Artificial Intelligence}} and {{Statistics}}},
  author = {Wood, Frank and Meent, Jan Willem and Mansinghka, Vikash},
  editor = {Kaski, Samuel and Corander, Jukka},
  year = {2014},
  volume = {33},
  pages = {1024--1032},
  publisher = {{PMLR}},
  abstract = {We introduce and demonstrate a new approach to inference in expressive probabilistic programming languages based on particle Markov chain Monte Carlo. Our approach is easy to implement and to parallelize, applies to Turing-complete probabilistic programming languages, and supports accurate inference in models that make use of complex control flow, including stochastic recursion, as well as primitives from nonparametric Bayesian statistics. Our experiments show that this approach can be more efficient than previously introduced single-site Metropolis-Hastings samplers.}
}

@inproceedings{wu2014effect,
  title = {Effect Handlers in Scope},
  booktitle = {Proceedings of the 2014 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  author = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
  year = {2014},
  pages = {1--12},
  publisher = {{ACM}},
  address = {{Gothenburg, Sweden}},
  doi = {10.1145/2633357.2633358},
  isbn = {978-1-4503-3041-1},
  keywords = {effect handlers,Haskell,modularity,monads,semantics,syntax},
  series = {Haskell '14}
}

@article{xia2019interaction,
  title = {Interaction {{Trees}}: {{Representing Recursive}} and {{Impure Programs}} in {{Coq}} ({{Work In Progress}})},
  author = {Xia, Li-yao and Zakowski, Yannick and He, Paul and Hur, Chung-Kil and Malecha, Gregory and Pierce, Benjamin C. and Zdancewic, Steve},
  year = {2019},
  volume = {4},
  publisher = {{ACM}},
  doi = {10.1145/3371119},
  articleno = {Article 51},
  issue_date = {January 2020},
  journal = {Proceedings of the ACM Programming Languages},
  keywords = {coinduction,compiler correctness,Coq,monads},
  number = {POPL},
  numpages = {32}
}


