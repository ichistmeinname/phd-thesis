% !TEX root = ../thesis.tex
%

\cleanchapterquote{And quickly they will observe that functional programming elegantly admits solutions that are very hard (or impossible) to formulate with the programming vehicle of their high school days.}{Edsgar W. Dijkstra}{(On why to choose Haskell over Java)}

Many features that are most commonly associated with functional programming gain presence in mainstream as well as new programming languages in particular.
Version 5 of Java~\citep{arnold2005java} brings polymorphism in the form of generics to an object\--oriented language that is heavily used in industry; version 8 introduces a more convenient way to write lambda functions.
New programming languages like Elm~\citep{czaplicki2012elm} or Reason~\citep{2019reasonml}, which are heavily influenced by the functional languages Haskell~\citep{jones2002haskell} and OCaml~\citep{minsky2013real}, respectively, fill the gap concerning statically typed, functional languages for front\--end developers.
Over the last decades, programmers seek the comfort of a compiler that warns about potentially bad programs before actually running them.
Furthermore, they long for abstractions to simplify and generalise their code basis in order to increase the stability and maintainability of their software products.
Such abstractions like higher\--order functions, algebraic data types, polymorphism and purity are highly regarded in the functional programming language community since the introduction of ML in the 70s.

Among functional languages, the superset of declarative languages also includes the paradigm of logic programming.
Features associated with logic programming like non\--determinism, free variables and constraint solving have not caught on mainstream languages such as the functional features we mentioned above --- yet.
One part of this thesis illustrates the advantages of a functional logic programming language, which combines both of these paradigms, over encoding logic features in a functional language.
These advantages we discuss in this thesis are specific to non\--strict non\--determinism.
The first application considers permutation enumeration function.
More precisely, the permutation functions arises from sorting functions that are parametrised by a comparison function.
The clue is to apply such sorting functions with a non\--deterministic comparison function that produces all possible rearrangements of the input list, leading to a permutation enumeration function.
The advantages of the functional logic programming language become apparent when comparing the implementation against an implementation in a functional language that uses lists to model the non\--determinism.
The second application is an implementation of a library for probabilistic programming.
The key ingredient of probabilistic programs are distributions that are most commonly modeled as pairs of events and their corresponding probabilities.
Users of probabilistic programming languages then want to query these distributions in order to get the probability of a subset of the events.
An implementation that represents distributions using non\--strict non\--determinism can have advantages with respect to these queries that are already known from property\--based testing \citep{christiansen2008easycheck,runciman2008smallcheck}.

Moreover, pure functional programming languages are said to be particularly well\--suited for equational reasoning.
Most equational reasoning efforts do not bother about disruptive properties like partiality that may occur in programs we want to prove properties about.
Partial programs are allowed in both of these languages and complicate equational reasoning.
In case of partiality, we can argue that a total subset is reasonable, because functional programmers are interested in preventing the possibility of run\--time errors anyway.
In case of a functional logic language, however, partiality comes in a different flavour: non\--determinism consists of a non\--deterministic choice operator as well as a failure value that behaves as neutral element with respect to the choice operator.
More precisely, we would exclude all programs except the ones that would also compile in a functional language.
Whereas the restriction concerning partiality in the context of a functional language might be acceptable, it is rather radical to exclude non\--deterministic programs when we want to reason about a functional logic language.
As the second part of this thesis, we discuss how to model non\--strict functional languages with effects like partiality and non\--determinism in a proof assistant in order to apply equational reasoning in a computer\--assisted approach.

The thesis is structured as follows. We give an introduction to advanced concepts of functional and functional logic programming as well as a beginner\--friendly introduction to a dependently typed language we later use as the proof assistance of choice for the formal reasoning (\autoref{ch:dp}).
The advantages of non\--strict non\--determinism are illustrated using the example of two applications: implementing a permutation enumeration function by means of a sorting function that is applied to a non\--determinism predicate (\autoref{ch:permutations}), and developing a library for probabilistic programming that relies on non\--determinism instead of lists as internal structure (\autoref{ch:pflp}).
We then switch the focus from applications to formal reasoning and present a framework to model non\--strict functional programs that come with effects like partiality and non\--determinism as well as prove exemplary properties about programs using the framework (\autoref{ch:reasoning}).
Finally, we give a summary of the presented work (\autoref{ch:conclusion}) and collect additional source code in the appendix.

As all contributions presented in this thesis have been already published, the related chapters (Chapter 3--5) each inform about the previously published work as well.
Furthermore, we highlight the changes and additions with respect to the published version, and present related work as well as a summary for each chapter individually.