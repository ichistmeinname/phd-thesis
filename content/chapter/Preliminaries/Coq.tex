\section{Programming with Dependent Types in Coq}
\label{sec:progDT}

In this section we will give an introduction to programming with the interactive theorem prover Coq.
In order to write functional programs Coq provides the specification language \emph{Gallina}.
More precisely, Gallina is a dependently typed functional programming language.
The theorem prover part of Coq is based on the calculus of inductive construction \citep{coquand1988inductively}, a derivative of the calculus of construction that was introduced by \citet{coquand1986calculus}.
As Coq is not an automatic theorem prover, it additionally provides a tactic language called \emph{Ltac} to provide facilities to automate proofs.

This introduction is structured as follows.
We first give an overview on writing functional programs in Coq including common obstacles with regards to Coq's restriction as total language as well as how to overcome them.
As some of these solutions will lead us to dependently typed programming, we will take a look at how to formalise properties and how to prove them.
In that light we give a beginner-friendly introduction on how to use Coq's tactic language to write proofs.
Note that we do not give a formal definition of the calculus of constructions or other concepts with regard to the implementation of Coq's logic, but suggest the interested reader to study other textbooks for a full-blown introduction \citep{pierce2010software, chlipala2011certified}.
Instead we focus on how to use Coq as a tool to formalise and proof properties about programs.

\subsection{Functional Programming}

We can define a lot of common functions we know from Haskell or Curry one-to-one in Coq.
As a code convention, we will start data type and constructor names with lower-case letters as many standard types in Coq follow the same convention.
Consider the following data type definition for Peano numbers.

\begin{minted}{coq}
Inductive peano : Type :=
| z : peano
| s : peano -> peano.
\end{minted}

First, we note that all definitions have explicit typing annotations, although Coq could infer all of them.
Most notably, the data type declaration for \cinl{peano} is annotated with \cinl{Type}.
Although Coq is build upon a sophisticated type hierarchy, for us it is enough to know that we will use \cinl{Type} for inductive data types and type synonyms.
The syntax to define constructors for data types resembles GADT-style definitions in Haskell, that is, each constructor is specific by its full type signature, as we are used to it for function definitions.

Next, we define a function to check if a Peano number is zero as well as addition on Peano numbers using pattern matching.

\begin{minted}
Definition isZero (p : peano) : bool :=
  match p with
  | z   => true
  | s _ => false
  end.

Fixpoint add (p1 p2 : peano) : peano :=
  match p1 with
  | z => p2
  | s p => s (add p p2)
  end.
\end{minted}

The definition of \cinl{isZero} additionally uses the predefined \cinl{bool} type as result.
These definitions represent two different kinds of function: \cinl{isZero} is a non-recursive function, whereas \cinl{add} is a representative for recursive functions.
In Coq it is crucial to define recursive functions using the keyword \cinl{Fixpoint}.
Definitions that are marked as \cinl{Fixpoint}s need to pass an additional check: As a total language, all functions in Coq have to terminate.
In case of recursive functions, Coq checks if there is one argument of the recursive call that is structurally smaller than the original value passed to the function for each recursive call.
For our example \cinl{add}, the argument \cinl{p} of the recursive call is structurally smaller than the original value \cinl{p1} in the second case of the branch, where we know that \cinl{p1} has the shape \cinl{(s p)}.

If we want to define a recursive function in Coq that does not follow this restriction, we can use the keyword \cinl{Program Fixpoint} and prove the termination of the function afterwards.
An example for such a recursive function is the following artificial definition that decreases on one of its arguments at each recursive call, but does not have one designated argument that decreases at each call.

\begin{minted}{coq}
Fail Fixpoint test (b : bool) (n m : peano) : bool :=
  match (n,m) with
  | (z,_)      => true
  | (_,z)      => false
  | (s p, s q) => if b then test b p m else test b n q
  end.
\end{minted}

The keyword \cinl{Fail} indicates that the definition was not accepted by Coq without an error.
Here, the command has failed with the error message \texttt{Cannot guess decreasing argument of fix}.
In this thesis, we will not use capabilities like \cinl{Program Fixpoint} to define recursive functions that do not obey Coq's restrictions, so we abstain from going into more details concerning proving termination of recursive functions.

Moving on with our definitions above, we can introduce \cinl{Notation}
that allows us to write something more natural like \cinl{p1 + p2} for
the expression \cinl{(add p1 p2)}.
Note that we can provide an associativity for the newly introduced operator syntax as well as a fixity level.

\begin{minted}{coq}
Notation "p1 + p2" := (add p1 p2) (left associativity, at level 50).
\end{minted}

In Coq we can check types, print definitions and evaluate expressions directly in the Coq-file using so-called \emph{Vernacular}-commands like \cinl{Check}, \cinl{Print} and \cinl{Compute} that will print the information on the console.
Since we are used to having a REPL from languages like Haskell and Curry, we will write these commands and the printed answer in a REPL-style as follows.

\begin{crepl}
\coqrepl Compute (s z + s z).
   = s (s z)
   : peano
\end{crepl}

Let us now consider a polymorphic data type definition as well as polymorphic functions using lists as example.
We use the predefined definition for lists; as a code convention we start type variables using upper-case letters.

\begin{minted}{coq}
Inductive list (A : Type) :=
| nil  : list A
| cons : A -> list A -> list A.
\end{minted}

When we try to compute the exemplary singleton list \cinl{cons z nil} to normalform, Coq yields an error message.

\begin{crepl}
\coqrepl Compute (cons z nil).
Error: The term "z" has type "peano" while it is expected to have type
       "Type".
\end{crepl}

Constructors of polymorphic functions need to be applied to more arguments as we are used to in functional languages like Haskell.
More precisely, all constructors of a polymorphic data type like \cinl{list} have additional type arguments.
In our case, \cinl{cons} is of type \cinl{forall A : Type, A -> list A -> list A} and \cinl{nil} of type \cinl{forall A : Type, list A}.
The first argument is a type that determines the concrete type instantiation of the constructors \cinl{cons} and \cinl{nil}.
The definition above works when we apply a type like \cinl{nat} explicitly or instruct Coq to infer the argument by using an underscore (\cinl{_}).

\begin{crepl}
\coqrepl Compute (cons peano z (nil peano)).
    = cons peano z (nil peano)
    : list peano

\coqrepl Compute (cons _ z (nil _)).
    = cons peano z (nil peano)
    : list peano

\coqrepl Compute (cons _ tt (nil _)).
    = cons unit tt (nil unit)
    : list unit
\end{crepl}

Note that the type \cinl{unit} we use as third example has only one constructor \cinl{tt}.
Instead of applying type arguments explicitly, we can tweak some settings in order to use functions as we are used to in Haskell, i.e., such that type arguments are inferred. \footnote{In particular, we use the option \cinl{Set Implicit Arguments} and specific commands like \cinl{Arguments nil [_]} to make Coq infer all type arguments if possible.}

Next, we define the recursive functions \cinl{length} and \cinl{map} as exemplary functions on lists.

\begin{minted}{coq}
Fixpoint length (A : Type) (xs : list A) : peano :=
  match xs with
  | nil       => z
  | cons _ ys => s (length ys)
  end.

Fixpoint map (A B : Type) (f : A -> B) (xs : list A) : list B :=
  match xs with
  | nil => nil
  | cons y ys => cons (f y) (map f ys)
  end.
\end{minted}

A rather obvious property of a combination of these function states that mapping over a list does not change its length.
In Coq we can define such a proposition using mostly language features we have used so far.

\begin{minted}{coq}
Lemma map_length (A B : Type) (f : A -> B) (xs : list A)
  : length xs = length (map f xs).
\end{minted}

While the arguments of the function \cinl{map_length} look as usual, the resulting type involves dependent types.
The symbol \cinl{=} on the right-hand side of the type signature is just a notation for the type \cinl{eq} that is defined as follows.

\begin{minted}{coq}
Inductive eq (A : Type) (x : A) : A -> Prop :=
| eq_refl : eq x x.
\end{minted}

The data type \cinl{eq} is a propositional type, indicated by the resulting type \cinl{Prop}.
Intuitively, Coq uses the convention that ordinary programs are of type \cinl{Type} while proofs are of type \cinl{Prop}.
Since the definition \cinl{eq} is the proof that two expressions are literally the same, i.e., structurally equal, the resulting type of \cinl{eq} is \cinl{Prop}.
Furthermore, the type of the constructor \cinl{eq_refl} that represents the reflexivity property for structural equality is \cinl{eq x x}.
Here, \cinl{eq} is a dependent type, because the type of the constructor \cinl{eq_refl} uses not only types but the value \cinl{x} in its type signature.

The type of lemmas like \cinl{map_length} correspond to the proposition we want to prove and the implementation is one concrete proof.
That is, when we can implement \cinl{map_length} with type \cinl{length xs = length (map f xs)}, we have proven the corresponding proposition.

\subsection{Proving in Coq: A step-by-step introduction}
For the proof of that proposition, on the other hand, we need to take a look at the tactic language \cinl{Ltac} for the first time.
We enclose a proof using the commands \cinl{Proof} and \cinl{Qed} and write all tactics we want to apply between these commands.
So, let us start with the proof; we will illustrate the progress after each step in a verbatim environment next to the presented tactic or other command.

\begin{cproof}{Proof.}
  A : Type
  B : Type
  f : A -> B
  xs : list A
  ============================
  length xs = length (map f xs)
\end{cproof}

The current state of the proof shows that we have the types \cinl{A, B} in scope as well as a function \cinl{f : A -> B} and a list \cinl{xs : list A}.
These information are \emph{hypotheses} we can use for the proof.
Underneath the hypotheses we see the resulting type of \cinl{map_length} that represents the current \emph{goal}.
We can then use tactics to manipulate hypotheses and the goal in a sensible way until we find the final proof of the goal.
 As we proceed with the proof, we will use \cinl{...} to indicate that we do not list all hypotheses, e.g., we will leave out types of identifiers variables and hypotheses that are not used in the currently focused goal.

Since we cannot simplify neither the left-hand side of the equation nor the right-hand side, we start by doing an induction on \cinl{xs} to take a look at more concrete values \cinl{xs} can occur as.
Using the \cinl{induction}-tactic on a list will generate two new goals: one for \cinl{nil} and one for \cinl{cons}.

\begin{cproof}{induction xs as [ | y ys H ]}
  ...
  f : A -> B
  ============================
  length nil = length (map f nil)

subgoal 2 (ID 30) is:
length (cons y ys) =
length (map f (cons y ys))
\end{cproof}

We use a more involved version of the \cinl{induction}-tactic that additionally supplies the names for the new parameters that need to be introduced.
The introduction pattern \cinl{[ | y ys H ]} describes the naming conventions for two subgoals: we do not supply any names for the first goal and the three names \cinl{y}, \cinl{ys} and \cinl{H} for subgoal for \cinl{cons}.
The first two names will be used for the arguments of \cinl{cons} and the name \cinl{H} will be used for the induction hypothesis that is automatically generated by Coq since \cinl{list} is a recursive type.
We can structure proofs using bullet points like \cinl{-,+,*} and bring the next subgoal in focus.
In case of \cinl{nil}, we can simplify both sides of the equation using the definition of \cinl{length} and \cinl{map} by applying the tactic \cinl{simpl}.

\begin{cproof}{- simpl.}
  ...
  ============================
  z = z
\end{cproof}

Now we are at the point that we can use the tactic \cinl{reflexivity} that, intuitively, constructs the final expression using the above introduced constructor \cinl{eq_refl}.
Next, we take a look at the \cinl{cons}-case after simplifying both expressions again.

\begin{cproof}{- simpl.}
  ...
  H : length ys = length (map f ys)
  ============================
  s (length ys) = s (length (map f ys))
\end{cproof}

Note that the induction hypothesis \cinl{H} states that the proposition already holds in case of \cinl{ys}.
That is, we can directly rewrite \cinl{length ys} on the left-hand side of the equation in the goal with the right-hand side of the hypothesis.

\begin{cproof}{rewrite -> H.}
  ...
  ============================
  s (length (map f ys)) =
  s (length (map f ys))
\end{cproof}

The \cinl{rewrite}-tactic gets two arguments: the first argument specifies the direction we want to perform the rewriting\footnote{The direction from left-to-right is the default and does not need to be provided in this case.} and the second argument indicates based on which equality we want to apply the rewriting.
After rewriting the hypothesis, the final goal can be proven using \cinl{reflexivity} again.
We then finish the proof by using the keyword \cinl{Qed}.

\begin{cproof}{Qed.}
map_length is defined
\end{cproof}

At that point, Coq provides the information that the lemma \cinl{map_length} was successfully defined and can be used in future proofs and definitions.
In order to give a better overview of the proof in its entirety, we restate the proposition as lemma including the complete proof script.

\begin{minted}{coq}
Lemma map_length (A B : Type) (f : A -> B) (xs : list A) : length xs = length (map f xs).
Proof.
  induction xs as [ | y ys H ].
  - simpl. reflexivity.
  - simpl.
    rewrite -> H.
    reflexivity.
Qed.
\end{minted}

\subsection{Dependent Types to Encode Invariants}

As stated in the beginning, the property about map not manipulating the length of the list is not surprising.
We will now take a look at how to encode the length of the list in its type.
Due to this encoding, the property of map not manipulating the length of the list becomes clear from the type signature alone.

A list that has length encoded in its type is usually called a \cinl{vector} and is defined as follows.

\begin{minted}{coq}
Inductive vector (A : Type) : peano -> Type :=
| vnil  : vector A z
| vcons : forall n, A -> vector A n -> vector A (s n).
\end{minted}

Note that the type \cinl{vector} needs to be applied to two arguments to yield a type: a type for the elements and a \cinl{peano} to indicate its length.
The two constructors illustrate how to use the type: In case of \cinl{vnil} we encode that the length is zero using the peano number \cinl{z} as second argument to \cinl{vector}; for \cinl{vcons} we encode that adding an element to the front results in a length incremented by one.
More precisely, if we have a \cinl{vector} of length \cinl{n} adding an element to the front using \cinl{vcons} results in a \cinl{vector} of length \cinl{s n}.

When defining functions of type \cinl{vector}, we need to explicitly pass the length as argument as well.
Consider the following definition of computing the length for \cinl{vector}.

\begin{minted}{coq}
Definition vlength (A : Type) (n : peano) (xs : vector A n) : peano := n.
\end{minted}

The definition is especially convenient to define as the \cinl{peano} number \cinl{n} we pass to type \cinl{vector} is also our result.
That is, we can use the value we construct types with in the right-hand side of the function definition as well.
Next, we define a mapping function for \cinl{vector} that explicitly states that the length of the input and output list are the same.

\begin{minted}{coq}
Fixpoint vmap (A B : Type) (n : peano) (f : A -> B) (xs : vector A n)
  : vector B n :=
  match xs with
  | vnil       => vnil
  | vcons y ys => vcons (f y) (vmap f ys)
  end.
\end{minted}

Note that we cannot define the function using two different values for the length.
The definition of \cinl{vmap} explicitly reconstructs all constructors of the input \cinl{xs} such that the output list cannot be of different length.

As the type signature of \cinl{vmap} already tells us that \cinl{vmap} does not change the length of the list, the property we proved above for ordinary lists becomes a one-liner.

\begin{minted}{coq}
Lemma vmap_vlength : forall A B (n : peano) (f : A -> B) (xs : vector A n),
    vlength xs = vlength (vmap f xs).
Proof.
  reflexivity.
Qed.
\end{minted}

Although we cannot construct the result of \cinl{vmap f xs} --- as in the case for ordinary lists, we do not need to take a look at \cinl{xs} to compute the length of the list.
We know from the type alone that the left side of the equation evaluates to \cinl{n} for \cinl{xs : vector A n} when using the definition of \cinl{vlength}.
The same applies to the right side of the equation, because \cinl{vlength} can compute the length of the list using its type information only.
The expression \cinl{vmap f xs} is of type \cinl{vector B n}, so using the definition of \cinl{vlength} yields \cinl{n} again.
Coq automatically applies some simplifications --- like unfolding function definitions --- when we apply the tactic \cinl{reflexivity}, so the proof consists of only one tactic.

\subsection{Propositions and False Assumptions}

When we defined the function \cinl{vmap}, we said that we cannot use a more general type using two type variables \cinl{n m : peano} for the input and output list.
We can even show that there is no way to define \cinl{vmap} such that \cinl{n} and \cinl{m} are different values.

First up, we define a proposition \cinl{vmap_spec} that represents the specifications of \cinl{vmap}.

\begin{minted}{coq}
Inductive vmap_spec (A B : Type) (f : A -> B) :
  forall (n m : peano), vector A n -> vector B m -> Prop :=
| spec_nil  : vmap_spec f vnil vnil
| spec_cons : forall (n m : peano) (x : A) (y : B)
                (xs : vector A n) (ys : vector B m),
    vmap_spec f xs ys -> f x = y -> vmap_spec f (vcons x xs) (vcons y ys).
\end{minted}

Given types \cinl{A B : Type} and a function \cinl{f : A -> B}, we define the predicate to relate two lists of type \cinl{vector A n} and \cinl{vector B m} for all Peano numbers \cinl{n} and \cinl{m}.
That is, the type is general enough to allow the lists to be of different length.
The \cinl{spec_nil} case relates empty lists whereas the second case \cinl{spec_cons} relates non-empty lists of potentially different lists.
The second case additionally assumes that the head element of the second list \cinl{y} can be constructed by applying the function to the other head element \cinl{x}.
Of course, the specification has high resemblance with our definition of \cinl{vmap}.

As first finger exercise, we show that our definition of \cinl{vmap} indeed fulfils the specification.
Since we will use the same types \cinl{A B}, Peano numbers \cinl{n m}, function \cinl{f : A -> B} and list \cinl{xs} for several proofs, we use a section to declare these variables upfront so we do not need to introduce them for each proof or definition again.
All of these \emph{section variable}s are additional arguments of the definitions using these variables after closing the section but are not arguments within the section.

\begin{minted}{coq}
Section vmap_spec_proofs.

  Variable A B : Type.
  Variable n m : peano.
  Variable f : A -> B.
  Variable xs : vector A n.

  Lemma vmap_fulfils_spec : vmap_spec f xs (vmap f xs).
  Proof.
    induction xs as [ | n y ys IHys ]; simpl.
    - apply spec_nil.
    - apply spec_cons.
      + apply IHys. apply ys.
      + reflexivity.
  Qed.
\end{minted}

The first thing we do for both cases of the induction is to simplify the given goal using the definition \cinl{vmap}.
In order to reduce the repetition, we use the notation \cinl{tactic1; tactic2} to apply the second tactic \cinl{simpl} on all subgoals generated by the first tactic \cinl{induction}.
Since our definition of \cinl{vmap} is a natural implement of the specification, the remaining proof is straightforward: we use the appropriate constructor of the specification predicate and the assumptions we have in place.

For our next proof, we want to show that something is false, i.e., that a value of a particular type cannot be constructed.
In Coq, such a value that cannot be constructed is represented using the type \cinl{False}.

\begin{minted}{coq}
Inductive False : Prop := .
\end{minted}

Since \cinl{False} lives in the world of proofs it is of type \cinl{Prop}.
We cannot construct any value of type \cinl{False}, simply because the inductive type has no constructors.
The definition of \cinl{False} is valid nonetheless --- and useful as well.

We can, for example, use \cinl{False} to show that two expressions are not equal.

\begin{minted}{coq}
Lemma z_not_s : forall (x : peano), z = s x -> False.
Proof.
  intros x Heq.
  discriminate Heq.
Qed.
\end{minted}

We use the tactic \cinl{discriminate} on hypothesis that state two structurally different to be equal, like \cinl{z = s x}.
Note that other tactics might work as well but we will use \cinl{discriminate} in such cases.
Moreover, the negation function on propositions \cinl{not} is defined using \cinl{False} and usually occurs in form of its notation \cinl{<>}.

\begin{minted}{coq}
Definition not (A : Prop) : Prop := False
Notation "<>" := not.
\end{minted}

The next two proofs use \cinl{vmap_spec} to demonstrate that we cannot define a mapping function fulfilling the specifications for input and output lists of different length.
The first lemma states that assuming a list \cinl{ys} of length \cinl{m}, \cinl{n <> m} and that the specification holds for this \cinl{ys}, we can always derive \cinl{False}.

\begin{minted}{coq}
  Lemma vmap_different_length : forall (ys : vector B m),
      n <> m -> vmap_spec f xs ys -> False.
  Proof.
    intros ys Hnot Hspec. induction Hspec.
    - contradiction.
    - apply IHHspec. apply s_not_eq. apply Hnot.
  Qed.
\end{minted}

Let us take a look at the two subgoals produced by inducting over the specification predicate \cinl{vmap_spec f xs ys}, that is for the cases \cinl{xs : vector A z} and  \cinl{ys : vector B z} for the first subgoal and \cinl{xs : vector A (s n)} and \cinl{ys : vector B (s m)} for the second subgoal.

\begin{cproof}{induction Hspec.}
  ...
  Hnot : z <> z
  ============================
  False

subgoal 2 (ID 139) is:
  ...
  Hnot : s n <> s m
  IHHspec : n <> m -> False
  ============================
  False
\end{cproof}

We can discard the first subgoal by observing that the assumption \cinl{z <> z} is a false statement: the used tactic \cinl{contradiction} looks for such statements in the hypotheses and discards the proof when a suitable statement is found.
For the second subgoal we use the following auxiliary lemma that states that if a successor construction is not structurally equal, their arguments are not structurally equal either.

\begin{minted}{coq}
Lemma s_not_eq : forall (n m : peano), s n <> s m -> n <> m.
\end{minted}

First, we apply the assumption \cinl{IHHspec} to change the goal.
Then we use the auxiliary lemma to derive the new goal \cinl{s n <> s
  m} that we can proof directly by applying the appropriate assumption
\cinl{Hnot}.

Besides showing that the output list cannot be of different length, we can also show that for all possible output lists \cinl{ys : vector B m} that fulfils the specification predicate, it must hold that the output list is of the same length as the input list, i.e., \cinl{n = m}.

\begin{minted}{coq}
  Lemma vmap_same_length : forall (ys : vector B m),
      vmap_spec f xs ys -> n = m.
  Proof.
    intros ys Hspec. induction Hspec.
    - reflexivity.
    - rewrite IHHspec; reflexivity.
  Qed.

End vspec_map_proofs.
\end{minted}

The proof follows straightforward by induction over the specification predicate.
The last line of the code closes the section we opened above, that is, all the variables introduced are note visible anymore but inserted as additional arguments for the lemmas \cinl{vmap_different_length} and \cinl{vmap_same_length}.


The encoding of lists associated with their lengths as well as using predicates to formalise properties for data structures are good show-cases on how to use Coq's dependent type system to prove properties about programs.
The above proofs give a good overview on the tactics we will use throughout the thesis.
Other features and more involved tactics of Coq will be introduced as needed.

%Without the annotation \cinl{peano} would be annotated as type \cinl{Set}.
%Besides the types \cinl{Type} and \cinl{Set}, Coq provides a third level in the hierarchy with the type \cinl{Prop} that is used to define relations.
%Since very object in Gallina has a type, the types \cinl{Set} and \cinl{Prop} are of type \cinl{Type}, that is, \cinl{Type} leads the typing hierarchy.
%
%\begin{minted}{coq}
%Check Set.
%(* Set : Type *)  
%Check Prop.
%(* Prop : Type *)
%Check Type.
%(* Type : Type *)
%\end{minted}
%
%Furthermore, it seems that \cinl{Type} is of its own type.

% \begin{itemize}

% \item definitions vs fixpoints
% \item total language
% \item definitions using dependent types
% \item notations
% \item section variables
% \item unit, empty type
% \item proofs are programs
% \item intro-pattern in proofs

% \end{itemize}
