\section{Programming with Dependent Types in Coq}
\label{sec:progDT}

In this section we give an introduction to programming with the interactive theorem prover Coq.
In order to write functional programs, Coq provides the specification language \emph{Gallina}.
More precisely, Gallina is a dependently typed functional programming language.
The theorem prover part of Coq is based on the calculus of inductive construction \citep{coquand1988inductively}, a derivative of the calculus of construction that was introduced by \citet{coquand1986calculus}.
As Coq is not an automatic theorem prover, it additionally provides a tactic language called \emph{Ltac} that enables the user to interactively construct proofs.

This introduction is structured as follows.
We first give an overview on writing functional programs in Coq including common obstacles with regard to Coq's totality restriction as well as how to overcome them.
As some of these solutions lead us to dependently typed programming, we take a look at how to formalise properties about programs and how to prove them.
In that light, we give a beginner-friendly introduction on how to use Coq's tactic language to write proofs.
Note that we do not give a formal definition of the calculus of constructions or other concepts with regard to the implementation of Coq's logic, but suggest the interested reader to study other textbooks for a full-blown introduction \citep{pierce2010software, chlipala2011certified}.
Instead we focus on how to use Coq as a tool to formalise and prove properties about programs.

\subsection{Functional Programming}

We can define a lot of common functions we know from functional programming languages like Haskell or Curry one-to-one in Coq.
As a code convention, we will start data type and constructor names with lower-case letters as many standard types in Coq follow the same convention.
Consider the following data type definition for Peano numbers.

\begin{minted}{coq}
Inductive nat : Type :=
| z : nat
| s : nat -> nat.
\end{minted}

First, we note that all definitions have explicit typing annotations, although Coq could infer all of them.
Most notably, the data type declaration for \cinl{nat} is annotated with \cinl{Type}.
Although Coq is build upon a sophisticated type hierarchy, for us it is enough to know that we will use \cinl{Type} for inductive data types and type synonyms.
The syntax to define constructors for data types resembles GADT-style definitions in Haskell, that is, we specify full type signature for each constructor, as we are used to it for function definitions.
Furthermore, we list all constructors line-by-line and each line begins with a pipe \cinl{|} as delimiter.

Next, we define a function to check if a Nat number is zero as well as a function for addition on Nat numbers using pattern matching.

\begin{minted}{coq}
Definition isZero (p : nat) : bool :=
  match p with
  | z   => true
  | s _ => false
  end.

Fixpoint add (p1 p2 : nat) : nat :=
  match p1 with
  | z   => p2
  | s p => s (add p p2)
  end.
\end{minted}

The pipe symbole \cinl{|} is again used as a delimiter: this time to list all patterns we want to distinguish in a \cinl{match ... with}-expression that corresponds to Haskell's \hinl{case ... of}-expressions.
Note that the definition of \cinl{isZero} uses the predefined \cinl{bool} type as result, and that we can group successive arguments of the same type in the type signature.
The functions definitions above represent two different kinds of functions: \cinl{isZero} is a non-recursive function, whereas \cinl{add} is a representative for recursive functions.
In Coq it is crucial to define recursive functions using the keyword \cinl{Fixpoint}.
Definitions that are marked as \cinl{Fixpoint}s need to pass an additional check: As a total language, all functions in Coq have to terminate.
In case of recursive functions, Coq checks if there is one argument of the recursive call that is structurally smaller than the original argument passed to the function for each recursive call.
In our example definition \cinl{add}, the argument \cinl{p} of the recursive call is structurally smaller than the original value \cinl{p1} in the second case of the branch, where we know that \cinl{p1} has the shape \cinl{(s p)}.

As an example for a recursive function that Coq's termination checker does accept, we try to define the following artificial definition that decreases on one of its arguments at each recursive call, but does not have one designated argument that decreases for each call.

\begin{minted}{coq}
Fail Fixpoint test (b : bool) (n m : nat) : bool :=
  match (n,m) with
  | (z,_)      => true
  | (_,z)      => false
  | (s p, s q) => if b then test b p m else test b n q
  end.
\end{minted}

The keyword \cinl{Fail} indicates that the definition was not accepted by Coq without an error.
Here, the command has failed with the error message \texttt{Cannot guess decreasing argument of fix}.
If we want to define such a recursive function that does not follow Coq's restriction, we can use the keyword \cinl{Program Fixpoint} and prove the termination of the function afterwards.
In this thesis, we will not use capabilities like \cinl{Program Fixpoint} to define recursive functions that do not obey Coq's restrictions, so we abstain from going into more details concerning proving termination of recursive functions.

Moving on with our definitions on Nat numbers above, we can introduce a \cinl{Notation} that allows us to write more natural expressions like \cinl{p1 + p2} for
the expression \cinl{(add p1 p2)}.
Note that we can provide an associativity for the newly introduced operator syntax as well as a fixity level.

\begin{minted}{coq}
Notation "p1 + p2" := (add p1 p2) (left associativity, at level 50).
\end{minted}

In Coq we can check types, print definitions and evaluate expressions directly in the Coq-file using so-called \emph{Vernacular}-commands like \cinl{Check}, \cinl{Print} and \cinl{Compute} that will print the information on the console.
Since we are used to having a REPL from languages like Haskell and Curry, we will write these commands and the printed answer in a REPL-style as follows.

\begin{crepl}
\coqrepl Compute (s z + s z).
   = s (s z)
   : nat
\end{crepl}

Let us now consider a polymorphic data type definition as well as polymorphic functions using lists as example.
We use the predefined definition for lists.
As a code convention we name type variables using upper-case letters.

\begin{minted}{coq}
Inductive list (A : Type) : Type :=
| nil  : list A
| cons : A -> list A -> list A.
\end{minted}

In case of polymorphic functions, including constructors of datas types, we need to pass the instantiation of the type arguments explicitly.
For example, when we try to compute the exemplary singleton list \cinl{cons z nil} to normalform, Coq yields an error message.

\begin{crepl}
\coqrepl Compute (cons z nil).
Error: The term "z" has type "nat" while it is expected to have type
       "Type".
\end{crepl}

When using Coq, constructors of polymorphic functions need to be applied to more arguments than we are used to from functional languages such as Haskell.
More precisely, all constructors of a polymorphic data type like \cinl{list} as well as polymorphic functions in general have additional type arguments.
In our case, \cinl{cons} and \cinl{nil} have the following types.

\begin{crepl}
\coqrepl Check nil.
   nil : forall (A : Type), list A
\coqrepl Check cons.
   cons : forall (A : Type), A -> list A -> list A
\end{crepl}

The first argument is the type that determines the concrete type instantiation of the constructors \cinl{cons} and \cinl{nil}.
The definition above works when we apply a type like \cinl{nat} explicitly or instruct Coq to infer the argument by using an underscore (\cinl{_}).

\begin{crepl}
\coqrepl Compute (cons nat z (nil nat)).
    = cons nat z (nil nat)
    : list nat

\coqrepl Compute (cons _ z (nil _)).
    = cons nat z (nil nat)
    : list nat

\coqrepl Compute (cons _ tt (nil _)).
    = cons unit tt (nil unit)
    : list unit
\end{crepl}

Note that the type \cinl{unit} we use in the third example has only one constructor \cinl{tt}.
Instead of applying type arguments explicitly, we can tweak some settings in order to use functions as we are used to in Haskell, i.e., such that type arguments are inferred. \footnote{In particular, we use the option \cinl{Set Implicit Arguments} and specific commands like \cinl{Arguments nil [_]} to make Coq infer all type arguments if possible.}

Next, we define the recursive functions \cinl{length} and \cinl{map} as exemplary functions on lists.

\begin{minted}{coq}
Fixpoint length (A : Type) (xs : list A) : nat :=
  match xs with
  | nil       => z
  | cons _ ys => s (length ys)
  end.

Fixpoint map (A B : Type) (f : A -> B) (xs : list A) : list B :=
  match xs with
  | nil => nil
  | cons y ys => cons (f y) (map f ys)
  end.
\end{minted}

A rather obvious property of a combination of these function states that mapping over a list does not change its length.
In Coq we can define such a proposition mostly consisting of language features we have used so far.

\begin{minted}{coq}
Lemma map_length (A B : Type) (f : A -> B) (xs : list A)
  : length xs = length (map f xs).
\end{minted}

First, instead of using the \cinl{Definition} or \cinl{Fixpoint} keyword, we use \cinl{Lemma} that has the same purpose as the latter.
That is, the definition \cinl{map_length} is a function.
While the arguments of the function \cinl{map_length} look as usual, the resulting type involves dependent types.
The symbol \cinl{=} on the right-hand side of the type signature is just a notation for the type \cinl{eq} that is defined as follows.

\begin{minted}{coq}
Inductive eq (A : Type) (x : A) : A -> Prop :=
| eq_refl : eq x x.
\end{minted}

The data type \cinl{eq} is a propositional type, indicated by the resulting type \cinl{Prop}.
Intuitively, Coq distinguishes between ordinary programs that are of type \cinl{Type} while proofs are of type \cinl{Prop}.
Since the definition \cinl{eq} is the proof that two expressions are structurally equal, the resulting type of \cinl{eq} is \cinl{Prop}.
Furthermore, the type of the constructor \cinl{eq_refl} that represents the reflexivity property for structural equality is \cinl{eq x x}.
Here, \cinl{eq} is a dependent type, because the type of the constructor \cinl{eq_refl} uses not only types but the value \cinl{x} in its type signature.

The type of lemmas like \cinl{map_length} correspond to the proposition we want to prove and the implementation is one concrete proof.
That is, if we can implement \cinl{map_length} with type \cinl{length xs = length (map f xs)}, we have proven the corresponding proposition.

\subsection{Proving in Coq: A Step-by-Step Introduction}
For the proof of the proposition \cyinl{map_length}, on the other hand, we need to take a look at the tactic language \cinl{Ltac} for the first time.
We enclose a proof using the commands \cinl{Proof} and \cinl{Qed} and write all tactics we want to apply between these commands.
So, let us start with the proof; we present the tactic or other commands on the left-hand side and illustrate the progress after that command in a verbatim environment on the right-hand side.

\begin{cproof}{Proof. intros A B f xs.}
  A : Type
  B : Type
  f : A -> B
  xs : list A
  ============================
  length xs = length (map f xs)
\end{cproof}

The current state of the proof shows that we have the types \cinl{A} and \cinl{B} in scope as well as a function \cinl{f : A -> B} and a list \cinl{xs : list A}, which we introduced with the tactic \cinl{intros}.
These types are \emph{hypotheses} we can use for the proof.
Underneath the hypotheses we see the resulting type of \cinl{map_length} that represents the current \emph{goal}.
We can then use constructs of the tactic language to manipulate hypotheses and the goal in a sensible way until we find the final proof of the goal.
As we proceed with the proof, we will use \cinl{...} to indicate that we do not list all hypotheses, e.g., we will leave out types of identifiers, variables and hypotheses that are not used in the currently focused goal.

We cannot simplify neither the left-hand side of the equation nor the right-hand side, because the definition of \cinl{length} distinguishes between the \cinl{nil} and \cinl{cons} case.
In order to argument about these two different cases separately, we start by doing an induction on \cinl{xs}.
Using the \cinl{induction}-tactic on a list generates two new goals: one for \cinl{nil} and one for \cinl{cons}.

\begin{cproof}{induction xs as [ | y ys H ]}
  ...
  f : A -> B
  ============================
  length nil = length (map f nil)

subgoal 2 is:
  ...
  H : length ys = length (map f ys)
  ============================
  length (cons y ys) =
  length (map f (cons y ys))
\end{cproof}

We use a more involved version of the \cinl{induction}-tactic that additionally supplies the names for the new arguments that need to be introduced.
The introduction pattern \cinl{[ | y ys H ]} describes the naming conventions for the variables introduced in the two subgoals.
We do not supply any variable names for the first goal, because the \cinl{nil}-case does not introduced new variables.
For the \cinl{cons}-subgoal we pass the three names: \cinl{y} and \cinl{ys} for the two arguments of the \cinl{cons}-constructor as well as \cinl{H} for the induction hypothesis.
More generally, the vertical bar is a separator for the resulting subgoals and we introduce new names depending on the arguments of the corresponding subgoal.
The first two names correspond to the the arguments of \cinl{cons} and \cinl{H} is the name for the induction hypothesis that is automatically generated by Coq since \cinl{list} is a recursive type.
In case of \cinl{nil}, we can simplify both sides of the equation using the definition of \cinl{length} and \cinl{map} by applying the tactic \cinl{simpl}.

\begin{cproof}{- simpl.}
  ...
  ============================
  z = z
\end{cproof}

We structure proofs using bullet points like \cinl{-,+,*} and bring the next subgoal in focus.
Now we are at the point that we can use the tactic \cinl{reflexivity}, which, intuitively, constructs the final expression using the above introduced constructor \cinl{eq_refl}.
Next, we take a look at the \cinl{cons}-case after simplifying both expressions again.

\begin{cproof}{- simpl.}
  ...
  H : length ys = length (map f ys)
  ============================
  s (length ys) = s (length (map f ys))
\end{cproof}

The induction hypothesis \cinl{H} states that the proposition already holds in case of \cinl{ys}.
That is, we can directly rewrite \cinl{length ys} on the left-hand side of the equation in the goal with the right-hand side of the hypothesis.

\begin{cproof}{rewrite -> H.}
  ...
  ============================
  s (length (map f ys)) =
  s (length (map f ys))
\end{cproof}

The \cinl{rewrite}-tactic gets two arguments: the first argument specifies the direction we want to perform the rewriting in\footnote{The direction from left-to-right is the default and does not need to be provided in this case.} and the second argument indicates which equality hypothesis we want to rewrite in our goal.
After rewriting the hypothesis, the final goal can be proven using \cinl{reflexivity} again.
We then finish the proof by using the keyword \cinl{Qed}.

\begin{cproof}{Qed.}
map_length is defined
\end{cproof}

At that point, Coq provides the information that the lemma \cinl{map_length} was successfully defined and can be used in future proofs and definitions.
In order to give a better overview of the proof in its entirety, we restate the proposition as lemma including the complete proof script.

\begin{minted}{coq}
Lemma map_length (A B : Type) (f : A -> B) (xs : list A) : length xs = length (map f xs).
Proof.
  intros A B f xs.
  induction xs as [ | y ys H ].
  - simpl. reflexivity.
  - simpl.
    rewrite -> H.
    reflexivity.
Qed.
\end{minted}

\subsection{Representing Data Types using Containers}

A prominent example for the usage of dependent types is generic programming: we can encode a variety of polymorphic data types using containers as introduced by \citet{abbott2003categories}.

A container is described as a product of shapes and a position function.
The shape is a type \cinl{Shape} and the position type \cinl{Pos} is a type function that maps shapes to types.
Using these two components we can define a container extension that gives rise to a data type.

\begin{minted}{coq}
Inductive Ext (Shape : Type) (Pos : Shape -> Type) (A : Type) : Type :=
| ext : forall s, (Pos s -> A) -> Ext Pos A.
\end{minted}

A container extension \cinl{Ext Shape Pos} is then isomorphic to a type constructor \cinl{F}, where \cinl{F A} represents the polymorphic data type.

As an example, let us consider the polymorphic data type \cinl{One} we discussed in \autoref{subsec:freeMonad} in the context of free monads.
Recall that the definition was used by \citet{swierstra2008data} and that the name captures the number of representable values quite well.

\begin{minted}{coq}
Inductive One (A : Type) : Type :=
| one : One A.
\end{minted}

Now we wanto to represent \cinl{One} as a container described as a type of shapes and a position type function.
The data type \cinl{One} has only one constructor, that is, there is only one shape that we need to represent.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition One!$_\text{S}$! := unit.
\end{minted}

Intuitively, the shape type represents the different constructors of a data type.
Note that instead of introducing a new type defining with one value, we reuse Coq's \cinl{unit} type.
The only value of type \cinl{unit} is called \cinl{tt}.

The position type function, on the other hand, describes the possible positions of polymorphic arguments for all constructors.
As observed above, \cinl{One} has only one constructor.
This constructor \cinl{one} does not have any polymorphic arguments.
More precisely, there are no possible positions for polymorphic argument for any constructor.
In order to represent that there are no possible positions, we use an empty type.
An empty type is a data type without any values, that is, we cannot construct values of that type.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Inductive Empty : Type := .
Definition One!$_\text{P}$! (s : One!$_\text{S}$!) := Empty.
\end{minted}

Recall that the position type function depends on the corresponding shape.
Here, however, the shape does not matter as we do not have any position anyhow.

Using Coq's ability to prove properties about programs, we can show that the container representation is isomorphic to the original data type.
More precisely, we define two functions \cinl{from_One} and \cinl{to_One}, and show that both compositions yield the identity.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition from_One A (o : One A) : Ext One!$_\text{S}$! One!$_\text{P}$! A :=
  ext tt (fun (p : One!$_\text{P}$! tt) => match p with end).

Definition to_One A (e : Ext One!$_\text{S}$! One!$_\text{P}$! A) : One A :=
  one.
\end{minted}

The definition of \cinl{from_One} uses an empty pattern match, because there are no possible values of type \cinl{One_P tt} that is just a type synonym for \cinl{empty}.
Since the argument \cinl{p} is of type \cinl{empty} and \cinl{empty} has no constructors to match on, Coq realises that we cannot have a value of type \cinl{empty} in the first place and accepts the definition.
That is, we can define a function that yields an arbitrary polymorphic value given an empty type as argument.

\begin{minted}{coq}
Definition bogus (A : Type) (e : empty) : A :=
  match e with end.
\end{coq}

The definition of \cinl{to_One}, on the other hand, is straightforward, because there is only one way to construct the value \cinl{one}.
Note that we do not need to access a polymorphic component of type \cinl{A} in order to construct a value of type \cinl{One}.

An alternative definition of the above function displays the components of the argument type \cinl{Ext One_S One_P A} more explicitly.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition to_One A (e : Ext One!$_\text{S}$! One!$_\text{P}$! A) : One A :=
  let '(ext tt pf) := e in one.
\end{minted}

Since \cinl{Ext} has only one constructor, Coq allows a let-binding for such irrefutable patterns using the above syntax using a tick \cinl{'}.
The function \cinl{pf} is of type \cinl{One_P tt -> A}, which becomes a function of type \cinl{empty -> A} after inlining the definition of \cinl{One_P tt}.
As a side note, we could not produce a value of type \cinl{A} using the function \cinl{pf} if we needed to: we cannot construct the appropriate argument of type \cinl{empty}.

With these definitions at hand, we can prove that they form an isomorphism.
We start with the more involved proof \cinl{from_to_One} first.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Lemma from_to_One : forall (A : Type) (e : Ext One__S One__P A),
    from_One (to_One e) = e.
\end{minted}

\begin{cproof}{Proof. intros A e; simpl.}
  e : Ext One__S One__P A
  ============================
  ext tt (fun p : One__P tt => match p return A with
                               end) = e

\end{cproof}

We can directly simplify the function applications of \cinl{from_One} and \cinl{to_One} as they disregard the given argument.
Next, we observe that the argument \cinl{e} on the right-hand side of the equation is of type\cinl{Ext}: it must be constructed using \cinl{ext} as well.
More precisely, we even know that the first component, the shape, is of type \cinl{One__S}, and, hence, the only valid value is \cinl{tt}.
We destruct \cinl{e} directly in its two components: \cinl{tt} for the shape and \cinl{pf} for the position function using \cinl{[]} as a nested destruction for the shape.
The pattern \cinl{[]} can be used for deconstruction of values with only one constructors and without any arguments.

\begin{cproof}{destruct e as [ [] pf ].}
  s : One__S
  pf : One__P s -> A
  ============================
  ext tt (fun p : One__P tt => match p with end) = ext tt pf
\end{cproof}

Next, we observe that we have the \cinl{ext}-constructor on both sides of the equation.
By applying the tactic \cinl{f_equal}, we use the following predefined lemma about functional equality.

\begin{crepl}
\coqrepl Check f_equal.
  f_equal : forall (A B : Type) (f : A -> B) (x y : A),
    x = y -> f x = f y
\end{crepl}

In the case above, we have \cinl{ext tt} as function that is applied to \cinl{ we know that the function application of \cinl{ext tt} to the argument \cinl{(fun p : One__P tt => match p with end)} on the left-hand side and to \cinl{pf} on the right-hand side of the equation.
 
\begin{cproof}{f_equal.}
  pf : One__P tt -> A
  ============================
  (fun p : One__P tt => match p with end) = pf
\end{cproof}

The assumption of the \cinl{f_equal}-lemma becomes the new goal: we now need to show that the two position functions are the same.
In functional programming we are used to a property called functional extensionality: two functions \cinl{f : A -> B} and \cinl{g : A -> B} are equal, if for all possible input argument of appropriate type, they yield the same result.

\begin{minted}{crepl}
\coqrepl Check  functional_extensionality.
  functional_extensionality : forall (A B : Type) (f g : A -> B),
    (forall x : ?A, f x = g x) -> f = g
\end{crepl}

We can use the corresponding tactic \cinl{extensionality} to introduce a new variable \cinl{x} f appropriate type that is used as argument on both sides of the equation.

\begin{cproof}{extensionality p.}
  pf : One__P tt -> A
  p : One__P tt
  ============================
  match p return A with end = pf p
\end{cproof}

Finally, we prove the statement by realising that the newly introduced argument \cinl{p} of type \cinl{One__P tt} is a value of an empty type.
Recall that \cinl{One__P tt} can be inlined to \cinl{Empty}.
That is, we finish the proof by trying to destruct the value \cinl{p} into its corresponding constructors.
Coq realises that there are no values of that type, which proves the last goal.

\begin{cproof}{destruct p. Qed.}
from_to_One is defined
\end{cproof}

The second direction of the isomorphism proof is straightforward.
After introducing all variables and destructing the argument \cinl{o : One A}, we simplify the left-hand side of the equation using the function definitions of \cinl{from_One} and \cinl{to_One}.
The simplification already leads to the value \cinl{one : One A}} on the left-hand side as well as on the right-hand side.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Lemma to_from_One : forall (A : Type) (o : One A),
    to_One (from_One o) = o.
Proof.
  intros A o.
  destruct o; reflexivity.
Qed.
\end{minted}
