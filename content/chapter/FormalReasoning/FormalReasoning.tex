\cleanchapterquote{There is no deep theoretical reason why this
  program should be rejected [...].}{Adam Chlipala}{(Associate
  Professor of Computer Science)}

This chapter moves the focus from applications using effects like non\--determinism to an approach to model effectful programs in order to apply equational reasoning using a proof assistant.
Equational reasoning is a popular and common tool to prove properties about effectful functional programs and, thus, prominently used by Haskell enthusiasts \citep{jeuring2012testing, gibbons2011just, hutton2008reasoning}.
In particular, \citet{danielsson2006fast} argue that reasoning about total programs only and expecting the result to carry over to partial programs is \textit{morally correct}.
Nevertheless, since we are interested in proving properties about partial or other effectful programs more explicitly, we cannot apply equational reasoning as it is and need a model to represent such  effects.
In this chapter we present an approach to model effectful non\--strict functional programs in the proof assistant Coq and prove exemplary properties about functions used in functional languages.
Our running example is often used as a finger exercise for proofs in a total setting.
The main insight of our approach is that a lot of these properties carry over to partial languages: these properties still hold if partial values or non\--deterministic computations are at play.
Our approach allows to reason about a whole class of effects, and not only about a concrete effect like partiality or non\--determinism.
The interesting outcome of this approach is that one proof is enough to prove a proposition for a whole class of effects.
In the following we refer to this insight as proving effect\--generic properties.

After discussing the general idea for a framework to model effectful non\--strict functional programs, we emphasise one effect occurring in Haskell: partiality.
We present our approach using the example of the associativity of Haskell's function \hinl{append} to concatenate two lists.

Last but not least we give an outlook on first ideas to model Curry programs.
The underlying effect of Curry is non\--determinism in combination with laziness, that is, non\--strictness and sharing.
As we have seen in previous chapters, the combination of non\--determinism and non\--strictness behaves with respect to Curry's call\--time choice semantics, that is, variables denote values and not computations.
We show how to model non\--determinism and discuss the problem of modelling a language with sharing.
That is, we make more clear that our framework currently models non\--strict program semantics, but does not handle lazy semantics.
More precisely, we can model call\--by\--name but not call\--by\--need.

In summary, this chapter makes the following contributions.

\begin{itemize}
\item We present a generic model of effectful non\--strict functional programs in the proof assistant Coq.
\item In order to define a valid representation of effectful programs, we take the reader on an introductory tour of Coq's intricacies.
\item We implement a model of effectful data structures that pleases Coq's termination checker.
\item We argue that our approach is especially beneficial when it comes to effect\--generic properties: instead of individually proving a property for each new effect of interest, we can prove such a property for a variety of effects once and for all.
\item We present first ideas on modelling Curry's non\--determinism and discuss arising obstacles when trying to model call\--time\--choice.
\item In the light of these obstacles, we discuss that our current framework works well for call\--by\--name semantics, but does not work for call\--by\--need semantics out\--of\--the box.
\item Moreover, we show some examples that illustrate why this distinction comes up when modelling Curry's non\--determinism but not for partiality.
\end{itemize}
 
\section{A Generic Model For Effectful Non\--Strict Programs}

In this section we will present our general approach to model effectful non\--strict programs in a dependently\--typed language like Coq.
We illustrate why previous work is insufficient for our goals and does not tackle the same problem as we do, respectively.
Since the reasons for the insufficiency of the previous work is due to rather technical details of dependently\--typed languages and the general idea of propositions as types \citep{wadler2015propositions}, we give a detailed explanation to illustrate which steps are necessary to model our approach in Coq.
That is, this section tries to explain the obstacles and their solutions in Coq in a beginner\--friendly way.

\subsection{Representation of Partial Programs}
\label{subsec:partial}
The first obstacle that arises when we want to prove properties about Haskell programs in Coq is the fact that Coq is a total language while often Haskell programs are partially defined.
That is, we cannot translate partial Haskell programs into Coq as they are, we need to represent the partial parts of the programs more explicitly.
In the context of this thesis, partial programs or function definitions are terminating but do not yield a defined output for all inputs.

Let us take a look at an example.
One of the first partial functions that comes to mind is the \hinl{head} function on lists that we defined in \autoref{code:haskell_head}.
In case of the empty list the function is not defined as there is no element to return.

\begin{haskellcode}
head :: [a] -> a
head []    = undefined
head (x:_) = x
\end{haskellcode}

In a total language like Coq, the corresponding head function usually takes an additional argument to take care of the undefined behaviour in case of the empty list.
The following implementation is part of Coq's predefined library for lists.

\begin{coqcode}
Definition hd (A : Type) (default : A) (l : list A) : A = 
  match l with
  | nil      => default
  | cons x _ => x
  end.
\end{coqcode}

Alternatively, we can indicate the potentially undefined behaviour by changing the result type to \cinl{option A}.
In case of a non\--empty list we wrap the head element into the \cinl{Some}\--constructor, and use \cinl{None} as resulting value for an empty list.
This alternative implementation is predefined under the name \cinl{head}.

\begin{coqcode}
Inductive option (A : Type) :=
| None : option A
| Some : A -> option A.

Definition head (A : Type) (l : list A) : option A  = 
  match l with
  | nil    => None
  | cons x _ => Some x
  end.
\end{coqcode}

The latter version suites our problem a bit better than the first: there is not always a good candidate in scope that can be used as default value, the latter version fits a general setting better.
However, the latter version is not compositional.
Consider the following example that uses the result of \cinl{head} as an argument.

\begin{coqcode}
Fail Definition exampleList (A : Type) : list A :=
  cons (head (cons 1 nil)) nil.
\end{coqcode}

We cannot use the result as an element of the newly constructed list, we get a type error.

\begin{quote}
\emph{The term "cons (head nil) nil" has type "list (option ?A)" while it is expected to have type "list A".}
\end{quote}

The list constructor \cinl{cons} expects the head element of the list to match its type with all the remaining elements of the list.
Since we want to construct a list of type \cinl{list A}, the head element needs to be of type \cinl{A}; the function \cinl{head}, however, yields a value of type \cinl{option A}.

As Haskell is a non\--strict language, it is crucial that we allow partial values at top\--level as well as within the components of data structures, that is, within arguments of constructors, in order to model Haskell's partiality correctly.
Due to non\--strictness, it is possible that an undefined value is never demanded during evaluation.
The Haskell expression \hinl{head (1 : undefined)}, for example, does not trigger the \hinl{undefined} value in the tail of the list, because \hinl{head} only demands the first list constructor and ignores the second argument.
In order to have a aptronym for the representation of partial values, we define a new data type \cinl{partial} that captures the notion that a value can be undefined or defined more clearly than the predefined type \cinl{option} like we have already seen for Haskell in \autoref{code:partial_haskell}.

\begin{coqcode}
Inductive partial (A : Type) :=
| undefined : partial A
| defined   : A -> partial A.
\end{coqcode}

When using a data type like lists we need to adapt the definition of the data type itself by lifting all arguments to allow partial values a well.

\begin{coqcode}
Inductive List (A : Type) :=
| nil : List A
| cons : partial A -> partial (List A) -> List A.
\end{coqcode}

The data type \cinl{List} represents a Haskell list in Coq as all constructor arguments may be partial.
When defining functions on lists, we need to consider that the top\--level list constructor may already be undefined.
The definition of  functions like \cinl{head} adapts to the settings as follows: all arguments as well as result types need to be lifted and the implementation needs to handle the partial values accordingly.

\begin{coqcode}
Definition head (A : Type) (pxs : partial (List A)) : partial A :=
  match pxs with
  | undefined  => undefined
  | defined xs => match xs with
                 | nil       => undefined
                 | cons px _ => px
                 end
  end.
\end{coqcode}

We cannot pattern match on the list directly as in the original definition.
In order to access the list, we need to take a look at the \cinl{partial}\--layer first.
In case of an \cinl{undefined} input list, the overall result is \cinl{undefined} as well.
If the input list is \cinl{defined}, we can reimplement the original behaviour of the Haskell function, that is, yielding the first element in case of a non\--empty list and yielding \cinl{undefined} in case of an empty list.

Let us take a look at another list function in Haskell and its counterpart in our model for Coq: concatenation of two lists.

\begin{haskellcode}
(++) :: [a] -> [a] -> [a]
(++) []       ys = ys
(++) (x : xs) ys = x : (xs ++ ys)
\end{haskellcode}

The concatenation function on lists is a recursive and total function and can, thus, be translated to Coq as it is.
However, since we want to mix partial and total functions and, thus, increase the compositionality of both possible effects, we translate the append function using the same scheme as above.

\begin{coqcode}
Fail Fixpoint append (A : Type) (pxs pys : partial (List A))
  : partial (List A) :=
  match pxs with
  | undefined  => undefined
  | defined xs => match xs with
                 | nil         => pys
                 | cons pz pzs => defined (cons pz (append pzs pys))
                 end
  end.
\end{coqcode}

The function \cinl{append} is recursive and, as far as we are concerned, the first argument is structurally decreasing in each
recursive call.
However, Coq does not accept the above definition and rejects it with the following message.

\begin{quote}
\emph{The command has indeed failed with message: Cannot guess decreasing
argument of fix.
Recursive call to append has principal argument equal to "pzs" instead of a subterm of "pxs".}
\end{quote}

What is going on here?
Coq cannot retrace that the value \cinl{pzs} is actually a subterm of \cinl{pxs}; without that connection the recursive call on \cinl{pzs} is not allowed.
The problem is our lifted data type definition of
\cinl{List}.
Due to the lifting, the \cinl{List} becomes a so\--called \emph{nested inductive} type, because the type we want to define
appears nested in another inductive type.
In this case the other inductive type is \cinl{partial}.

We fix the problem by splitting the function into a non\--recursive and a recursive part.
The recursive part is working only on \cinl{List A} and produces a \cinl{partial (List A)}, while the non\--recursive
function expects and yields a value of type \cinl{partial (List A)}, and mainly calls the recursive function after unwrapping the
\cinl{partial}\--layer.

\begin{coqcode}
Definition append (A : Type) (pxs pys : partial (List A))
  : partial (List A) :=
  match pxs with
  | undefined  => undefined
  | defined xs =>
    let fix append' xs pys :=
        match xs with
        | nil         => pys
        | cons pz pzs => defined (cons pz (match pzs with
                                          | undefined  => undefined
                                          | defined zs => append' zs pys
                                          end))
        end
    in append' xs pys
  end.
\end{coqcode}

The recursive function is the local function \cinl{append'} that is introduced using \cinl{let fix}.
In order to make the recursive call we need to unpack an additional \cinl{partial}\--layer of the variable \cinl{pzs}.
Since we are now reconstructing the nested inductive structure using a nested recursion, Coq accepts the definition.

In the remainder of this chapter we will define the two functions necessary to translate a recursive Haskell function on top\--level to reuse the definitions in proofs.
The recursive function that works directly on the nested inductive type will be suffixed like the local function definition \cinl{append'}.
That is, the following code shows how the above code can be split into two top\--level functions.

\begin{coqcode}
Fixpoint append' (A : Type) (xs : List A) (pys : partial (List A))
  : partial (List A) :=
  match xs with
  | nil         => pys
  | cons pz pzs => defined (cons pz (match pzs with
                                    | undefined  => undefined
                                    | defined zs => append' zs pys
                                    end))
  end.

Definition append (A : Type) (pxs pys : partial (List A))
  : partial (List A) :=
  match pxs with
  | undefined  => undefined
  | defined xs => append' xs pys
  end.
\end{coqcode}

\subsection{Generalisation Attempt}
\label{subsec:genericLifting}

Up to now, we have seen an encoding of Haskell programs in Coq that lifts all Haskell values to \cinl{partial} values.
The overall goal is to not only reason about Haskell's partiality effect but a whole class of effects.
For example the effects we enumerated and discussed in \autoref{subsec:monadicAbstractions}: I/O, tracing, error, or non\--determinism.
That is, we do not want to restrict our model in Coq to one effect only, but generalise it to arbitrary effects.

The first idea that comes to mind to generalise the above encoding is to change the concrete type \cinl{partial} by adding a type parameter.
Hence, we can regain the above encoding by instantiating the type parameter with \cinl{partial}.
Consider the following parametrised definition of \cinl{List}.

\begin{coqcode}
Fail Inductive List (M : Type -> Type) (A : Type) :=
| nil : List M A
| cons : M A -> M (List M A) -> List M A.
\end{coqcode}

Similar to \cinl{partial} that corresponds to the Maybe monad that we know from Haskell, we will be mostly interested in other monadic instantiations and follow the idea of monadic abstractions we discussed in \autoref{subsec:monadicAbstractions}.
Thus, we name the type parameter \cinl{M} to indicate that it is a placeholder for a monadic type.
This representation was already suggested by \citet{abel2005verifying}, who translated Haskell code into Agda~\citep{norell2009dependently} code in order to prove propositions about Haskell functions.
Their approach, however, is not applicable in recent versions of Agda nor Coq anymore.
When we try to compile the above definition, we get the following error message.

\begin{quote}
\emph{The command has indeed failed with message:
Non strictly positive occurrence of "List" in "M A $\rightarrow$ M (List M A) $\rightarrow$ List M A".}
\end{quote}

Coq does not allow to define a type definition like \cinl{List} because of its \emph{strict positivity requirement}.
What is going on this time?

As a first step to understand what is going on here, we will reduce the above definition to the simplest definition that still triggers the same error message.

\begin{coqcode}
Fail Inductive NonStrictlyPos :=
| con : (NonStrictlyPos -> nat) -> NonStrictlyPos.
\end{coqcode}

The data type \cinl{NonStrictlyPos} has no type parameters and only one unary constructor \cinl{con}.
The argument of the constructor \cinl{con} is a function from \cinl{NonStrictlyPos} to \cinl{nat}.
The domain of this function is the crucial part of the definition and the origin of the error message.
As so often when using Coq, \citet{chlipala2013certified} is a great resource introducing typical obstacles beginners may face when using Coq for the first time.
\citeauthor{chlipala2013certified} makes the following comment concerning Coq's strict positivity requirement.

\begin{quote}
\emph{We have run afoul of the strict positivity requirement for inductive definitions, which says that the type being defined may not occur to the left of an arrow in the type of a constructor argument.}
\end{quote}

Inductive type definitions obey the strict positivity requirement, if the recursive occurrences of the type only occur strictly positive in all argument types for all constructors.
That is, in case of \cinl{NonStrictlyPos} we need to inspect the types of the arguments of its only constructor \cinl{con}.
The only argument of \cinl{con} is the function type \cinl{NonStrictlyPos -> nat}.

\begin{excursus}{Positive and Negative Occurrences}
According to the error message Coq produces when we try to compile the data type \cinl{List}, the type definition violates a strict positivity restriction; but what is a positive occurence?
Taking the quote of Chlipala to a more formal ground, the strictly positive occurrence of a type is described as follows: a type $\tau$ occurs strictly positively in a type $\tau_1\rightarrow \dots \rightarrow \tau_n \rightarrow \tau$, if and only if $\tau$ does not occur in any of the types $\tau_i$ with $i$ ranging from $1$ to $n$.
Although this description might answer the question we raised to some extent, it raises new ones as well: how do we distinguish between \emph{positive} and \emph{strictly positive} occurrences, and can an occurrence be \emph{negative} as well?

For that matter, let us consider an arbitrary type $\tau = t_1 \rightarrow \dots \rightarrow t_n$, where all $t_i$ are types as well.
The type arguments $t_1$ to $t_n$ appear in positive or negative positions.
A type argument $t_i$ has a negative position if it appears to the left of an odd number of type arrows.
That is, starting from an inner (nested) position, each type arrow flips a negative position to a positive and vice versa.
In particular, a type argument $t_i$ has a positive position if it appears to the left of an even number of type arrows or no type arrows at all.
Moreover, a type $t$ occurs strictly positively in $t_1 \rightarrow \dots \rightarrow t_n \rightarrow t$ if $t$ occurs in no $t_i$.
For more information, \citet{blanqui2002inductivedatatype}  give an inductive definition of the set of negative and positive positions.

Here, we consider some examples to clarify the definition of negative, positive and strictly positive positions.
Consider the following examples of possible types in Coq, where \cinl{A} is a type variable.

\begin{enumerate}
\item[(1)] \cinl{A -> nat}
\item[(2)] \cinl{nat -> A}
\item[(3)] \cinl{(A -> nat) -> nat}
\item[(4)] \cinl{((A -> nat) -> nat) -> nat}
\end{enumerate}

The type \cinl{A} occurs positively in (2) and (3), and negatively in (1) and (4).
The occurrence in (2) is also strictly positive.

In dependently typed languages, the strict positivity requirement plays an important role for the definition of inductive data types.
An inductive type t obeys the strict positivity requirement if the recursive occurrences of t are strictly positive in the types of all the arguments of its constructors.\footnote{The definition by \citeauthor{blanqui2002inductivedatatype} also takes care of mutual inductive types where the recursive occurrence is only implicit.}

Consider once again the following exemplary type definitions in Coq.

\begin{enumerate}
\item[(1)] \cinl{Inductive T := con : T -> T -> T}
\item[(2)] \cinl{Inductive T := con : (T -> T) -> T}
\item[(3)] \cinl{Inductive T := con : (nat -> T) -> T}
\item[(4)] \cinl{Inductive T := con : (nat -> T) -> (T -> T) -> T}
\end{enumerate}

The inductive type \cinl{T} obeys the strict positivity requirement in (1) and (3), and violates it in (2) and (4).
In (1) we need to check the following arguments of the constructor \cinl{con}: both arguments of type \cinl{T} and both types are strictly positive.
The argument in question for (3) is \cinl{nat -> T}, where \cinl{T} does not occur to the left of an arrow, thus, the type is strictly positive as well.
In (2) we need to inspect the type \cinl{T -> T}; here, \cinl{T} occurs to the left of an arrow, thus, in a negative position.
The overall definition, then, does not fulfil the requirement.
The inductive type in (4) is a combination of (2) and (3), thus, the type of the first argument of \cinl{con} fulfils the requirement, whereas the second arguments violates it again.
\end{excursus}

Let us think again about the definition of \cinl{NonStrictlyPos}.
With the excursus above, we now know that \cinl{NonStrictlyPos} occurs ``left of an arrow''  in the first argument of the \cinl{con}\--constructor, namely in the function type \cinl{NonStrictlyPos -> nat}.
Due to this non strictly positive occurence, the overall data type definition of \cinl{NonStrictlyPos} is non strictly positive as well, that is, fails the strict positivity requirement for data type definitions.
In contrast, the following definition is not problematic.

\begin{coqcode}
Inductive StrictlyPos :=
| con : StrictlyPos -> (nat -> StrictlyPos) -> StrictlyPos.
\end{coqcode}

Here, both arguments of the constructor \cinl{con} are strictly positive: the first argument is of type \cinl{StrictlyPos}, thus, trivially strictly positive; and in the second argument's type \cinl{StrictlyPos} does not occur to the left, but to the right of an arrow, fulfilling the positivity requirement as well.

The above excursus explains the origin of the error message Coq presents us when we try to define data types like \cinl{NonStrictlyPos} and \cinl{List}, but two question still remain open.

\begin{enumerate}
\item Why is the strict positivity of data type definitions required in Coq?
\item Why is our definition \cinl{List} non strictly positive as well, although there is no function arrow in the argument types of \cinl{cons}?
\end{enumerate}

\subsubsection{Why does Coq require the strict positivity of data type definitions?}

Let us for a moment assume that the definition of \cinl{NonStrictlyPos} was allowed.
We then define the following function.\footnote{We do not use code highlighting to distinguish the following hypothetical code from valid Coq code.}

\begin{verbatim}
Definition applyFun (t : NonStrictlyPos) : nat :=
  match t with
  | con f => f t
  end.
\end{verbatim}

The function \cinl{applyFun} takes a value \cinl{t} of type \cinl{NonStrictlyPos} and applies the function \cinl{f} inside the
argument of the \cinl{con}\--constructor to the value \cinl{t} itself.
A problematic example usage of this function is the expression \cinl{applyFun (con applyFun)}.
Reducing the expression by using the definition of \cinl{applyFun} yields \cinl{applyFun (con applyFun)} again.
We can apply this reduction infinitely often, thus, we have constructed an expression that does not terminate.
Taking a step back, we observe that the data type \cinl{NonStrictlyPos} has some resemblance with a specialised instance
of the fixpoint combinator \cinl{Mu}.

\begin{coqcode}
Fail Inductive Mu A :=
| mu : (Mu A -> A) -> Mu A.
\end{coqcode}

Note that we cannot define the type \cinl{Mu} in Coq.
The connection to the fix\--point combinator explains why Coq needs to restrict such a definition: we know that all Coq programs need to terminate and we need to use a special keyword \cinl{Fixpoint} or \cinl{fix} to indicate recursive functions in order to apply termination checks with respect to recursion.
If we could define a data type like \cinl{Mu}, our definition of \cinl{applyFun} is an example that shows how we can define non\--terminating programs without using the explicit fix\--point combinator that Coq already provides for recursive constructions.
That is, data types like \cinl{Mu} introduce the capability to express general recursion and Coq's logic becomes inconsistent.
In order to ensure the consistency of Coq's logic, the strict positivity requirement needs to be enforced for data type definitions.

\subsubsection{Why does \cinl{List} not fulfil the strict positivity requirement?}

Now we know what Coq is nagging about when the error message about a non strictly positive occurrence for data type definitions appears.
However, it is still not obvious why the definition of \cinl{List} falls under the same category.
Recall our attempt to define the data type \cinl{List}.

\begin{coqcode}
Fail Inductive List (M : Type -> Type) (A : Type) :=
| nil : List M A
| cons : M A -> M (List M A) -> List M A.
\end{coqcode}

The type \cinl{List} does not appear to the left of an arrow in the argument types of its constructor \cinl{cons}, but Coq still rejects the definition because of the type \cinl{M (List M A)}.
However, Coq is of course on the right track rejecting such a definition.
While a concrete instantiation using \cinl{partial} instead of the type parameter \cinl{M} is accepted, since \cinl{List} does not appear to the left of an arrow, we cannot guarantee that all usages of \cinl{List} obey this requirement.
For example, consider the following definition that we might use to instantiate the type parameter with.

\begin{coqcode}
Definition Cont R A := (A -> R) -> R.
\end{coqcode}

The type \cinl{Cont} represents the continuation monad.
Now let us instantiate the type parameter \cinl{M} in the definition of \cinl{List} with \cinl{Cont R} for an arbitrary \cinl{R}, a concrete monad.
The following type definition \cinl{ListCont} inlines the definition of \cinl{Cont} in the constructor corresponding to \cinl{cons}.

\begin{coqcode}
Fail Inductive ListCont R A :=
| nilC  : ListCont R A
| consC : ((A -> R) -> R) -> ((ListCont R A -> R) -> R) -> ListCont R A.
\end{coqcode}

Due to the inlining, it now becomes apparent that the type \cinl{ListCont} appears indeed to the left of an arrow in one of the type arguments of its constructor.
More precisely, \cinl{ListCont} appears to the left of an arrow in the second argument of the \cinl{consC}\--constructor.
Summarising our findings, the type definition \cinl{List} defined above allows arbitrary type constructors as instances for its type parameter \cinl{M}.
Since the type parameter is arbitrary, it is not safe to use this definition for all potential instances of \cinl{M}.
The strict positivity restriction might be violated for a concrete instation of \cinl{M}, for instance, for the concrete instantiation of \cinl{Cont} as we demonstrated in the definition of \cinl{ListCont}.
Since we cannot guarantee by definition that the data type definition \cinl{List} is only used with instantiations of \cinl{M} that obey the strict positivity requirement, Coq rejects the definition.

\subsection{Free Monad and Containers}
\label{subsec:freeAndContainers}

Let us summarise the situation so far.
We want to model effectful data types and functions, for example representing non\--strict partial programs, in a generic way, but cannot use a type constructor variable to represent this generic effect in Coq due to the strict positivity requirement.
If we use, however, a concrete effect, like \cinl{partial}, the strict positivity is guaranteed again.
That is, we want to represent effects using a concrete data type representation in order to satisfy Coq's requirement.
Recall that the effects we want to represent are all a superset of pure values.
Partiality, for example, adds \cinl{undefined} to the set of \cinl{defined} values.
The other mechanism the representation of effects needs to offer is a way to apply functions to pure values; in case of \cinl{partial} we have used pattern matching to unwrap the pure values in order the define \cinl{head} and \cinl{append}.
Fortunately, monadic abstractions as discussed in \autoref{subsec:monadicAbstractions} give us exactly these capabilities.
As in Haskell, we define a monad as type constructor class parametrised over \cinl{M} that allows to define functions \cinl{return : A -> M A} and \cinl{bind : M A -> (A -> M B) -> M B}.

The main goal is to retain the generality to model a wide range of arbitrary monads, but to use a concrete data type in order to fulfil the strict positivity requirement.
We can achieve this goal by using a data type that represents all strictly positive types in a constructive manner.
Fortunately, \citet{abbott2003categories} introduced the notion of containers to represent strictly positive types; their main insight is that all strictly positive types can be expressed using containers.
A container is described as a product of shapes and a position function.
The shape is a type \cinl{Sh} and the position type \cinl{Pos} is a type function that maps shapes to types.
Recall that we defined a container extension that gives rise to a functor in \autoref{sub:container} as follows.

\begin{coqcode}
Inductive Ext (Sh : Type) (Pos : Sh -> Type) A :=
| ext : !$\forall$! (s : Sh), (Pos s -> A) -> Ext Pos A.
\end{coqcode}

A container extension \cinl{Ext S P} is then isomorphic to a functor
\cinl{F}.
Using the following definition of \cinl{fmap} for \cinl{Ext}, we show
in \appref{subsec:appendix:extFunctor} that \cinl{Ext} fulfills the functor
laws.

\begin{coqcode}
Definition fmap (Shape : Type) (Pos : Shape -> Type) (A B : Type)
    (f : A -> B) (e: Ext Shape Pos A) : Ext Shape Pos B :=
    match e with
    | ext s pf => ext s (fun p => f (pf p))
    end.
\end{coqcode}

In \autoref{code:one_container} we defined an exemplary concrete instance of a container for the data type \cinl{One} and proved both structures are isomorphic, which we will recap shortly.
Since we are mainly interested in monads, we can go even further and use monadic containers as proposed by \citet{altenkirch2017monadic} and \citet{uustalu2017partiality}.
However, we decided against using monadic containers directly, as they, as far as we know, cannot be implemented in a constructive way, but are an extension of \cinl{Ext} that are modelled using a type class.

Since we know that all monads have a constructor that represents \emph{pure} values, the effect we want to model is everything that we gain on top of these defined values.
We define this property more explicitly using a free monad~\citep{swierstra2008data} as introduced in \autoref{subsec:freeMonad}: we either have a pure or an effectful value.

\begin{coqcode}
Fail Inductive Free F A :=
| pure   : A -> Free F A
| impure : F (Free F A) -> Free F A.
\end{coqcode}

As the effect is once again represented by a type constructor variable \cinl{F} that has the data type to be defined as argument, Coq does not accept the definition.
Fortunately, the type parameter \cinl{F} needs to be a functor in order to make a \cinl{Free F} a monad.
Or to it put differently, given a functor \cinl{F} the free monad construction lifts \cinl{F} to a monad.
Now we can apply the insight about representing strictly positive types as containers again: since container extensions are isomorphic to functors, there are a variety of functors that we can represent using containers.
We can change the definition of \cinl{Free} as follows to fulfil Coq's strict positivity requirement.

\begin{coqcode}
Inductive Free (Sh : Type) (Pos : Sh -> Type) A :=
| pure   : A -> Free Sh Pos A
| impure : Ext Sh Pos (Free Sh Pos A) -> Free Sh Pos A.
\end{coqcode}

The definition uses the container extension instead of a generic functor \cinl{F}, that is, we are still generic: not over all possible type constructors but over all strictly positive types.
Note, however, that we do not need the indirection using \cinl{Ext} explicitly, we instead define \cinl{Free} by inlining the definition of \cinl{Ext} in the constructor \cinl{impure} to make its usage more convenient.

\begin{coqcode}
Inductive Free (Sh : Type) (Pos : Sh -> Type) A :=
| pure   : A -> Free Sh Pos A
| impure : !$\forall$! s, (Pos s -> Free Sh Pos A) -> Free Sh Pos A.
\end{coqcode}

With this definition of \cinl{Free} at hand, we are well\--suited to define a lifted version of \cinl{List} as we wished to do at the beginning of this section.

\begin{coqcode}
Inductive List (Sh : Type) (Pos : Sh -> Type) A :=
| nil : List Sh Pos A
| cons : Free Sh Pos A -> Free Sh Pos (List Sh Pos A) -> List Sh Pos A.
\end{coqcode}

We also define smart constructors \cinl{Nil} and \cinl{Cons} as notations that wrap the list in the additional \cinl{pure}\--constructor to indicate that the top\--level expression is defined.

\begin{coqcode}
Notation Nil := (pure nil).
Notation Cons fx fxs := (pure (cons fx fxs)).
\end{coqcode}

\subsubsection{Representing Partiality using Free Monads and Containers}
\label{subsub:partiality_container}

In \autoref{code:one_container} we already defined the container extension for \cinl{One} as \cinl{Ext One!$_\text{S}$! One!$_\text{P}$!} and proved that both these structures form an isomorphism using the functions \cinl{from_One} and \cinl{to_One}.
The definitions looked as follows.

\begin{coqcode}
Definition One!$_\text{S}$! := unit.
Definition One!$_\text{P}$! (s : One!$_\text{S}$!) := Empty.

Definition from_One A (o : One A) : Ext One!$_\text{S}$! One!$_\text{P}$! A :=
  ext tt (fun (p : One!$_\text{P}$! tt) => match p with end).

Definition to_One A (e : Ext One!$_\text{S}$! One!$_\text{P}$! A) : One A :=
  one.
\end{coqcode}

Next up, we can also show that the resulting construction \cinl{Free One!$_\text{S}$! One!$_\text{P}$!}  is isomorphic to the monadic structure \cinl{partial}.
First, we define the conversion functions \cinl{to_partial} and \cinl{from_partial} analogous to the setup for \cinl{One} above.

\begin{coqcode}
Definition to_partial A (fx : Free One!$_\text{S}$! One!$_\text{P}$! A) : partial A :=
 match fx with
 | pure x     => defined x
 | impure _ _ => undefined
 end.

Definition from_partial A (p : partial A) : Free One!$_\text{S}$! One!$_\text{P}$! A :=
  match p with
  | undefined => let '(ext s pf) := from_One one in impure s pf
  | defined x => pure x
  end.
\end{coqcode}

Based on these conversion functions, we prove two lemmas that state that both possible compositions of these functions are the identity.

\begin{coqcode}
Lemma from_to_partial : !$\forall$! (A : Type) (fx : Free One!$_\text{S}$! One!$_\text{P}$! A),
    from_partial (to_partial fx) = fx.
Proof.
  intros A fx. destruct fx as [x | [] pf]; simpl.
  - reflexivity.
  - do 2 f_equal. extensionality p. destruct p.
Qed.

Lemma to_from_partial : !$\forall$! (A : Type) (p : partial    A),
    to_partial (from_partial p) = p.
Proof.
  intros A p. destruct p; reflexivity.
Qed.
\end{coqcode}

\subsubsection{Representing Totality using Free Monads and Containers}
\label{subsub:totality_container}
In order to see a second effect, we find some inspiration by \citet{abel2005verifying} who are interested in two effects: partiality and totality.
Since we have already discussed partiality, we will now take a look at how to model totality.
Of course, totality is, strictly speaking, not an effect, but describes the absence of any additional effects, we have pure values only.
A suitable monad to represent totality is the identity monad; in order to match our naming scheme used for partiality, we name the data type \cinl{total}.

\begin{coqcode}
Inductive total (A : Type) :=
| totality : A -> total A.
\end{coqcode}

When using a free monad to represent \cinl{total}, we only need to give a functor for the additional effect on top of pure values.
Since totality does not add any effects and describes pure values only, we need to model this absence of effects.
In terms of defining values using \cinl{Free F} that represent total values, we only want to be able to use the \cinl{pure}\--constructor.
The \cinl{impure}\--constructor, on the other hand, should not be available, it should be impossible to construct a value using \cinl{impure}.
That is, we need a functor without any constructors.
When an inductive type has no constructors, there is no way to construct a value of that type.
Once again, we use the same naming scheme as \citet{swierstra2008data} and define the type constructor \cinl{Zero} that has no values.

\begin{coqcode}
Inductive Zero (A : Type) := .
\end{coqcode}

Note that, in contrast to the \cinl{Empty} type, \cinl{Zero} is a type constructor as it has an additional type parameter \cinl{A}.
Similar to the definition of \cinl{One}, we do not use this type parameter.

In order to represent \cinl{Zero} as container, we once again need to define the corresponding shape and position type function.
Since \cinl{Zero} has no constructors, it has no shapes and no polymorphic values that we might want to access.
For both types we can reuse \cinl{Empty}.

\begin{coqcode}
Definition Zero!$_\text{S}$! := Empty.
Definition Zero!$_\text{P}$! (s : Zero!$_\text{S}$!) := Empty.
\end{coqcode}

For both conversion functions, \cinl{from_Zero} and \cinl{to_Zero}, the definition simply matches on the non\--existent value to define a function with the wanted type.

\begin{coqcode}
Definition from_Zero A (u : Zero A) : Ext Zero!$_\text{S}$! Zero!$_\text{P}$! A :=
  match u with end.

Definition to_Zero A (e : Ext Zero!$_\text{S}$! Zero!$_\text{P}$! A) : Zero A :=
  let '(ext s pf) := e in match s with end.
\end{coqcode}

It is quite trivial to prove that the conversion functions form an isomorphism as the following reasoning shows.

\begin{coqcode}
Lemma from_to_Zero : !$\forall$! (A : Type) (e : Ext Zero!$_\text{S}$! Zero!$_\text{P}$! A),
    from_Zero (to_Zero e) = e.
Proof.
  intros A e. destruct e as [[] pf].
Qed.

Lemma to_from_Zero : !$\forall$! (A : Type) (z : Zero A),
    to_Zero (from_Zero z) = z.
Proof.
  intros A z. destruct z.
Qed.
\end{coqcode}

The next step is to define the conversion functions \cinl{to_total} and \cinl{from_total} to show that using the container representation for \cinl{Zero} in combination with \cinl{Free} yields the original monad \cinl{total} again.

\begin{coqcode}
Definition to_total A (fx : Free Zero!$_\text{S}$! Zero!$_\text{P}$! A) : total A :=
  match fx with
  | pure x        => totality x
  | impure s _ => match s with end
  end.

Definition from_total A (t : total A) : Free Zero!$_\text{S}$! Zero!$_\text{P}$! A :=
  match t with
  | totality x => pure x
  end.
\end{coqcode}

\noindent
In fact, similar as for the case of the partiality monad, we can even show that the conversion functions form an isomorphism as well.

\begin{coqcode}
Lemma from_to_total : !$\forall$! (A : Type) (fx : Free Zero!$_\text{S}$! Zero!$_\text{P}$! A),
    from_total (to_total fx) = fx.
Proof.
  intros A fx. destruct fx as [x | [] pf]; reflexivity.
Qed.

Lemma to_from_total : !$\forall$! (A : Type) (t : total A),
    to_total (from_total t) = t.
Proof.
  intros A t. destruct t; reflexivity.
Qed.
\end{coqcode}

\subsubsection{Other Containers and Limitations}

We will later see that monads like tree and list, which are commonly used when modelling non\--determinism, can be represented using our approach as well.
There are also common monads from Haskell that have corresponding effects that are interesting to reason about.
For example, the writer and state monad that are used to model tracing and I/O\--interactions with the user, respectively.
We can model these effects using \cinl{Free} and a suitable container representation of the underlying effect.

Since we use containers to ensure Coq that we do not define a potentially non\--strictly positive type, the class of strictly positive types is the natural limitation when using our approach.
An example for a monad that we cannot represent with our approach is the continuation monad.
The continuation monad \cinl{Cont} was an exemplary instantiation of the type constructor variable \cinl{M}, such that our initial try to define \cinl{List} became non\--strictly positive.
The goal was to convince Coq that we won't use an instantiation like \cinl{Cont}, so it makes sense that we indeed cannot define a data type that is isomorphic to \cinl{Cont}.

In the end, we have to keep in mind that our approach using \cinl{Free} as representative for a generic monadic parameterisation can only represent monads that correspond to strictly positive types.

\subsection{Working with Free to Define Lifted Functions}
\label{subsec:liftedFunctions}

With the definition of \cinl{List} using \cinl{Free} to model generic effectful lists at hand, we can take a look at the definition of the function \cinl{append} again.
Analogous to the definition of \cinl{append} at the end of \autoref{subsec:partial}, we need to split the function into two parts: one part works on pure \cinl{List}s and takes care of pattern matching while the second part handles \cinl{Free}\--lifted arguments only.

For the remainder of this chapter, we will use \cinl{Free} and data types like \cinl{List} as type constructors of kind \cinl{Type -> Type} when used with a generic container, that is, we do not pass the corresponding shape and position function as argument.
Note, however, that this convention is a simplification for better readability only and the resulting definition would not compile in Coq.

In order to compare the differences of using \cinl{Free} to our concrete representation using \cinl{partial}, recall the definition of \cinl{append} and \cinl{append'}, respectively.

\begin{coqcode}
Fixpoint appendP' (A : Type) (xs : List A) (pys : partial (List A))
  : partial (List A) :=
  match xs with
  | nil         => pys
  | cons pz pzs => Cons pz (match pzs with
                            | undefined  => undefined
                            | defined zs => appendP' zs pys
                            end)
  end.

Definition appendP (A : Type) (pxs pys : partial (List A))
  : partial (List A) :=
  match pxs with
  | undefined  => undefined
  | defined xs => appendP' xs pys
  end.
\end{coqcode}

For better readability, we added the suffix \cinl{P} for this version of \cinl{append} that uses \cinl{partial}.
Let us now try to transfer the general idea of \cinl{appendP'} to define a version using \cinl{Free}.

\begin{coqcode}
Fail Fixpoint append' A (xs : List A) (fys : Free (List A)) :=
 match xs with
 | nil         => fys
 | cons fz fzs => pure (cons fz (match fzs with
                          | pure zs     => append' zs fys
                          | impure s pf => _ (* what to do here? *)
                          end))
 end.
\end{coqcode}

A case distinction on the concrete constructors of \cinl{partial} was quite simple, in the case of \cinl{Free} and its representation using \cinl{Ext}, however, the second constructor \cinl{impure} has recursive occurrences of values of type \cinl{Free}.
That is, a case distinction like in the definition of \cinl{appendP'} needs to be defined as a recursive function when using \cinl{Free}.

Recall that the basic idea is to model monadically lifted data types, that is, \cinl{Free} is a representative for a monad.
The case distinction we are using in the definition of \cinl{appendP'} is the monadic \emph{bind} function (\cinl{(>>=)}) in disguise.
Hence, we need to define bind for \cinl{Free} in order to transfer the above definition successfully.

\begin{coqcode}
Fixpoint free_bind A B (fx : Free A) (f : A -> Free B) : Free B :=
 match fx with
 | pure x      => f x
 | impure s pf => impure s (fun p => free_bind (pf p) f)
 end.
\end{coqcode}

The definition of \cinl{free_bind} distinguishes between the two possible constructors \cinl{pure} and \cinl{impure}; in the former case we have a value \cinl{x} in place that \cinl{f} can be applied to.
In the latter case we have variable bindings \cinl{s} and \cinl{pf} for the shape and position function to work with.
Note that the position function applied to a position yields a \cinl{Free}\--value again, that is, \cinl{pf} has type
\cinl{Pos s -> Free A}.
The trick is that we just need to reconstruct the effect that we have seen, characterised by its shape \cinl{s}, and apply the function \cinl{f} recursively for all recursive occurrences of the effect that we can access using the position function \cinl{pf}.

With the definition of \cinl{free_bind} at hand, we can go ahead and start the second try to define \cinl{append'}: now we know that we need to use \cinl{free_bind} instead of an explicit case distinction.
More precisely, the usage of \cinl{free_bind} mimics the evaluation to head normal form, which is exactly how pattern matching in Haskell behaves when using a case distinction.

\begin{coqcode}
Fail Fixpoint append' A (xs : List A) (fys : Free (List A)) :=
  match xs with
  | nil         => fys
  | cons fz fzs => Cons fz (free_bind fzs (fun zs => append' zs fys))
  end.
\end{coqcode}

Unfortunately, the definition of \cinl{append'} is not accepted by Coq, because it cannot guess the decreasing argument of the provided fixpoint function.
More precisely, Coq gives the following error message when we provide the information that the list \cinl{xs} is supposed to be the decreasing argument.

\begin{quote}
\emph{Recursive call to append' has principal argument equal to "zs" instead of "fzs".}
\end{quote}

What is the problem now?

\begin{excursus}{Definition of recursive, higher\--order functions}

Once again Coq is not content with the way we define our programs.
In this case, the fault is not with \cinl{append}, but with the definition of \cinl{free_bind}.
As a recursive, higher\--order function that uses the same function as its functional argument for each recursive call, we need to convince Coq that the function indeed stays the same.
That way, Coq comprehends that the overall function terminates, if it does not depend on the function we pass as higher\--order argument.
That is, the problem is not specific to \cinl{free_bind} and our usage of \cinl{Free}, but a general problem for recursive, higher\--order functions.
Consider, for example, the definition of \cinl{map} for ordinary lists.
Note that the constructors \cinl{nil} and \cinl{cons} used in this excursus are exclusively used as names for the constructors of the predefined \cinl{list} type.

\begin{coqcode}
Fixpoint map A B (f : A -> B) (xs : list A) : list B :=
 match xs with
 | nil       => nil
 | cons x xs => cons (f x) (map f xs)
 end.
\end{coqcode}

Next, we give a definition for rose trees, consisting of a \cinl{leaf}\-- and \cinl{branches}\--constructor.
The \cinl{branches}\--constructor uses a list to allow for arbitrary branching of the tree.

\begin{coqcode}
Inductive rose A :=
| leaf     : A -> rose A
| branches : list (rose A) -> rose A.
\end{coqcode}

When we then try to define a map\--like function for \cinl{rose} as well, we might be tempted to just reuse the \cinl{map} function for lists to handle the \cinl{branches}\--constructor.

\begin{coqcode}
Fail Fixpoint mapRose A B (f : A -> B) (r : rose A) : rose B :=
 match r with
 | leaf x      => leaf (f x)
 | branches rs => branches (map (fun x => mapRose f x) rs)
 end.
\end{coqcode}

However, Coq once again does not recognise that this definition of \cinl{mapRose} terminates.
It raises the following error message.

\begin{quote}
\emph{Recursive call to mapRose has principal argument equal to "x" instead of "rs".}
\end{quote}

Due to the usage of \cinl{map}, Coq's termination checker fails to recognise that the recursive call of \cinl{mapRose} will eventually terminate.
Fortunately, there is a simple scheme to convince Coq that the function \cinl{map} is inductively recursive over its list argument and, more importantly, the supplied function does not determine the termination.
That is, \cinl{map} terminates independently of its functional argument.
Consider the following alternative definition of \cinl{map}.

\begin{coqcode}
Definition map A B (f : A -> B) (xs : list A) : list B :=
 let fix map' xs :=
     match xs with
     | nil       => nil
     | cons x xs => cons (f x) (map' xs)
     end
 in map' xs.
\end{coqcode}

Instead of declaring a recursive function on top\--level using the keyword \cinl{Fixpoint}, we declare a local fixpoint only.
In this case, the local recursive function \cinl{map'} has only one parameter, namely the list argument, and reuses the function \cinl{f} that is passed to the top\--level function \cinl{map}.
Due to the explicit fixpoint definition that does not have the higher\--order function as argument anymore, Coq's termination checker can realise that the termination of \cinl{map} does not depend on the function \cinl{f}.

An alternative, but equivalent definition, uses section variables to introduce the type parameters and the higher\--order argument.

\begin{coqcode}
Section map.

 Variable A B : Type.
 Variable f : A -> B.

 Fixpoint map (xs : list A) : list B :=
   match xs with
   | nil       => nil
   | cons x xs => cons (f x) (map xs)
   end.

End map.
\end{coqcode}

We can declare variables with their associated types for usage within a section.
Outside of the section, the function \cinl{map} gets all arguments used in its definition as further arguments.
Moreover, the code that Coq generates for the second version with section variables is exactly the first implementation given above.

Independent of which of the two implementations we chose, we can now use \cinl{map} to define \cinl{mapRose} and Coq accepts the definition as terminating.

\begin{coqcode}
Fixpoint mapRose A B (f : A -> B) (r : rose A) : rose B :=
 match r with
 | leaf x      => leaf (f x)
 | branches rs => branches (map (mapRose f) rs)
 end.
\end{coqcode}
\end{excursus}

Now let us go back to our initial problem with the definition of \cinl{append'} using the higher\--order, polymorphic auxiliary function \cinl{free_bind}.
The problem that arose for the definition of \cinl{append'} using \cinl{free_bind} is analogous to the definition of \cinl{roseMap} using \cinl{map}.
That is, we need an alternative implementation of \cinl{free_bind} that follows the scheme above: the recursion of \cinl{Free} needs to be explicitly independent of the functional argument.
We then end up with the following definition of \cinl{free_bind}.

\begin{coqcode}
Definition free_bind A B (fx : Free A) (f : A -> Free B) : Free B :=
 let fix free_bind' fx :=
     match fx with
     | pure x      => f x
     | impure s pf => impure s (fun p => free_bind' (pf p))
     end
 in free_bind' fx.
\end{coqcode}

In order to use \cinl{free_bind} as an operator \cinl{(>>=)} as known from Haskell, we additionally define the following notation.

\begin{coqcode}
Notation "fx >>= f" := (free_bind fx f) (at level 40, left associativity).
\end{coqcode}

Last but not least, we are finally equipped to define the auxiliary function \cinl{append'} as well as the final \cinl{append}\--function that is the generically lifted version of the corresponding Haskell function.

\begin{coqcode}
Fixpoint append' A (xs : List A) (fys : Free (List A)) :=
  match xs with
  | nil => fys
  | cons fz fzs => pure (cons fz (fzs >>= fun zs => append' zs fys))
  end.

Definition append A (fxs fys : Free (List A)) : Free (List A) :=
  fxs >>= fun xs => append' xs fys.
\end{coqcode}

\section{Proving Properties About Haskell Programs}

While we discussed the overall infrastructure and necessary preliminaries for a general framework to model non\--strict effectful
programs, we will focus on two effects occurring in Haskell: totality and partiality.
Both instantiations are of interest to motivate our effect\--generic reasoning.
That is, we follow the idea of \citet{abel2005verifying} and prove general propositions about Haskell's concatenation functions in three steps: first, we show that the proposition holds in the total setting and then show that it also holds in the partial setting.
On top of these both proofs, the last step makes the case for our generic approach: we prove the property once and for all for a whole class of effects.

\subsection{Three Proofs for the Associativity of Append}

Since it took us a whole section to define the function \cinl{append} for an effect\--generic \cinl{List} data type, it seems reasonable to prove a property for that function.
Thus, in this subsection we will focus on the associativity of append and prove this proposition in the total, partial and generic setting.
Since we encounter proofs for lifted data types and functions for the first time, we will present the proofs step\--by\--step.
We will, however, postpone technical details to the end of this subsection.
Thus, we explain the details of the proof from a more abstract perspective rather than diving deep into the technical details of the applied tactics.

\subsubsection{Totality}
In order to refresh the memory, the definition of the container to represent total programs shown in \autoref{subsub:totality_container} looks as follows.

\begin{coqcode}
Definition Zero!$_\text{S}$! := Empty.
Definition Zero!$_\text{P}$! (s : Zero!$_\text{S}$!) := Empty.
\end{coqcode}

That is, the container representing totality has neither a position nor a shape, thus, programs modelled as \cinl{Free Zero!$_\text{S}$! Zero!$_\text{P}$!} do not have any \cinl{impure} values by construction.
Whenever we encounter an \cinl{impure}\--constructor, we know that the accompanying shape \cinl{s : Zero!$_\text{S}$!} cannot exist.
Let us now take a look at the associativity of append in the total setting and see how we use this observation about the corresponding container when proving a proposition.

\begin{coqcode}
Lemma append_assoc_total :
 !$\forall$! (A : Type) (fxs fys fzs : Free Zero!$_\text{S}$! Zero!$_\text{P}$! (List Zero!$_\text{S}$! Zero!$_\text{P}$! A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 intros A fxs fys fzs.
 destruct fxs as [ xs | s pf ]; simpl.
\end{coqcode}

In order to evaluate \cinl{append}, we make a case distinction on the first list argument \cinl{fxs}.
In case of a pure value, we have the following goal and assumptions.

\begin{alltt}
  A : Type
  xs : List Zero\(\sb{\text{S}}\) Zero\(\sb{\text{P}}\) A
  fys, fzs : Free Zero\(\sb{\text{S}}\) Zero\(\sb{\text{P}}\) (List Zero\(\sb{\text{S}}\) Zero\(\sb{\text{P}}\) A)
  ============================
  append' xs (append fys fzs) = append (append' xs fys) fzs
\end{alltt}

Now we can proceed as if we were working with ordinary lists: we proceed by induction on the \cinl{List} argument \cinl{xs}.

\begin{cproof2}{induction xs as [ | fx fxs IH ]; simpl.}{0.85}
  
  ...
  fys, fzs : Free Zero\(\sb{\text{S}}\) Zero\(\sb{\text{P}}\) (List Zero\(\sb{\text{S}}\) Zero\(\sb{\text{P}}\) A)
  ============================
  append fys fzs = append fys fzs

  ...
  IH : ForFree (fun xs => append' xs (append fys fzs)
                        = append (append' xs fys) fzs) fxs
  ============================
  Cons fx (fxs >>= (fun zs => append' zs (append fys fzs))) =
  Cons fx (fxs >>= append (fun zs => append' zs fys) fys)
\end{cproof2}

We then need to prove the proposition for \cinl{nil} and \cinl{cons}.
The former is trivial as both sides of the terms are already equal.
For the latter case, we proceed by stripping away the \cinl{Cons}\--constructor and take another look at \cinl{fxs} by destructing the induction hypothesis \cinl{IH}, which produces two cases: one for \cinl{pure} and one for \cinl{impure}.
Note that we will discuss the induction hypotheses \cinl{IH} that makes use of a custom proposition \cinl{ForFree} in detail later.

\begin{cproof2}{do 2 f_equal. destruct IH as [ xs H | ]; simpl.}{0.85}
  
  ...
  H : append' xs (append fys fzs) = append (append' xs fys) fzs
  ============================
  append' xs (append fys fzs) = append (append' xs fys) fzs

  ...
  s : Zero\(\sb{\text{S}}\)
  ============================
  ...
\end{cproof2}

In the former case, the induction hypothesis brings our current goal in the right form such that we can finish the subproof easily by rewriting the hypothesis \cinl{H} and applying \cinl{reflexivity}.
For the latter case we only need to focus on one of the assumptions, namely, \cinl{s : Zero!$_\text{S}$!}.
Since there cannot exist any value of type \cinl{Zero!$_\text{S}$!}, the subgoal is trivially true as one of the assumptions is a contradiction.
After destructing on the value \cinl{s}, there are no more subgoals and we have successfully proven the current goal.

The same reasoning applies for the last remaining goal.
We started with a case distinction on the original first list arguments \cinl{fxs} and are now in the \cinl{impure}\--case.

\begin{alltt}
  ...
  s : Zero\(\sb{\text{S}}\)
  ============================
  impure s (fun p : Zero\(\sb{\text{P}}\) s => append (pf p) (append fys fzs)) =
  impure s (fun p : Zero\(\sb{\text{P}}\) s => append (append (pf p) fys) fzs)
\end{alltt}

The assumption \cinl{s : Zero!$_\text{S}$!} is once again a bogus assumption, so we clear the last remaining goal by using \cinl{destruct s} again.

Now that we have successfully proven this statement, we will take a second look at the complete proof script, without the additional remarks and assumptions.
We improved the scripts a little bit and moved the \cinl{destruct} tactic directly after destructing the \cinl{Free}\--values, to finish the second subgoal immediately.
Alternatively, we could use a nested introduction pattern for \cinl{s} as well and destruct it directly using the pattern \cinl{[]}.
Then, the additional cases for \cinl{impure} would not be generated at all.

\begin{coqcode}
Lemma append_assoc_total :
 !$\forall$! (A : Type) (fxs fys fzs : Free Zero!$_\text{S}$! Zero!$_\text{P}$! (List Zero!$_\text{S}$! Zero!$_\text{P}$! A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 intros A fxs fys fzs.
 destruct fxs as [ xs | s pf ]; try destruct s; simpl.
 - induction xs as [ | fx fxs IH ]; simpl.
   + reflexivity.
   + do 2 f_equal. destruct IH as [ xs H | s pf ]; try destruct s; simpl;
       rewrite H. reflexivity.
Qed.
\end{coqcode}

The main difference between the above proof and a proof for associativity of the append function for ordinary lists is the unboxing of the additional \cinl{Free}\--layer of the list argument and tweaking the induction hypothesis to fit our needs.

\subsubsection{Partiality}
As next step, we consider an actual effect: partiality.
Again, we recall the definition of the container to represent partiality when using \cinl{Free} as introduced in \autoref{subsub:partiality_container}.

\begin{coqcode}
Definition One!$_\text{S}$! := unit.
Definition One!$_\text{P}$! (s : One!$_\text{S}$!) := Empty.
\end{coqcode}

This time, the corresponding container has one possible shape, but no positions.
The additional effect of representing undefined values does not contain any recursive occurence of the \cinl{Free} values, thus, the effect does not have any polymorphic components in its constructors.

Let us take a look at the proof for the associativity of append; we focus on the differences, as most of the proof is actually the same.
Hence, this time we show the entire proof script first and take a closer look at some subgoals afterwards.

\begin{coqcode}
Lemma append_assoc_partial :
 !$\forall$! (A : Type) (fxs fys fzs : Free One!$_\text{S}$! One!$_\text{P}$! (List One!$_\text{S}$! One!$_\text{P}$! A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 intros A fxs fys fzs.
 destruct fxs as [ xs | s pf ]; simpl.
 - (* fxs = pure xs *) induction xs as [ | fx fxs IH ]; simpl.
   + (* xs = nil *) reflexivity.
   + (* xs = cons fx fxs; induction hypothesis IH *)
     do 2 f_equal. destruct IH as [ xs H | s' pf' ]; simpl.
     * (* fxs = pure xs *) rewrite H. reflexivity.
     * (* fxs = impure s' pf' *)
       do 2 f_equal. extensionality p. destruct p.
  - (* fxs = impure s pf *)
    do 2 f_equal. extensionality p. destruct p
Qed.
\end{coqcode}

We observe that for both cases of \cinl{impure}\--values, we do not have a contradiction in place as we had in the total setting.
The contradiction in the total setting was introduced by the shape of the container that did not have any constructors.
Now, we are working with \cinl{One!$_\text{S}$!}, which is a type synonym for the \cinl{unit} type and has exactly one constructor, namely \cinl{tt}.
We can, however, prove the \cinl{impure}\--cases using \cinl{destruct} again, but we need to have a position as an assumption.
The position is introduced as assumption when we strip away the prefix of \cinl{impure s' pf'} on both sides of the equation such that only the position function \cinl{pf} remain to be proven equivalent.

The initial situation for the first \cinl{impure}\--case looks as follows.

\begin{alltt}
  ...
  s' : One\(\sb{\text{S}}\)
  ============================
  impure s' (fun p => ...) =
  impure s' (fun p => ...)
\end{alltt}

As mentioned above, after stripping away the prefix both expressions have in common, we end up with two functions that we need to prove equal.
We introduce the function argument \cinl{p} using \cinl{extensionality p} and end up with \cinl{p : One!$_\text{P}$! s'} added to the assumptions and a changed goal as follows.

\begin{alltt}
  s' : One\(\sb{\text{S}}\)
  p : One\(\sb{\text{P}}\) s'
  ============================
  pf' p >>= (fun zs => append' zs (append fys fzs)) =
  pf' p >>= (fun zs => append (append' zs fys) fzs)
\end{alltt}

Since \cinl{One!$_\text{P}$! s'} is a type synonym for \cinl{Empty}, the position \cinl{p} has no constructors and we can finish the proof using \cinl{destruct p}, again.
We follow the same approach to prove the second \cinl{impure}\--case.

\subsubsection{Generic Effect}
Last but not least, we take a look at a generic proof for the associativity of append. Instead of introducing components of a concrete container, the shape \cinl{Sh} and position function \cinl{Pos} are universally quantified.

\begin{coqcode}
Lemma append_assoc_generic :
  !$\forall$! (Sh : Type) (Pos : Sh -> Type) (A : Type)
    (fxs fys fzs : Free Sh Pos (List Sh Pos A)),
    append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
intros Sh Pos A fxs fys fzs.
\end{coqcode}

The main difference to the concrete proofs above is that in case of a generic effect, we cannot hope to have a false assumption, like a value of type \cinl{Empty}, in place to easily prove the \cinl{impure}\--cases.
Considering a generic effect has the consequence that we need to consider all possible instantiations.
In particular, using the effect in combination with \cinl{Free} might lead to a recursive occurrence, that is, the effect might have a polymorphic argument.

By means of proving the proposition, this observation leads to the consequence that a simple case distinction over the \cinl{Free}\--value \cinl{fxs} is not enough, we need to proceed by induction over \cinl{fxs}.

\begin{coqcode}
 induction fxs as [ xs | s pf IH ]; simpl.
 - (* fxs = pure xs *) induction xs as [ | fx fxs IH ]; simpl.
   + (* xs = nil *) reflexivity.
   + (* xs = cons fx fxs *) do 2 f_equal.
     induction IH as [ xs H | s pf _ IH' ]; simpl.
     * (* fxs = pure xs *) rewrite H. reflexivity.
     * (* fxs = impure s pf *) do 2 f_equal. extensionality p.
       apply IH'.
\end{coqcode}

The \cinl{pure}\--case stays basically the same, the difference, once again, lies in the nested \cinl{impure}\--case.

\begin{alltt}
  ...
  s : Sh
  IH' : \(\forall\) p : Pos s,
        pf p >>= (fun zs => append' zs (append fys fzs)) =
        pf p >>= (fun zs => append' zs fys) >>= (fun zs => append' zs fzs)
  p : Pos s
  ============================
  pf p >>= (fun zs => append' zs (append fys fzs)) =
  pf p >>= (fun zs => append' zs fys) >>= (fun zs => append' zs fzs)
\end{alltt}

Here, we cannot prove the subgoal by contradiction but need to actually use the induction hypothesis \cinl{IH'} generated by \cinl{induction IH}.

A similar situation appears for the second \cinl{impure}\--case that originated from the initial induction on \cinl{fxs}.
\begin{alltt}
  IH : \(\forall\) p : Pos s,
       append (pf p) (append fys fzs) = append (append (pf p) fys) fzs
  ============================
  impure s (fun p : Pos s => append (pf p) (append fys fzs)) =
  impure s (fun p : Pos s => append (append (pf p) fys) fzs)
\end{alltt}

In this case, the induction hypothesis is directly applicable when proving the functions equal.
This last subgoal then finishes the proof.

\begin{coqcode}
 - (* fxs = impure s pf *) do 2 f_equal. extensionality p.
   apply IH.
Qed.
\end{coqcode}

\subsubsection{The Generic Proof Owns them All}

Here comes the best part about the generic proof: the generic proof is applicable to the total and partial setting as well.
That is, instead of proving the proposition for all concrete effects again and again, as necessary in the approach introduced by \citet{abel2005verifying}, we prove the proposition once and for all.

Of course, if we want to prove a property in a concrete setting, we can still reuse the generic propositions as the following alternative proofs for the concrete settings of totality and partiality illustrate.

\begin{coqcode}
Lemma append_assoc_total' :
 !$\forall$! (A : Type) (fxs fys fzs : Free Zero!$_\text{S}$! Zero!$_\text{P}$! (List Zero!$_\text{S}$! Zero!$_\text{P}$! A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 apply append_assoc_generic.
Qed.

Lemma append_assoc_partial' :
 !$\forall$! (A : Type) (fxs fys fzs : Free One!$_\text{S}$! One!$_\text{P}$! (List One!$_\text{S}$! One!$_\text{P}$! A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 apply append_assoc_generic.
Qed.
\end{coqcode}

\subsection{Induction Principle for Free and List}

Recall that the \cinl{induction} tactic we use in proofs makes use of the associated induction principle for the corresponding type.
We discussed that an induction principle is an ordinary function of type \cinl{Prop} using the example of Coq's predefined list data type in \autoref{subsub:induction}.
Since our proofs depend on induction on values of type \cinl{Free}, we now consider the corresponding induction principle that Coq generates.

\begin{coqcode}
Free_ind : !$\forall$! (Sh : Type) (Pos : Sh -> Type) (A : Type) (P : Free A -> Prop),
   (!$\forall$! (x : A), P (pure x)) ->
   (!$\forall$! (s : Sh) (pf : Pos s -> Free A),
     (!$\forall$! p : Pos s, P (pf p)) -> P (impure s pf)) ->
   !$\forall$! (fx : Free A), P fx
\end{coqcode}

For the base case we need to show that a given predicate \cinl{P} holds for \cinl{pure x} for all \cinl{x} of appropriate type.
The \cinl{impure} case is a bit more interesting: given a shape \cinl{s} and a position function \cinl{pf}, we need to prove that the predicate holds for \cinl{impure s pf} with an additional induction hypothesis in place.
The hypothesis states that, for all possible positions \cinl{p}, the predicate already holds for all recursive values that we can access using the position function \cinl{pf}.
Note that these arguments correspond to the variables introduced in the patterns when using the \cinl{induction} tactic.
For example, the code above used the tactic using an introduction pattern as follows.

\begin{coqcode}
induction fxs as [ xs | s pf IH ].
\end{coqcode}

The variable \cinl{xs} in the left branch of the introduction pattern corresponds to the pure value, while \cinl{s} \cinl{pf} are the arguments of the \cinl{impure} constructor and \cinl{IH} is the generated induction hypothesis.

In case of data types that contain arguments of type \cinl{Free} due to the lifting of the constructors, the induction principle generated by Coq is not strong enough to fulfil its purpose.
Consider, for example, the induction principle Coq generates for the \cinl{List} data type defined in \autoref{subsec:freeAndContainers}.

\begin{coqcode}
List_ind : !$\forall$! (Sh : Type) (Pos : Sh -> Type) (A : Type)
      (P : List A -> Prop),
      P nil ->
      (!$\forall$! (fx : Free A) (fxs : Free (List A)), P (cons fx fxs)) ->
      !$\forall$! l : List Pos A, P l
\end{coqcode}

While the base case for \cinl{nil} looks fine, the generated function for the \cinl{cons} constructor looks a bit odd.
More precisely, the second function misses an induction hypothesis for the list \cinl{fxs}.
Without such a hypothesis at hand, there are not many propositions that we would be able to prove.
Fortunately, we can define a custom induction principle for \cinl{List} and other data types that we might define.
Since an induction principle is an ordinary proposition, that is, a function of type \cinl{Prop}, we just need to implement a function of the right type.
By enabling an option\footnote{\cinl{Unset Elimination Schemes.}}, we deactivate the automatic generation and define the custom induction principle named \cinl{List_ind}.
That way, we can use \cinl{induction} as we are used to.

First of all, we declare the types and the functions we want to use in the induction principle.
The keyword \cinl{Hypothesis} is commonly used for proposition functions in custom induction principles instead of using the keyword \cinl{Variable}; both keywords fulfil the same purpose though.

\begin{coqcode}
Variable A : Type.
Variable P : List A -> Prop.

Hypothesis nilP : P nil.
Hypothesis consP : !$\forall$! fx fxs, ?IH -> P (cons fx fxs).
\end{coqcode}

In order to specify the missing induction hypothesis in case of \cinl{cons} (that we currently named \cinl{?IH}), we need to work out how this hypothesis looks like in the lifted case.
When we consider ordinary lists, we require that the predicate holds for a list \cinl{fxs} in order to prove that it also holds for the list \cinl{cons fx fxs} for an arbitrary \cinl{fx} of appropriate type as well.
In case of a lifted list, the predicate is supposed to hold for all
pure and effectful lists.
The needed property is similar to stating that a predicate of type \cinl{A -> Prop} should hold for all elements of a list\--like structure.
In our case the list\--like structure is the \cinl{Free} wrapper with its two constructors \cinl{pure} and \cinl{impure}.
We define an auxiliary proposition \cinl{ForFree} that states if a predicate of type \cinl{A -> Prop} holds for all elements occurring in a value wrapped using \cinl{Free}.
Rememner that propositions in Coq are data type declarations that yield a value of type `Prop` instead of `Type`.

\begin{coqcode}
Inductive ForFree (P : A -> Prop) : Free A -> Prop :=
| forPure   : !$\forall$! x, P x -> ForFree P (pure x)
| forImpure : !$\forall$! s pf, (!$\forall$! p, ForFree P (pf p)) -> ForFree P (impure s pf).
\end{coqcode}

In case of \cinl{pure x} we can directly apply the predicate to the element \cinl{x}.
The \cinl{impure} constructor, on the other hand, embeds values of type \cinl{Free A}.
Thus, we can apply the proposition \cinl{ForFree} recursively.
We access the values of type \cinl{Free A} by applying the position function to all valid positions with respect to the used container.
That is, the predicate holds for \cinl{impure s pf} if \cinl{ForFree P} already holds for all elements that can be accessed using the position function.

Now we use the proposition \cinl{ForFree} to redeclare the necessary induction hypothesis in case of the \cinl{cons} constructor.

\begin{coqcode}
Hypothesis consP : !$\forall$! fx fxs, ForFree P fxs -> P (cons fx fxs).
\end{coqcode}

Note that the predicate \cinl{P} is of type \cinl{List A -> Prop}, that is, it is a predicate on lists.
Based on these hypotheses, we define our custom induction principle by implementing a function with the following type signature.

\begin{coqcode}
Fixpoint List_ind (xs : List A) : P xs.
\end{coqcode}

\noindent%
The above declaration corresponds to a \cinl{Lemma}\--statement, that is, we can define the function like proofs using tactics.
Due to the declared hypothesis, the goal and associated assumptions look as follows.

\begin{alltt}
  A : Type
  P : List A -> Prop
  nilP : P nil
  consP : \(\forall\) fx fxs, ForFree P fxs -> P (cons fx fxs)
  List_ind : \(\forall\) xs : List A, P xs
  xs : List A
  ============================
  P xs
\end{alltt}

\noindent Since the function is recursive, \cinl{List_ind} itself appears as an assumption as well.

In order to show that the predicate \cinl{P} holds for the list \cinl{xs}, we make a case distinction that leads to the following two subgoals.

\begin{cproof2}{destruct xs as [ | fy fys ].}{0.7}

  ...
  nilP : P nil
  ============================
  P nil

  ...
  consP : \(\forall\) fx fxs, ForFree P fxs -> P (cons fx fxs)
  List_ind : \(\forall\) xs : List A, P xs
  fy : Free A
  fys : Free  (List A)
  ============================
  P (cons fy fys)
\end{cproof2}

\noindent We finish the first subgoal by applying the hypothesis \cinl{nilP}; for the second goal we proceed by applying the hypothesis \cinl{consP}.
The new subgoal is the precondition of the hypothesis \cinl{consP} instantiated with \cinl{fy} and \cinl{fys} for the quantified variables \cinl{fx} and \cinl{fxs}, namely \cinl{ForFree P fys}.
We proceed by induction on \cinl{fys} since the proposition \cinl{ForFree} is an inductively defined proposition with constructors in case of \cinl{pure} and \cinl{impure} values.

\begin{cproof1}{induction fys as [ ys | s pf IH ].}{0.46}{0.51}
  ...
  List_ind : \(\forall\) xs : List A, P xs
  ys : List A
  ============================
  ForFree P (pure ys)

  ...
  IH : \(\forall\) (p : Pos s), ForFree P (pf p)
  ============================
  ForFree P (impure s pf)
\end{cproof1}

In both cases we apply the corresponding constructor of the proposition \cinl{ForFree}, namely, \cinl{forPure} and \cinl{forImpure}.

\begin{alltt}
  ...
  List_ind : \(\forall\) xs : List A, P xs
  ============================
  P ys

  ...
  IH : \(\forall\) (p : Pos s), ForFree P (pf p)
  ============================
  \(\forall\) p : Pos s, ForFree P (pf p)
\end{alltt}

We finish both subgoals by simply applying the appropriate assumption.
In the first case we apply the recursive function \cinl{List_ind} that we are currently defining.
For the \cinl{impure}\--case we use the induction hypothesis generated for \cinl{Free}.
The complete proof script is finalised by using \cinl{Defined} and looks as follows.

\begin{coqcode}
Fixpoint List_ind (xs : List Sh Pos A) : P xs.
 destruct xs as [ | fy fys ].
 - apply nilP.
 - apply consP.
   induction fys as [ ys | s pf IH ].
   + apply forPure.
     apply List_ind.
   + apply forImpure.
     apply IH.
Defined.
\end{coqcode}

Note that the difference between \cinl{Defined} and \cinl{Qed} to finalise a proof influences the visibility (in context of Coq often called \emph{opacity}) of the associated function.
The difference is rather technical; for here, it is sufficient to know that Coq can unfold definitions that are marked using \cinl{Defined}, while a definition marked with \cinl{Qed} prevents unfolding.

As alternative to the proof\--mode version, we can, of course, implement the induction principle as function definition directly.
In that case, instead of using induction on \cinl{Free}, we need a recursive helper function \cinl{free_ind} to work as induction hypothesis in case of \cinl{impure} values.

\begin{coqcode}
Fixpoint List_ind (xs : List A) : P xs :=
 match xs with
 | nil         => nilP
 | cons fy fys =>
   consP fy (let fix free_ind (fxs : Free (List A)) : ForFree P fxs :=
                 match fxs with
                 | pure xs => forPure P xs (List_ind xs)
                 | impure s pf => forImpure (fun p => free_ind (pf p))
                 end in free_ind fys)
 end.
\end{coqcode}

Note that the preceding sections used this definition of \cinl{List_ind} whenever we used the tactic \cinl{induction} on list
values.
Hence, the arguments in an introduction pattern like \cinl{[ | fy fys IH ]} correspond to the arguments of the \cinl{cons} constructor and the induction hypothesis of type \cinl{ForFree}.

\section{First Ideas to Model Curry Programs}

In this section we want to take a look at how to model non\--strict non\--determinism, motivated by the functional logic programming language Curry.
As we have seen in previous chapters, Curry combines the functional programming paradigm with concepts known from logic programming.
More precisely, Curry combines non\--determinism and laziness; the latter is introduced by shared variables via let\--bindings.
This combination leads to a call\--time choice semantics.
The approach we illustrated in the first sections enables reasoning about non\--strict functional programs.
The difference that we want to illuminate in this section is that sharing expressions via let\--bindings in a model of Haskell with \hinl{undefined} values is an optimisation only but cannot be observed by the programmer.
In Curry, on the other side, we can observe the difference between sharing a non\--deterministic computation that is evaluated once and duplicating non\--deterministic computations due to Curry's call\--time choice semantics.

Before we dive deep into the problems when modelling call\--time choice, we first implement Curry's non\--determinism effect using \cinl{Free}.
Based on this implementation, we discuss why the model cannot express call\--time choice and give an outlook on ideas to implement the intended semantics.
There are two aspects we want to emphasise here.

First, the outlook we give on modelling call\--time choice can be used to incorporate sharing for other effects as well.
For instance, a common extension of Haskell is the function \hinl{trace} that enables to track information of type \hinl{String} while evaluating a program.
The effect of tracing results in an observable difference between sharing and duplicating an effectful expression.
Hence, we need a similar technique to model call\--time choice semantics as well as for more involved effects than we have seen so far.

Second, the ideas about how to model sharing are still work\--in\--progress.
That is, we illustrate the motivation only and then reference related work that tackles similar problems and that we think is applicable for our problem.

\subsection{Non\--Determinism as Effect}

We discussed how to model totality and partiality using \cinl{Free} in \hyperref[subsub:totality_container]{\autoref{subsub:totality_container} (a)} and \hyperref[subsub:partiality_container]{\autoref{subsub:partiality_container} (b)}, respectively.
In the same manner, we now take a look at how to model non\--determinism.
That is, we define a container representation and prove that this representation is isomorphic to a data structure that combines a pair\--structure with a nullary constructor.
With these definitions at hand, we define simple non\--deterministic functions and prove exemplary properties.

\subsubsection{Representing Non\--determinism using Containers}
\label{subsubsec:nondetContainter}

In Curry the built\--in non\--determinism effect comes with two primitives: a polymorphic value \hinl{failed :: a} to represent finite failures as known from logic programming as well as the operator \hinl{(?) :: a -> a -> a} to construct a non\--deterministic choice between two expressions.
That is, we define the functor representing the non\--determinism effect using two constructors as follows. 

\begin{coqcode}
Inductive ND (A : Type) :=
| choice : A -> A -> ND A
| failed : ND A.
\end{coqcode}

In order to transfer this functor to its isomorphic container representation, we need to define the shape and position type function involved.
As we have two constructors to represent, we could simply use \cinl{bool} as the type for shapes.
In order to increase the readability of the resulting code, we use a custom data type with two constructors instead.

\begin{coqcode}
Inductive ND!$_\text{S}$! :=
| ch : ND!$_\text{S}$!
| fd : ND!$_\text{S}$!.
\end{coqcode}

In contrast to definitions of position type functions we have seen before, due to the two different shapes, we have to take the shape into account to determine the final position type.
That is, for the first time the dependently typed position type function actually depends on the given shape.
There are no positions to access in case of the \cinl{failed} constructor and two possible positions --- the left or right argument --- in case of \cinl{choice}.
Hence, we use types with zero and two values as position types: \cinl{Empty} and \cinl{bool}, respectively.

\begin{coqcode}
Definition ND!$_\text{P}$! (s : ND!$_\text{S}$!) :=
 match s with
 | fl => Empty
 | ch => bool
 end.
\end{coqcode}

As preparation to show that the constructed container is indeed isomorphic to the introduced functor, we define functions to transform values from one type to the other and vice versa.

\begin{coqcode}
Definition from_ND A (nd : ND A) : Ext ND!$_\text{S}$! ND!$_\text{P}$! A :=
 match nd with
 | choice x y => ext ch (fun (p : ND!$_\text{P}$! ch) => if p then x else y)
 | failed     => ext fl (fun (p : ND!$_\text{P}$! fl) => match p with end)
 end.

Definition to_ND A (e : Ext ND!$_\text{S}$! ND!$_\text{P}$! A) : ND A :=
 match e with
 | ext ch pf => choice (pf true) (pf false)
 | ext fl pf => failed
 end.
\end{coqcode}

Since the code corresponding to \cinl{failed} resembles the implementation we have seen for \cinl{One} before, the interesting part in both definitions is the case of \cinl{choice}.
In the definition of \cinl{from_ND} we decide between the left argument \cinl{x} and right argument \cinl{y} depending on the given position \cinl{p} that is of type \cinl{bool}.
We then implement \cinl{to_ND} such that it complies with its counterpart \cinl{from_ND}, that is, we access the left argument using \cinl{true} and the right argument using \cinl{false}.

These definitions indeed form an isomorphism; since we have already seen quite a few of these proofs, we refrain from showing the whole
proof script here but provide the definition in \appref{subsec:appendix:nondet}.

\begin{coqcode}
Lemma from_to_ND : !$\forall$! (A : Type) (e : Ext ND!$_\text{S}$! ND!$_\text{P}$! A),
   from_ND (to_ND e) = e.

Lemma to_from_ND : !$\forall$! (A : Type) (nd : ND A),
   to_ND (from_ND nd) = nd.
\end{coqcode}

\subsubsection{Proving Properties About Non\--deterministic Functions}
\label{subsubsec:nondetProving}

In the following sections the suffix \cinl{ND} for types is used as synonym for the concrete instantiation of data types with the non\--determinism effect, e.g., \cinl{FreeND = Free ND!$_\text{S}$! ND!$_\text{P}$!} and \cinl{ListND = List ND!$_\text{S}$! ND!$_\text{P}$!}.

We define the following primitives \cinl{Failed} and \cinl{Choice} to construct values introduced by the non\--determinism effect; we use the operator \cinl{?} as notation for the latter primitive.
Furthermore, most of the following lemmas are stated without the corresponding proof script.
We provide these missing proofs scripts in \appref{subsec:appendix:proving}.

\begin{coqcode}
Definition Failed (A : Type) : FreeND A :=
  impure fl (fun (p : ND!$_\text{P}$! fl) => match p with end).
Definition Choice (A : Type) (fx : FreeND A) (fy : FreeND A) :=
  impure ch (fun (p : ND!$_\text{P}$! ch) => if p then fx else fy).
\end{coqcode}

\paragraph{First Example}
\label{par:firstNDExample}
For our first example we work on a non\--deterministic (positive) number that is the choice between \cinl{1} and \cinl{2}.
Note that we work with (positive) numbers as representatives for \hinl{Int} values in Curry, that is, these numbers are primitive and only need to be lifted at the top\--level constructor.
Thus, we reuse Coq's type for Peano numbers \cinl{nat} to model positive numbers.

\begin{coqcode}
Definition oneOrTwo : FreeND nat :=
  pure 1 ? pure 2.
\end{coqcode}

We define the following function \cinl{even} for arbitrary effects based on predefined Coq functions for \cinl{nat} values.

\begin{coqcode}
Definition even (fn : Free nat) : Free bool :=
  liftM1 Nat.even fn.

Definition liftM1 A R (f : A -> R) (x : Free A) : Free R :=
  x >>= fun x' => pure (f x').
\end{coqcode}

Here, the auxiliary function \cinl{liftM1} is used to lift primitive functions --- like the \cinl{even} function on Peano numbers.
We will additionally use the notations \cinl{TTrue} and \cinl{FFalse}, respectively, for lifted Boolean values to distinguish them more comfortably from Coq's predefined Boolean values.

Now we are ready for some simple propositions about the defined functions: we prove that doubling the non\--deterministic computation \cinl{oneOrTwo} non\--deterministically and checking if the value is even yields \cinl{TTrue} twice.
That is, doubling the value \cinl{oneOrTwo} is always even.

\begin{coqcode}
Lemma even_oneOrTwo : even (liftM2 mult oneOrTwo (pure 2)) = TTrue ? TTrue.
\end{coqcode}

As an alternative formulation of this proposition, we can reuse \cinl{ForFree} to define the proposition \cinl{AllND} to check a given predicate for all values of a non\--deterministic computation.

\begin{coqcode}
Definition AllND (A : Type) (P : FreeND A -> Prop) (fx : FreeND A) : Prop :=
  ForFree (fun x => P (pure x)) fx.
\end{coqcode}

Given the definition \cinl{AllND}, we can simplify the statement above using a suitable proposition instead of reconstructing all non\--deterministic choices on the right\--hand side manually.

\begin{coqcode}
Lemma even_oneOrTwo_allND :
  AllND (fun fb => fb = TTrue) (even (liftM2 mult oneOrTwo (pure 2))).
\end{coqcode}

Note that this alternative definition is more general than the one above: here we say that all results are even, whereas the lemma \cinl{even_oneOrTwo} states that there are exactly two results, which are both even.

\paragraph{Second Example}
For the second example we consider the function \cinl{inc}.

\begin{coqcode}
Definition inc (fn : Free nat) : Free nat :=
  liftM1 (fun n => S n) fn.
\end{coqcode}

We prove that applying the function \cinl{inc} to a non\--deterministic choice between two values is equivalent to applying the function to both sides of the choice.

\begin{coqcode}
Lemma pulltab_inc : !$\forall$! (fx fy : FreeND nat),
  inc (fx ? fy) = inc fx ? inc fy.
\end{coqcode}

We can generalise this property of Curry's evaluation, often referred to as \emph{pull\--tabbing}, for any strict function.\footnote{In a setting with arbitrary effects, \citet{filinski2007inductive} call Curry's strictness property we describe here rigid.}
The strictness property states that applying the function to an argument is equivalent to evaluating its argument to head normal form first and applying the function to the pure value.

\begin{coqcode}
Lemma pulltab_if_strict : !$\forall$! (A B : Type)
  (f : FreeND A -> FreeND B) (fx fy : FreeND A)
  (Hstrict : !$\forall$! fz, f fz = fz >>= fun z => f (pure z)),
   f (fx ? fy) = f fx ? f fy.
\end{coqcode}

\paragraph{Third Example}
The third example considers not only a non\--deterministic computation but a non\--deterministic function.
We reimplement the function \cyinl{insert}, which non\--deterministically inserts a value at each position of a list, that we introduced in \autoref{code:ndInsert}.

\begin{coqcode}
Fixpoint ndInsert' (A : Type) (fx : FreeND A) (xs : ListND A)
 : FreeND (ListND A) :=
 match xs with
 | nil         => Cons fx Nil
 | cons fy fys => Cons fx (Cons fy fys)
                ? Cons fy (fys >>= fun ys => ndInsert' fx ys)
 end.

Definition ndInsert (A : Type) (fx : FreeND A) (fxs : FreeND (ListND A))
 : FreeND (ListND A) :=
 fxs >>= fun xs => ndInsert' fx xs.
\end{coqcode}

Note, that due to the recursive structure of the function, we need to split the definition into two parts as already described in \autoref{subsec:partial} and \autoref{subsec:liftedFunctions}.

The property we want to define about \cinl{ndInsert} states that for each resulting list, the length of the list increases by one in contrast to the original list.
The definition for \cinl{length} is defined as follows for an arbitrary effect.

\begin{coqcode}
Fixpoint length' (A : Type) (xs : List' A) : Free nat :=
  match xs with
  | nil        => pure 0
  | cons _ fxs => inc (fxs >>= fun xs => length' xs)
  end.

Definition length (A : Type) (fxs : Free (List A)) : Free nat :=
  fxs >>= fun xs => length' xs.
\end{coqcode}
  
More precisely, the property we define is more specific, as we do not universally quantify over the list argument, but show it for a concrete list only.

\begin{coqcode}
Lemma ndInsert_inc :
  AllND (fun fxs => length fxs = pure 3)
        (ndInsert (pure 1) (Cons (pure 2) (Cons (pure 3) Nil))).
\end{coqcode}

Let us take a more detailed look at this example, as a first naive try to prove the property fails.
After simplifying the expression, that is, evaluating the expression
\begin{coqcode}
  ndInsert (pure 1) (Cons (pure 2) (Cons (pure 3) Nil))
\end{coqcode}
the goal looks as follows.

\begin{cproof1}{simpl.}{0.1}{0.83}
  ============================
  AllND (fun fxs => length fxs = pure 3)
        (Cons (pure 1) (Cons (pure 2) (Cons (pure 3) Nil))
        ? Cons (pure 2) (Cons (pure 1) (Cons (pure 3) Nil)
                        ? Cons (pure 3) (Cons (pure 1) Nil)))
\end{cproof1}

As \cinl{AllND} is defined via \cinl{ForFree}, we can use the second rule of the proposition to process the goal.
Based on the decision for the non\--deterministic choice, we get the first resulting list for the left branch and the recursive call for the right branch.
We make a case distinction on that decision to proceed, which results in two subgoals.

\begin{cproof2}{apply forImpure. intros p; destruct p.}{0.85}

  ============================
  ForFree (fun x => length' x = pure 3)
          (Cons (pure 1) (Cons (pure 2) (Cons (pure 3) Nil)))

  ForFree (fun x => length' x = pure 3)
          (Cons (pure 2) (Cons (pure 1) (Cons (pure 3) Nil)
                         ? Cons (pure 3) (Cons (pure 1) Nil)))
\end{cproof2}

For the first subgoal, we use the first rule of the \cinl{ForFree}\--proposition to handle the pure list constructor and then only need to show that the list has indeed \cinl{pure 3} elements.

\begin{coqcode}
  - apply forPure. reflexivity.
\end{coqcode}

In the second subgal the outermost constructor is the pure list constructor \cinl{Cons}, that is, we use the first rule of the \cinl{ForFree}\--proposition again to process the goal.

\begin{cproof2}{- apply forPure.}{0.85}

  ============================
  length (Cons (pure 2) (Cons (pure 1) (Cons (pure 3) Nil)
                        ? Cons (pure 3) (Cons (pure 1) Nil)))
  = pure 3
\end{cproof2}

When restructuring the left\--hand side of the goal, we can unroll the definition of \cinl{length} once\footnote{This unrolling is a simplified illustration for the reader and not exactly the expression that Coq yields when using the tactic \cinl{simpl} here. We can, however, define a lemma proving that this simplification is valid.}, yielding the following expression.

\begin{alltt}
  liftM1 S (length (Cons (pure 1) (Cons (pure 3) Nil)
                   ? Cons (pure 3) (Cons (pure 1) Nil)))
  = pure 3
\end{alltt}

Fortunately, we know from the preceding examples that a strict function applied to a non\--deterministic value performs a pull\--tab step.
That is, we can rewrite the above equation as follows.
Note that we prove the hypothesis about the strictness of the applied function \cinl{liftM1 (fun n => S n) . length} by induction on the argument of type \cinl{FreeND (ListND nat)}.

\begin{cproof2}{rewrite pulltab_f_strict with (f := fun fxs => inc (length fxs)); simpl.}{0.45}

  ============================
  pure 3 ? pure 3 = pure 3
\end{cproof2}

We finally realise that we have a non\--deterministic choice on the left\--hand side, while we have a pure value on the right\--hand side.
That is, we cannot prove this property.
The problem with the original property is that we disregarded that the non\--determinism introduced by the function \cinl{ndInsert} occurs nested in the list constructors.

We regain the correctness of the property we initially wanted to state by evaluating the resulting list to normal form, that is, pulling all nested occurrences of non\--deterministic choices to the top\--level.
Remember that in our setting the usage of the operator \cinl{>>=} mimics the evaluation to head normal form, that is, we can define the evaluation to normal form by traversing a given data structure and evaluating all constructor arguments to head normal form.
Here, we only present the definition for \cinl{ListND nat}, but the nature of the functions is more generic: we can use the same definition for arbitrary effects and arbitrary types.

\begin{coqcode}
Fixpoint nfList' (ns : ListND nat) : FreeND (ListND nat) :=
 match ns with
 | nil         => Nil
 | cons fn fns => fn >>= fun n' =>
                  (fns >>= nfList') >>= fun ns' =>
                  Cons (pure n') (pure ns')
 end.

Definition nfList (fns : FreeND (ListND nat)) : FreeND (ListND nat) :=
 fns >>= nfList'.
\end{coqcode}

Taking this idea one step further, we could define an overloaded function \cinl{nf} using a type class and implement instances for all translated data types.
Using the function \cinl{nfList}, we redefine the property by evaluating the list argument to normal form and finally succeed with the proof.

\begin{coqcode}
Lemma ndInsert_inc :
  AllND (fun fxs => length fxs = pure 3)
        (nfList (ndInsert (pure 1) (Cons (pure 1) (Cons (pure 2) Nil)))).
\end{coqcode}



\subsection{Sharing as Effect}
\label{subsec:sharingEffect}

The preceding examples illustrate how to model simple non\--deterministic values and functions as well as how to prove properties about them.
The model we use so far, however, is not a suitable model for Curry's call\--time choice semantics.
The difference between Curry's call\--time choice semantics and the non\--strict non\--determinism we are currently able to model can be generalised to the difference between call\--by\--name and call\--by\--need.
In the following, we first compare our example definition of doubling a number with an alternative version to exhibit the call\--by\--name behaviour of our model.
We discuss an ad\--hoc solution to mimic call\--by\--need for concrete examples and give an example that shows the limitations of that idea.
Secondly, we propose a combination of the underlying mechanism of the \emph{KiCS2} compiler with related work on algebraic effects with scoped operations to implement Curry's call\--time choice semantics.

We only provide proof scripts of the stated propositions if we highlight a specific problem and discuss a peculiarity, respectively.
Otherwise we refrain from showing the proof scripts here but provide the missing code in \appref{subsec:appendix:sharing}.

\subsubsection{Call\--by\--name vs. Call\--by\--need}
\label{subsubsec:cbneed}
 
Consider the following two implementations for doubling a number: the first version multiplies the given value by two and the second version uses addition instead.

\begin{coqcode}
Definition doubleMult (fx : Free nat) : Free nat :=
  liftM2 mult fx (pure 2).

Definition doublePlus (fx : Free nat) : Free nat :=
  liftM2 plus fx fx.
\end{coqcode}

As we know from the proof in \autoref{par:firstNDExample}, the check on evenness for doubling the non\--deterministic computation \cinl{oneOrTwo} yields \cinl{True} for both non\--deterministic branches.

\begin{coqcode}
Lemma even_doubleMult_Choice :
  even (doubleMult oneOrTwo) = TTrue ? TTrue.
\end{coqcode}

We can, however, not prove the same property for \cinl{doublePlus} as the expression yields four instead of two results.

\begin{coqcode}
Lemma even_doublePlus_Choice :
 even (doublePlus oneOrTwo) = TTrue ? TTrue.
Proof.
  simpl. f_equal. extensionality p.
  destruct p.
  - (* even (pure 1 + oneOrTwo) = TTrue *)
    simpl.
    (* even (pure 2) ? even (pure 3) = TTrue *)
    admit.
  - (* even (pure 2 + oneOrTwo) = TTrue *)
    simpl.
    (* even (pure 3) ? even (pure 4) = TTrue *)
    admit.
Abort.
\end{coqcode}

Using the tactic \cinl{admit} we give up a try to prove a subgoal and the keyword \cinl{Abort} marks that we give up on the whole proof of the lemma.
The comments highlight that the argument \cinl{oneOrTwo} is evaluated two times: once as first argument of the addition and once as the second one.
The two occurrences of the variable \cinl{fx} in the definition of \cinl{doublePlus} result in two individual evaluations.
That is, the expression is equivalent to the inlined version using addition directly on two individual calls to the non\--deterministic computation \cinl{oneOrTwo}.

\begin{coqcode}
Lemma doublePlus_inline :
  doublePlus oneOrTwo = liftM2 plus oneOrTwo oneOrTwo.
\end{coqcode}

\noindent Applying the predicate \cinl{even} to this computation then yields four results, which we illustrate with the second proof.

\begin{coqcode}
Lemma even_doublePlus_Choice :
  even (doublePlus oneOrTwo) = (TTrue ? FFalse) ? (FFalse ? TTrue).
\end{coqcode}

Note, that the expression \cinl{doubleMult oneOrTwo} introduces just one level of non\--determinism and is, thus, equivalent to \cinl{pure 2 ? pure 4}.

\begin{coqcode}
Lemma doubleMult_inline :
  doubleMult oneOrTwo = pure 2 ? pure 4.
\end{coqcode}

Hence, the unwanted behaviour origins from duplicating non\--deterministic expressions: in the definition of \cinl{doublePlus}, we use the argument \cinl{fx} two times on the right\--hand side of the definition.
Note that the same unwanted behaviour when using \cinl{doublePlus} cannot be observed when applying the function to the value \cinl{Failed}.

\begin{coqcode}
Lemma even_doublePlus_Failed :
  even (doubleMult Failed) = Failed.
\end{coqcode}

We observe here that the difference between call\--by\--name and call\--by\--need --- that is, between sharing a value or duplicating its evaluation --- cannot be observed for effects like partiality --- as mimicked using \cinl{Failed} --- but becomes observable for an effect like non\--determinism.

\subsubsection{An Ad\--hoc Solution}
\label{subsubsec:adhoc}

In order to regain the property that we want to prove, we need to evaluate a shared non\--deterministic computation once and use the pure value of that computation for all occurrences in the expression.

We can mimic this behaviour with the following redefinition of \cinl{doublePlus}.

\begin{coqcode}
Definition doubleSharePos (fn : FreeND nat) : FreeND nat :=
  match fn with
  | pure _      => liftM2 plus fn fn
  | impure s pf => impure s (fun p => doublePlus (pf p))
 end.
\end{coqcode}

If the argument \cinl{fn} is already a pure number, we apply the function \cinl{plus} directly.
In case of an impure value, we reconstruct the constructor of the observed effect --- by using the same shape \cinl{s} --- and then apply \cinl{doublePlus} on all values the position function \cinl{pf} yields for the given position \cinl{p}.
Using this alternative definition with explicit sharing of the argument \cinl{fn}, we can prove the wanted property.

\begin{coqcode}
Lemma even_doubleSharePos_Choice :
  even (doubleSharePos oneOrTwo) = TTrue ? TTrue.
\end{coqcode}

Since it is inconvenient to handle sharing of the argument \cinl{fn} by using explicit pattern matching on the \cinl{Free}\--structure, we introduce an auxiliary function for explicit sharing.

\begin{coqcode}
Definition shareStrict (A : Type) (fx : Free A) : Free (Free A) :=
  match fx with
  | pure x      => pure (pure x)
  | impure s pf => impure s (fun p => pure (pf p))
  end.
\end{coqcode}

Note that we define this explicit sharing function for an arbitrary effect, we do not need to know about the possible shapes that we are reconstructing on the right\--hand side.
In order to define this functionality in a separate function, we yield a nested value, that is, a value of type \cinl{Free (Free A)}.
The inner layer of \cinl{Free} represents the shared computation while the outer layer is a reconstruction of the effect occurring in the argument \cinl{fx} that we want to share.

We implement an additional version of \cinl{doublePlus} using the explicit sharing function and prove that our running example for the property holds as well.

\begin{coqcode}
Definition doubleShare (fn : FreeND nat) : FreeND nat :=
  shareStrict fn >>= fun fn' => doublePlus fn'.

Lemma even_doubleShare_Choice :
  even (doubleShare oneOrTwo) = TTrue ? TTrue.
\end{coqcode}

Note that the naming of the explicit sharing function was not picked by chance: the above usage for the definition of \cinl{doublePlus} only works as expected, because \cinl{doublePlus} is strict in its argument.
That is, we can only use \cinl{shareStrict} if we are sure that the computation that we are sharing needs to be evaluated anyway.
Otherwise we might trigger a non\--deterministic computation or a partial value that was not needed in the first place.
In order to construct an example that shows the limitations of the explicit sharing function we consider a nested application of the effect\--generic function \cinl{const} that takes two arguments, ignores its latter one and yields the former.

\begin{coqcode}
Definition const (A B : Type) (fx : Free A) (fy : Free B) : Free A :=
  fx.
\end{coqcode}

The following lemma shows a nested usage of the function \cinl{const} on an arbitrary expression as first argument and passing a shared non\--deterministic computation as second and third argument.
The expected property is that this nested application is equivalent to yielding just the first argument.

\begin{coqcode}
Lemma share_with_const : !$\forall$! (A : Type) (fx : FreeND A),
   shareStrict oneOrTwo >>= fun fy' => const (const fx fy') fy' = fx.
Proof.
  intros A fx.
  simpl.
  (*   const (const fx (pure 1)) (pure 1)
     ? const (const fx (pure 2)) (pure 2) = fx *)
  admit.
Abort.
\end{coqcode}

However, when using \cinl{shareStrict} the left\--hand side of the equality is --- as the name of the function already suggests --- too strict.
When we use \cinl{shareStrict} on an expression that does not need to be evaluated --- here \cinl{const} yields its first argument and ignores the second one --- the usage results in an unwanted behaviour in case of an effectful computation.
That is, the above example application triggers the non\--deterministic computation \cinl{oneOrTwo} and, thus, yields its first argument \cinl{fx} twice.

\begin{coqcode}
Lemma share_with_const : !$\forall$! (A : Type) (fx : FreeND A),
  shareStrict oneOrTwo >>= fun fy' => const (const fx fy') fy' = fx ? fx.
\end{coqcode}

At the end, although we can use the explicit sharing function \cinl{shareStrict} to mimic the sharing behaviour of Curry for some concrete examples, the usage is limited to situations that demand the evaluation of the shared expression anyway.
In order to enable a more generic version of the explicit sharing function that does not rely on the demand of the shared expression, a more sophisticated underlying model is required.

\subsubsection{Free Monads with Scope}

A promising approach to model Curry's call\--time choice semantics is to use scoped operations as discussed by \citet{wu2014effect} and \citet{pirog2018syntax}.
More precisely, \citeauthor{wu2014effect} present two approaches for implementations in Haskell: (a) using explicit primitives to mark the beginning and the end of a scoped expression; (b) adapting the free monad construction by replacing the underlying functor with a higher\--order functor.
The higher\--order functor is a type constructor that takes a functor as argument, i.e., is of kind \hinl{(* -> *) -> * -> *}.
The former approach leads to an administrative overhead to keep track of well\--balanced begin and end tags and the problem that the construction of an unbalanced program is possible in the first place.
The usage is more convenient in the latter approach since the sharing primitive explicitly takes the scoped expression explicitly as its argument.
On the other hand, \citeauthor{pirog2018syntax} derive a representation of scoped effects using category theory.
They also give a Haskell implementation for their representation of the free monad with scoped effects by adding an additional constructor \hinl{Scope}.

\begin{haskellcode}
data Prog f g a = Return a
                | Op (f (Prog f g a))
                | Scope (g (Prog f g (Prog f g a)))
\end{haskellcode}

Note that the resulting data type \hinl{Prog} is parametrised over an additional type constructor \hinl{g}.
This type constructor is the functor for the effect with scope --- the type constructor \hinl{f} is still used for the effects, like partiality or non\--determinism, that we have seen so far.
The nested structure of the \hinl{Scope} constructor enables the separation of \emph{ordinary} and scoped effects: the inner \hinl{Prog} layer is not affected when using \hinl{(>>=)} to transform the structure.

\begin{figure}[tb]
 \centering
\begin{Verbatim}[numbers=left, xleftmargin=5mm]
                                     < Share_1
                                         |
                                         ? >
                                   /            \
                                  ?             ...
                           /            \
                      < Share_1     < Share_1
                          |              |
                          ? >            ? >
                       /     \        /     \
                      ?       ?      ?       ?
                     / \     / \    / \     / \
                    4   5   5   6  5   6   6   7
\end{Verbatim}
\caption{The decision tree representation of the expression \cyinl{example} in the simple Coq model with sharing nodes adapted with explicit begin (\texttt{<}) and end (\texttt{>}) markers}
\label{fig:searchTreeScope}
\end{figure}

In order to illustrate how a scoped effect can help in case of Curry's call\--time choice semantics, \autoref{fig:searchTreeScope} shows an adapted version of the decision tree representation for the following Curry expression.

\begin{curry}
example :: Int
example = let x = 1 ? 2 in (x + (1 ? 2)) + (x + (1 ? 2))  
\end{curry}

More precisely, the illustration enhances the decision tree representation using explicit markers.
Due to the explicit markers, we can number the \texttt{?}\--edges corresponding to the given label of the \texttt{Share}\--edges.
That is, the choices in line number $5$ and $11$ are not affected by the sharing effect and do not get any number.
Note that a numbering that affects only the choices within the markers corresponds to the tree representation when evaluating the example expression in Curry.

\section{Related Work}

In this section we present and discuss related and future work concerning formal reasoning about functional programs with effects.
We classify the related work using three categories: work on modelling algebraic effects in general, but especially using free monads; modelling and reasoning techniques that focus on Haskell programs; and approaches that model Curry's call\--time choice semantics.
If applicable, we state our interests in future work for specific topics that we discuss as related work directly.

\subsection{Modelling Algebraic Effects}

In his attempt to combine several functional programming idioms to describe a technique that established reusable components, \citet{swierstra2008data} manifests free monads and their usage for modelling effects in the functional programming community.

\citet{plotkin2009handlers} give a more theoretical overview of algebraic effects and the corresponding handlers.
They were motivated by finding models for exception handlers, but also present algebraic theories for effects like non\--determinism, IO and state.
For all these effects the underlying computation monad is the free\--model of the respective theory.
That is, they derive the representation of free monads to model effects from an algebraic theory.
Starting with their work on algebraic effects, by now there are implementations in Idris~\citep{brady2013programming}, Scala~\citep{brachthauser2017effekt}, OCaml~\citep{kiselyov2016eff}, and Haskell~\citep{kiselyov2015freer,kammar2013handlers} as well as new languages with primitives for effects and handlers like Eff~\citep{pretnar2015introduction}, Koka~\citep{leijen2016algebraic}, Frank~\citep{lindley2017be}, and F*~\citep{swamy2016dependent}.

Concerning modelling effects in dependently typed languages, \citet{mcbride2015turingcompleteness} introduces the \texttt{General} monad to model recursion in Agda.

\begin{verbatim}
data General (S : Set) (T : S -> Set) (X : Set) : Set where
  !!   : X -> General S T X
  _??_ : (s : S) -> (T s -> General S T X) -> General S T X
\end{verbatim}

He describes \texttt{General} as a request\--response tree with values of type \texttt{X}.
The definition is basically the implementation of the free monad we have presented and used here modulo renaming: \texttt{!!} embeds value as we do using \cinl{pure} and \cinl{impure} corresponds to \texttt{??}.

The formalism FreeSpec~\citep{letan2018modular} allows to model components as programs with algebraic effects in a modular fashion and verify properties of these components.
\citeauthor{letan2018modular} implement the framework in Coq based on the \hinl{Program} monad defined in the \texttt{operational} package\footnote{\url{https://hackage.haskell.org/package/operational}} in Haskell.
In contrast to the free monad we use in this chapter, their \cinl{Program} monad adds a third constructor to explicitly model processing a program using a continuation via the additional constructor \cinl{Bind}.

\begin{coqcode}
Inductive Program (I : Type -> Type) (A : Type) :=
| Pure    : A -> Program I A
| Bind    : !$\forall$! (B : Type), Program I B -> (B -> Program I A) -> Program I A
| Request : I A -> Program I A.
\end{coqcode}

In a newer version of the framework the constructors \cinl{Bind} and \cinl{Request} were merged into one constructor, hence, resemble the definition of freer monads as introduced by \citet{kiselyov2015freer} more closely.

\begin{coqcode}
Inductive Program (I : Type -> Type) (A : Type) :=
| Pure    : A -> Program I A
| Request : !$\forall$! (B : Type), I B -> (B -> Program I A) -> Program I A.
\end{coqcode}

In contrast to the usual free monad definition using a functor, the freer representation removes the functor constraint by using a continuation \cinl{B -> Program I A} instead of a direct description of how to process the instruction \cinl{I B}.

The work of \citet{koh2019interaction} on \emph{interaction trees} adapts the freer monad in Coq as well.
The associated DeepSpec project on verifying networked servers implemented in C uses interaction trees as general structure to represent reactive components.
Again,  a more recent version of the framework uses a slightly modified structure.
They currently implement a coinductive variant of the free monad to model diverging computations \citep{xia2019interaction}.

\begin{coqcode}
CoInductive itree (E: Type -> Type) (R: Type) :=
| Ret  : R -> itree E R
| Tau : itree E R -> itree E R
| Vis : !$\forall$! (A : Type), E A -> (A -> itree E R) -> itree E R.
\end{coqcode}

It would be interesting to investigate if a coinductive definition of \cinl{Free} might lead to a model for non\--termination in our setting as well.

Concerning other ideas that are worth further investigation, \citet{atkey2015interleaving} examine how the reasoning about
inductive data types can be eased using the categorical principle of initial algebras.
They are particularly interested in data types that are interleaved with effects --- similar to the monadic liftings of the data types that we have discussed.
Their approach does not only parametrise over the effects but also over the data structures.
That is, they describe an abstraction using \emph{initial f\--and\--m\--algebras}, where \emph{m} describes the interleaved effects as monads and \emph{f} is a functor that describes the pure part of the respective data type.
The part we like to investigate further is the approachability of the custom proof principle they use to prove properties about programs modelled as f\--and\--m\--algebras for our setting.

\subsection{Reasoning About Haskell Programs}

In addition to related work that model effects using monads, there is also a variety of work that focuses on modelling and reasoning about Haskell programs.
Most prominently represented in this thesis is the work by \citet{abel2005verifying}.
We based our approach on their original idea to model Haskell programs in the dependently typed language Agda using a monadic lifting for data types and functions.
The monadic lifting models two aspects of Haskell.
First, Haskell is a non\--strict language, such that the monadic \hinl{>>=}\--operator comes in handy when defining functions that need to pattern match on their arguments.
Second, since \citeauthor{abel2005verifying} want to model total as well as partial Haskell programs, the monadic approach enables the reuse of generic data type and function definitions.
By instantiating the monadic parameter with a concrete instance the model can be used for either one of the wanted settings.

The interactive proof assistant Sparkle developed by \citet{demol2002theorem} is integrated in the programming language Clean~\citep{brus1987clean}.
Since Clean is a non\--strict functional language like Haskell, reasoning about Clean is similar to reasoning about Haskell programs.
Furthermore, Sparkle considers the partiality of Clean as default and, thus, explicitly models undefined values.
As an especially interesting use\--case of this explicit model, \citet{vaneekelen2006proof} reason about the strictness of functions.
As future work, it would be interesting to model such strictness properties in the framework used in this thesis in the same manner as they do in Sparkle.

A conceptually similar approach that targets Haskell instead of Clean is HERMIT~\citep{farmer2015reasoning}.
HERMIT is a toolkit for reasoning about Haskell programs that integrates directly into the GHC pipeline.
The tool was successfully used by \citeauthor{farmer2015reasoning} to formalise and prove properties about various type classes and their corresponding laws as well as pen\--and\--paper proofs taken from \citetitle{bird2010pearls}~\citep{bird2010pearls}.

More recently, the translation of Haskell to Coq is a line of research that is of growing interest.
In the process, the goal is to have generated Coq code as close to the original structure of the Haskell code as possible.
The experience report by \citet{dijkstra2012experimentation} describes such an approach for an automatical translation.
\citeauthor{dijkstra2012experimentation} models partial functions using a method presented by \citet{bove2007computation} that extends all functions with additional proof arguments.
These proof arguments pose certain invariants about all function applications.
For example, the additional argument for the partial function \emph{head} on lists asserts that the applied list argument is not empty.
In contrast to this explicit modelling of Haskell's partiality, \citet{spector-zabusky2018total} present a translation from Haskell to Coq that focuses on total Haskell programs.
The advantage of focussing on the total subset of Haskell is that they can translate functions one\--to\--one to Coq.
In case of a partial function, like \emph{head}, their translation scheme uses, however, an additional axiom that can be understood as a representation of the polymorphic value \emph{undefined}.
As they state, this axiom makes their model unsound and is only meant as a temporarily solution.
That is, the common work\--flow suggests that the user can start proving properties about partial functions right away and totalise these functions later.
Most recently, \citet{breitner2018ready} present a more rigorous case study of this approach that proves properties about real world Haskell libraries.
For this publication the approach concerning partial functions was slightly adapted.
They still use an additional axiom for partial functions, but define it in such a way that prevents Coq from unfolding the definition.
This approach enables a more practical way to reason about some simple properties involving partial functions.

\subsection{Modelling Curry Programs}

Besides the generic view on modelling effects and the focus on modelling or reasoning about Haskell, we also take a look at related work on proving properties about functional logic programs to find connections and inspirations for our findings about modelling Curry programs.
\citet{cleva2004logic} discuss that common equational reasoning techniques are not valid in functional logic languages that combine non\--deterministic functions and call\--time choice semantics.
They suggest a proof calculus based on \emph{CRLW} (constructor\--based rewriting logic)~\citep{gonzalez-moreno1996rewriting} to prove properties about first\--order functional logic programs.
On top of that, they encode this approach in various proof assistants for simple exemplary programs and corresponding properties.

Instead of using term rewriting systems like \emph{CRLW} as basis, \citet{fischer2009purely} present an embedding of Curry's functional logic features, that is, the combination of non\--strictness, sharing and non\--determinism, in the functional language Haskell.
That is, they are more interested in a denotational, executable model of Curry.
Their approach follows the same idea as \citet{abel2005verifying} and uses a monadic lifting of data types and functions to incorporate non\--determinism in combination with non\--strictness.
Due to the combination with non\--determinism, the examples they are most interested in are monadic components that support the type class \hinl{MonadPlus}.

\begin{haskellcode}
class MonadPlus m where
  mplus :: m a -> m a -> ma
  mzero :: m a
\end{haskellcode}

Recall that the type constructor class \hinl{MonadPlus} comes with two functions \hinl{mplus} and \hinl{mzero} that represent operations for non\--deterministic choices and failure values, respectively.
As we have already discussed in \autoref{subsubsec:cbneed}, such a monadic representation models call\--by\--name rather than the concept of call\--by\--need.
In order to overcome this issue, they introduce an explicit sharing function \hinl{share :: MonadPlus m => m a -> m (m a)}.
We used the same interface for the sharing operator in our approach as discussed in \autoref{subsubsec:adhoc}.
These two layers for the resulting value of the sharing function is necessary to retain the non\--strictness property.
The first monadic layer additionally performs bookkeeping when sharing non\--deterministic computations.
In order to track the decisions of shared non\--deterministic computations during evaluation, \citeauthor{fischer2009purely} use an untyped heap that stores computations corresponding to variable references.
That is, their implementation is a realisation of the heap used in the operational call\--by\--need semantics as introduced by \citet{launchbury1993natural}.
The main contribution of an implementation for Curry's call\--time choice in Coq using \cinl{Free} in contrast to the implementation of \citeauthor{fischer2009purely} is to avoid unpure features.
This avoidance originates in our usage of Coq, that does not allow such features, but is also of interest for an implementation in Haskell as well.
As future work, we plan to investigate if a Haskell implementation that tracks the decisions of choices instead of references to computations can compete with respect to performance.

An approach by \citet{antoy2017proving} aims at modelling Curry programs in Agda.
In contrast to our as well as the goal of \citeauthor{fischer2009purely} to implement a generic model that combines non\--strictness, sharing and effects like non\--determinism, \citeauthor{antoy2017proving} explicitly tackle Curry's choice operator only.
They present two different representations of Curry's non\--determinism called \emph{planned choices}, and \emph{set of values} respectively.
The translation for the first approach adds an extra argument to the translated function.
This argument represents the choice to make for non\--deterministic choices during the computation of the translated function and, hence, makes the function deterministic.
For us, the second approach is more interesting because of its high resemblance to a monadic interface.
The second approach translates a non\--deterministic Curry function into a deterministic function in Agda that explicitly models the potential non\--determinism.
The following data type represents the explicit model used in Agda.

\begin{verbatim}
data ND (A : Set) : Set where
  Val  : A -> ND A
  _??_ : ND A -> ND A -> ND A
\end{verbatim}

Here, it becomes apparent that their model is a specialisation of the generic monadic model; in case of our model we can instantiate \cinl{Free} with a variant of the non\--determinism effect \cinl{ND} without \cinl{failed} results\footnote{As already noted, the approach by \citeauthor{antoy2017proving} does not consider \emph{failure} values but focuses on a non\--deterministic choice operator instead.} in a representation isomorphic to their data type \texttt{ND}.
The provided operators \texttt{\$*} and \texttt{*\$*} underline the correspondance to a monadic interface: The former operator corresponds to the functor method \hinl{fmap} and the latter to the monadic bind\--operation \hinl{>>=}.

Lastly, we like to mention the promising prototype developed by \citet{bunkenburg2019modeling} that was developed during his master's thesis.
\citeauthor{bunkenburg2019modeling} implements Curry's call\--time choice semantics in Coq using the \cinl{Free} model in combination with the results of \citet{wu2014effect} about scoped effects.
\citeauthor{wu2014effect} describe two representations for scoped effects: explicit syntax with begin\-- and end\--tags to delimit the scope and higher\--order syntax that uses a higher\--order functor to describe effects.
The first approach leads to cumbersome implementations for handlers of scoped effects when also considering possible mismatches of the tags.
The higher\--order syntax, on the other hand, takes the scoped program directly as argument and, thus, avoids to mark the begin and end of the scope manually.
Concerning the implementations in Coq, the higher\--order syntax, however, opens a new can of worms when trying to circumvent Coq's strict positivity restriction for data types, especially for the definition of the container representation of higher\--order functors.
As future work we like to try out this prototype using several case studies to detect the limits of the approach or the implementation in particular.
With respect to the difficulty of defining the container representation for the higher\--order approach in Coq, we hope to circumvent the problem by finding an appropriate implementation that is probably less general than the implementation in Haskell but
adheres to Coq's restrictions.
First experiments revealed that Agda accepts a slightly adjusted definition of the data type \citeauthor{bunkenburg2019modeling} tried to implement in Coq.
Hence, it might be worthwhile to reimplement the model for call\--time choice in Agda to try out first proofs about Curry programs for the higher\--order approach.
A fairly long\--term goal is to show that our model using \cinl{Free} correctly models Curry's call\--time choice.
Thanks to the implementation in Coq, we can use the model to prove the equivalence with an operational or denotational model of Curry.
The implementation of the operational or denotation of Curry is an interesting line of work itself that is useful for a wide range of questions and issues.

\section{Future Work}

Besides the special case of modelling Curry programs, we are interested in adapting our approach to be applicable to call\--by\--need semantics in general.
In Haskell, for example, we can also observe the difference between call\--by\--name and call\--by\--need when considering tracing as effect.
Consider the following exemplary Haskell program and its evaluation assuming a call\--by\--need and call\--by\--name semantics, respectively.

\begin{verbatim}
> let xNeed = trace "example" 42 in xNeed + xNeed
example84

> let xName = trace "example" 42 in xName + xName
exampleexample84
\end{verbatim}

The function \hinl{trace :: String -> a -> a} takes a message as first argument that is printed on the console and yields its second argument.
Note that using call\--by\--name semantics allows us to inline the let\--binding, yielding the following expression that triggers the tracing\--effect twice.

\begin{verbatim}
> trace "example" 42 + trace "example" 42
exampleexample84
\end{verbatim}

We plan to apply the first insights we gained from modelling Curry programs to model Haskell's tracing effect with call\--by\--need semantics.
In a first attempt to investigate the current approach \citep{christiansen2019verifying}, we took a more detailed look at the effects occurring in Haskell and defined a category of effects that behave the same under call\--by\--name and call\--by\--need semantics using a syntactic criteria for the effects involved.
In that paper, we have shown that a variety of propositions can be successfully modelled using our approach, assuming that the functions involved do not share computations.

When thinking about non\--deterministic functions, it becomes apparent that we cannot model all possible functions with our current approach.
Consider for example the following two function definitions of the same type.

\begin{curry}
fun1 :: Int -> Int
fun1 x = (x + 1) ? (x * 2)

fun2 :: Int -> Int
fun2 = (+1) ? (*2)
\end{curry}

Both functions increment the input value by one as well as multiply it by two by using non\--determinism.
The crucial difference is that the first function non\--deterministically yields a value whereas the second one yields a non\--deterministic function.
When using these functions as argument to \hinl{map}, for example, we can observe that these implementation behave differently.

\begin{verbatim}
> map fun1 [1,1]
[2,2]
[2,2]
[2,2]
[2,2]

> map fun2 [1,1]
[2,2]
[2,2]
\end{verbatim}

These examples are also used by \citet{mehner2014parametricity} to show that eta\--equivalence does not hold for Curry.
Translating the second function into our framework is, however, not possible.
Up to now, we have translated all function types by lifting each individual argument.
In case of \hinl{fun2}, we need to implement the non\--deterministic choice between two functions, thus, the final type is a function type that must be lifted.
More precisely, let us take a look at the definition of \cyinl{fun1} and the try to define \cyinl{fun2} with the usual pattern.

\begin{coqcode}
Definition fun1 (A : Type) (fn : Free nat) : Free nat :=
  (liftM2 plus fn (pure 1)) ? (liftM2 mult fn (pure 2)).

Definition fun2 (A : Type) : Free nat -> Free nat :=
  (fun fn => liftM2 plus fn (pure 1)) ? (fun fn => liftM2 mult fn (pure 2)).
\end{coqcode}

The second definition will not typecheck, because both arguments of \cinl{?} are functions, not the resulting expression.
The resulting expression is of type \cinl{Free (Free nat -> Free nat)}.
When thinking about the translation of types in more detail, it indeed makes sense to translate a Curry (or Haskell) function of type \hinl{a -> a} to \cinl{Free (Free a -> Free a)} in our monadic lifting.
Currently, we have corresponding type definitions that lift all arguments of the corresponding constructors.
For example, a type for pairs has a constructor \cinl{pair} of the following type.

\begin{crepl}
\coqrepl Check pair.
  pair : Free A -> Free B -> Pair A B.
\end{crepl}

Applying this rule to a function type, we need a constructor for lifted arguments as well.

\begin{coqcode}
Inductive Arrow (A B : Type) :=
| arrow : (Free A -> Free B) -> Arrow A B.
\end{coqcode}

Using the definition of \cinl{Arrow} as translation for function types, we can then define the two functions above as follows.

\begin{coqcode}
Definition fun1 (A : Type) :  Free (Arrow (Free nat) (Free nat)) :=
  (pure (arrow (fun fn => (liftM2 plus fn (pure 1))))) ?
  (pure (arrow (fun fn => (liftM2 mult fn (pure 2))))).

Definition fun2 (A : Type) : Free (Arrow (Free nat) (Free nat)) :=
  pure (arrow (fun fn => (liftM2 plus fn (pure 1))
                       ? (liftM2 mult fn (pure 2)))).
\end{coqcode}

Although both functions have the same type, we can now see the difference of the implementation more explicitly: the first definition produces a non\--deterministic result that consists of two functions first, while the second definition yields a pure function with non\--deterministic values as argument for the \cinl{arrow} constructor.
Note that a similar construction is also possible in the partiality setting we discussed for Haskell.
The difference between such two function definitions can, however, only be observed in the presence of the function \hinl{seq :: a -> b -> b} that evaluates its first argument to head normal form and yields its second argument.
The example consisting of two functions in case of partiality in Haskell look as follows.

\begin{haskellcode}
fun1 :: a -> b
fun1 x = undefined

fun2 :: a -> b
fun2 = undefined
\end{haskellcode}

In order to make the framework approachable for users, we like to investigate if all functions should be translated using \cinl{Arrow} or only functions that cannot be constructed otherwise.
For both variants it makes sense to conduct a case study to check how these decisions affect the usage of the framework when writing proofs.

As a different direction for future work, it would be interesting to consider inequational propositions as well.
Using inequational propositions, we can, for example, compare the strictness of two implementations of the same function.
Consider the following two variants to define multiplication on Peano numbers.

\begin{haskellcode}
mult :: Peano -> Peano -> Peano
mult Zero    _ = Zero
mult (Succ m) n = add n (mult m n)

mult2 :: Peano -> Peano -> Peano
mult2 Zero     _    = Zero
mult2 (Succ _) Zero = Zero
mult2 (Succ m) n    = add n (mult2 m n)
\end{haskellcode}

We refer to the former definition as the default implementation, whereas the latter definition is a more advanced variant that is less\--strict.
Assuming a less\--strict\--relation $\sqsubseteq$, we are then interested in a formal specification that \hinl{mult2} is less strict than \hinl{mult}.

\[
\forall \text{ p q : Peano}. \text{ mult p q} \sqsubseteq \text{mult2
  p q} \wedge \exists \text{ p q : Peano}. \text{ mult2 p q} \not \sqsubseteq \text{mult p q}
\]

A first idea to model the relation in the setting of partiality using the \cinl{Free}\--approach looks as follows.

\begin{coqcode}
Inductive le_Free_Partial A (leA : A -> A -> Prop)
  : Free A -> Free A -> Prop :=
| le_pure : !$\forall$! x y, leA x y -> le_Free_Partial leA (pure x) (pure y)
| le_impure_pure : !$\forall$! e x, le_Free_Partial leA (impure e) (pure x)
| le_impure : !$\forall$! e1 e2, le_Free_Partial leA (impure e1) (impure e2).
\end{coqcode}

In a similar manner, we can define a specialised version for an effect like \hinl{error}.
More interesting, however, is the objective to generalise the relation to arbitrary effects.
For example, an attempt to generalise the definition for the partiality and error setting passes an additional function to compare the shape of the effects involved.

\begin{coqcode}
Inductive le_Free_Hoare (A : Type) (leS : Sh -> Sh -> Prop)
    (leA : A -> A -> Prop) : Free C A -> Free C A -> Prop :=
| le_pure_Hoare : !$\forall$! x y,
    leA x y -> le_Free_Hoare leS leA (pure x) (pure y)
| le_impure_pure_Hoare : !$\forall$! s pf x,
    (!$\forall$! p, le_Free_Hoare leS leA (pf p) (pure x)) ->
      le_Free_Hoare leS leA (impure (ext s pf)) (pure x)
| le_impure_Hoare : !$\forall$! s1 pf1 s2 pf2,
    (!$\forall$! p1, exists p2, le_Free_Hoare leS leA (pf1 p1) (pf2 p2)) ->
    leS s1 s2 ->
    le_Free_Hoare leS leA (impure (ext s1 pf1)) (impure (ext s2 pf2))
| le_pure_impure_Hoare : !$\forall$! x s pf,
    (exists p : Pos s, le_Free_Hoare leS leA (pure x) (pf p)) ->
      le_Free_Hoare leS leA (pure x) (impure (ext s pf)).
\end{coqcode}

In contrast to the version of partiality, the constructors \cinl{le_impure_pure_Hoare} and \cinl{le_impure_Hoare} have additional hypotheses that take care of possible recursive effects.
Moreover, the constructor \cinl{le_pure_impure_Hoare} needs to be added for effects like non\--determinism that combine several values when using its primitive \texttt{choice}\--operator.
The definition above is not the only relational interpretation that is reasonable.
Possible alternatives are constructions corresponding to Smith or Plotkin powerdomains \citep{abramsky1994domain}.
We have presented these ideas in \citet{christiansen2019proving} and plan to continue this approach in the future.

\section{Conclusion}
\label{sec:conclusion}

In this chapter we discussed an approach to model and reason about non\--strict effectful programs in a proof assistant like Coq.
Here, partiality as most notably occurring in Haskell as well as Curry's non\--determinism were effects of special interest.
We started with a detailed motivation that resembles the obstacles we stumbled upon and the corresponding ideas and final solutions we came up with to tackle the problems.
After establishing the preliminary concepts underlying the framework, we define first Haskell functions and associated properties.
One of the advantages of the framework is its generality: although we are especially interested in an effect like partiality that can occur in Haskell, we emphasise the definition of effect\--generic functions and proofs.
The former is a common idiom in functional programming, we generalise functions using, for example, a monadic abstraction.
In case of our framework, the latter generalisation is even more interesting: if a proposition holds for arbitrary effects, we can reuse this proposition in other generic proofs as well as in proofs about more specialised settings like partiality.
That is, we can even reuse a variety of functions and properties we define to model Haskell programs when reasoning about Curry programs.
Of course, for Curry programs we need a non\--deterministic choice between two computations as an additional primitive, nonetheless, effect\--generic functions and propositions can be reused.
In the section about Curry, we additionally observe that the current model we use for Haskell as well as Curry follows call\--by\--name semantics.
In both cases, call\--by\--need semantics is what we are actually aiming for.
In case of Curry, however, we more naturally stumble upon this problem, because in case of non\--determinism we can observe the difference between call\--by\--name and call\--by\--need whereas we cannot observe this difference in case of partiality only.
For an effect like tracing, on the other hand, that is common for Haskell programmers as well, we can again observe the difference.
Thus, this observation leads us to the goal to define a model that enables us to reason about call\--by\--need semantics.
We discussed a first naive approach to reproduce the wanted semantics for simple programs, but could not use this approach in a more general setting.
In order to overcome this obstacle, we refer to a prototypical implementation using scoped operations to model Curry's call\--time choice semantics.
We hope to apply the ideas on scoped operations to reason about Haskell's tracing effects and other effects that rely on call\--by\--need semantics.

\section{Final Remarks}

The framework presented in this chapter as well as additional content has been previously published.
We published the general approach to represent Haskell programs as monadic Coq programs using free monads and container representations for functors in The Art, Science, and Engineering of Programming, Volume 3 \citep{dylus2019one}.
In the publication we additionally present a case study on queues that we did not include here.
Furthermore, the publication has a fairy tale theme that allowed us to present the obstacles and their solution in a more tutorial\--like manner.
Note that we decided here to define \cinl{Free} with an inlined version of \cinl{Ext} instead of using the data type to represent the container extension explicitly.
The additional content about Haskell's tracing effect and the observations concerning modelling call\--by\--name and call\--by\--need were published recently in the Proceedings of the 12th International Symposium on Haskell \citep{christiansen2019verifying}.
The publication also covers the translation of function types using an additional layer of monadic liftings as we discuss properties about Haskell's primitive function \hinl{seq}.
