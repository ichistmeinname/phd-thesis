\cleanchapterquote{There is no deep theoretical reason why this
  program should be rejected [...].}{Adam Chlipala}{(Associate
  Professor of Computer Science)}

This chapter moves the focus from applications using effects like
non-determinism to an approach to model effectful programs in order to
apply equational reasoning.
Equational reasoning is a popular and common tool to prove properties
about functional programs and, thus, prominently used by Haskell
practitioners. \todo{cite a lot}
In particular, \citet{danielsson2006fast} argue that reasoning about
total programs only and expecting the result to carry over to partial
programs is \textit{morally correct}.
Nevertheless, if we are interested in proving properties about partial
or other effectful programs more explicitly, we cannot apply
equational reasoning as it is and need a model for effectful programs.
In the remainder of this chapter we present an approach to model
effectful non-strict functional programs in the proof assistant Coq
and prove exemplary properties about common functions used in
functional languages.
All these properties hold in total languages as well and are, thus,
not new insights.
The main insight of our approach is that a lot of these properties
carry over to partial languages in the sense that these properties
still hold if partial values are at play.
Our approach allows to reason not only about a concrete
effect like partiality or non-determinism, but for a whole class of effects; the
interesting outcome of the this approach is that one proof is
enough to prove a proposition for a whole class of effects.
In the following we will talk about this insight as being able to
prove properties in an effect-generic fashion.

After discussing the general idea for a framework to model effectful
non-strict functional programs, we emphasise on one effect occurring
in Haskell: partiality.
We present a couple of examples that prove properties of common Haskell list
functions.

Last but not least we give an outlook on first ideas to model Curry
programs.
The underlying effect of Curry is non-determinism with the special
treatment with respect to sharing.
As we have seen in previous chapters, the combination of
non-determinism and non-strictness lead Curry to chose a
call-time-choice semantics, where variables declare values and not computations.
That is, our idea tackles the problem of modelling a language where
sharing is not an optimisation with respect to evaluation only, but
can be observed.

In summary, this chapter makes the following contributions.

\begin{itemize}
\item We present a generic model of effectful non-strict functional
  programs in the proof assistant Coq.
\item The modelling in Coq is particular interesting since the
  standard implementation of effectful data structures does not please
  the termination checker.
\item We take the reader on an introductory tour of Coq's intricacies in
order to define a valid representation of effectful programs.
\item We argue that our approach is especially interesting for proving
  properties for a variety of effects once-at-for-all instead of
  individually for each new effect of interest.
\item The first ideas on modelling Curry's call-time choice semantics
  gives insights about modelling a language with sharing.
\end{itemize}
 
\section{A Generic Model For Effectful Non-Strict Programs}

In this section we will present our general approach to model
effectful non-strict programs in a dependently-typed language like
Coq.
We illustrate why previous work is not applicable anymore or does not
tackle the same problem as we do.
Since the reasons for the inapplicability of the previous work is due
to rather technical reasons of dependently-typed languages and the
general idea of propositions as types \citep{wadler2015propositions},
we give a detailed explanation to illustrate which steps are necessary
to model our approach in Coq.
That is, this section tries to explain the obstacles and their
solutions to a beginner-friendly Coq audience.

\subsection{Representation of Partial Programs}
\label{subsec:partial}
The first obstacle that arises when we model Haskell programs in Coq
is the fact that Coq is a total language and most Haskell programs are
not.
That is, we cannot translate partial Haskell programs into Coq as they
are, we need to represent the partial parts of the programs more
explicitly.

Let us take a look at an example.
One of the first partial function that comes to mind is the \hinl{head} function on lists.
In case of the empty list the function is not defined as there is not element to return.

\begin{minted}{haskell}
head :: [a] -> a
head (x:_) = x
\end{minted}

\noindent 
Due to the missing case for the empty list, the above code is
equivalent to the following implementation that uses a pattern for the
empty list to explicitly yield \hinl{undefined}.

\begin{minted}{haskell}
head :: [a] -> a
head []    = undefined
head (x:_) = x
\end{minted}

In a total language like Coq the corresponding head functions usually
takes an additional argument to take care of the undefined behaviour
in case of the empty list.
The following implementation is part of Coq's predefined library for
lists.

\begin{minted}{coq}
Definition hd (A : Type) (default : A) (l : list A) : A = 
  match l with
  | nil => default
  | cons x _ => x
  end.
\end{minted}

Alternatively, we can indicate the potentially undefined behaviour by
changing the result type to \cinl{option A}.
In case of a non-empty list we wrap the head element into the
\cinl{Some}-constructor, and use \cinl{None} as
resulting value for an empty list.
This alternative implementation is predefined under the name
\cinl{head}.

\begin{minted}{coq}
Definition head (A : Type) (l : list A) : option A  = 
  match l with
  | nil => None
  | x :: _ => Some x
  end.
\end{minted}

The latter version suites our problem a bit better than the first:
there is not always a good candidate in scope that can be used as
default value, the latter version fits a general setting better.
However, the latter version is not compositional.
Consider the following example that uses the result of
\cinl{head} as an argument.

\begin{minted}{coq}
Fail Definition exampleList (A : Type) : list A :=
  cons (head nil) nil.
\end{minted}

We cannot use the result as an element of the newly constructed list,
we get a type error.

\begin{quote}
\emph{The term "cons (head nil) nil" has type "list (option ?A)" while it is expected to have type "list A".}
\end{quote}

The list constructor \cinl{cons} expects the head element
of the list to match its type with all the elements of the remaining
list.
Since we want to construct a list of type \cinl{list A},
the head element needs to be of type \cinl{A};
the function \cinl{head}, however, yields a value of type
\cinl{option A}.

As Haskell is a non-strict language, it is crucial that we allow
partial values at top-level as well as within the components of data
structures, that is, within arguments of constructors in order to
model Haskell's partiality correctly.
Due to non-strictness, it is possible that an undefined value is never
demanded during evaluation.
The Haskell expression \hinl{head (1 : undefined)}, for example, does
not trigger the \hinl{undefined} value in the tail of the list,
because \hinl{head} only demands the first list constructor \hinl{:}
and ignores the second argument.
Instead of reusing \cinl{option}, we define a new data type
\cinl{partial} that captures the notion that a value can be undefined
or defined.

\begin{minted}{coq}
Inductive partial (A : Type) :=
| undefined : partial A
| defined   :  A -> partial A.
\end{minted}

In case of the lists we need to adapt the definition of the data type
itself by lifting all arguments to allow partial values as well.

\begin{minted}{coq}
Inductive List (A : Type) :=
| nil : List A
| cons : partial A -> partial (List A) -> List A.

Definition Nil (A : Type) : partial (List A) :=
  defined nil.
Definition Cons (A : Type) (ox : partial A) (oxs : partial (List A)) 
  : partial (List A) :=
  defined (cons ox oxs).
\end{minted}

The data type \cinl{List} represents a Haskell list in Coq
as all constructor arguments may be partial.
When defining functions on lists, we need to consider that the overall
list may already be partial.
Hence, we define smart constructors \cinl{Nil} and
\cinl{Cons} that wraps the list in the additional
\cinl{defined}-constructor to indicate that the top-level
expression is defined.
The definition of  functions like \cinl{head} adapt to the settings as
follows: all argument as well as result types need to be lifted and
the implementation needs to handle the partial values accordingly.

\begin{minted}{coq}
Definition head (A : Type) (oxs : partial (List A)) : partial A :=
  match oxs with
  | undefined  => undefined
  | defined xs => match xs with
                 | nil       => undefined
                 | cons ox _ => ox
                 end
  end.
\end{minted}

We cannot pattern match on the list directly as in the original
defintion.
In order to access the list, we need to take a look at the
\cinl{partial}-layer first.
If the input list is already \cinl{undefined}, the
overall result is \cinl{undefined} as well.
If the input list \cinl{defined}, we can reimplement the original
behaviour of the Haskell function, that is, yielding the first element
in case of a non-empty list and yielding \cinl{undefined} in case of
an empty list.

Let us take a look at another list function in Haskell and its
counterpart in our model for Coq: concatenation of two lists.

\begin{minted}{haskell}
(++) :: [a] -> [a] -> [a]
(++) []       ys = ys
(++) (x : xs) ys = x : ((++) xs ys)
\end{minted}

The concatenation function on lists is a recursive and total function
and can, thus, be translated to Coq as it is.
However, since we want to mix partial and total functions and, thus,
increase the compositionality of both possible effects, we translate
the append function using the same scheme as above.

\begin{minted}{coq}
Fail Fixpoint append (A : Type) (oxs oys : partial (List A)) : partial (List A) :=
  match oxs with
  | undefined  => undefined
  | defined xs => match xs with
                 | nil         => oys
                 | cons oz ozs => Cons oz (append ozs oys)
                 end
  end.
\end{minted}

The function \cinl{append} is recursive and, as far as we
are concerned, the first argument is structurally decreasing in each
recursive call.
However, Coq does not accept the above definition and rejects its with
the following message.

\begin{quote}
\emph{The command has indeed failed with message: Cannot guess decreasing
argument of fix.
Recursive call to append has principal argument equal to "ozs" instead of a subterm of "oxs".}
\end{quote}

What is going on here?
Coq cannot retrace that the value \cinl{ozs} is actually a
subterm of \cinl{oxs}; without that connection the
recursive call on \cinl{ozs} is not allowed.

The problem is our lifted data type definition of
\cinl{List}.
Due to the lifting, the \cinl{List} becomes a so-called
\emph{nested inductive} type, because the type we want to define
appears nested in another inductive type.
In this case the other inductive type is \cinl{partial}.

We can fix the problem by splitting the function into a non-recursive
and a recursive part.
The recursive part is working only on \cinl{List A} and
produces an \cinl{partial (List A)}, while the non-recursive
function expects and yields a value of type \cinl{partial
  (List A)} and mainly calls the recursive one after unwrapping the
\cinl{partial}-layer.

\begin{minted}{coq}
Definition append (A : Type) (oxs oys : partial (List A)) : partial (List A) :=
  match oxs with
  | undefined  => undefined
  | defined xs =>
    let fix append' xs oys :=
        match xs with
        | nil         => oys
        | cons oz ozs => Cons oz (match ozs with
                                  | undefined => undefined
                                  | defined zs => append' zs oys
                                  end)
        end
    in append' xs oys
  end.
\end{minted}

The recursive function is the local function
\cinl{append'}.
In order to make the recursive call we need to unpack an additional
\cinl{option}-layer of the variable \cinl{ozs}.
Since we are now reconstructing the nested inductive structure using a
nested recursion, Coq accepts the definition.

In the remaining of this chapter we will define the two functions
necessary to translate a recursive Haskell function on top-level to
reuse the definitions in proofs.
The recursive function that works directly on the nested inductive
type will be suffixed with prime like for the local function definition.
That is, the following code shows how the above can be split into two
top-level functions.

\begin{minted}{coq}
Fixpoint append' (A : Type) (xs : List A) (oys : partial (List A))
  : partial (List A) :=
  match xs with
  | nil         => oys
  | cons oz ozs => Cons oz (match ozs with
                            | undefined    => undefined
                            | defined zs => append' zs oys
                            end)
  end.

Definition append (A : Type) (oxs oys : partial (List A))
  : partial (List A) :=
  match oxs with
  | undefined  => undefined
  | defined xs => append' xs oys
  end.
\end{minted}

\subsection{Generalisation Attempt}

Up to now, we have seen an encoding of Haskell programs in Coq that
lifts all Haskell values to \cinl{partial} values.
The overall goal is to not only reason about Haskell's partiality
effect but a whole class of effects.
That is, we do not want to restrict our model in Coq to one effect
only, but generalise it to arbitrary effects.

The first idea that comes to mind to generalise the above encoding is to change the
concrete type \cinl{partial} by a type parameter.
Hence, we can regain the above encoding by instantiating the type
parameter with \cinl{partial}.
Consider the following parametrised definition of \cinl{List}.

\begin{minted}{coq}
Fail Inductive List (M : Type -> Type) (A : Type) :=
| nil : List M A
| cons : M A -> M (List M A) -> List M A.
\end{minted}

Similar to \cinl{partial} that mimics the Maybe monad that we know
from Haskell, we will be mostly interested in other monadic
instantiations.
Thus, we name the type parameter \cinl{M} to indicate that it is a
placeholder for a monadic type.
This representation was already suggested by
\citet{abel2005verifying}, who translated Haskell code into Agda code
in order to prove propositions about Haskell functions.
Their approach, however, is not applicable in recent versions of Agda
nor Coq anymore.
When we try to compile the above definition, we get the following error message.

\begin{quote}
\emph{The command has indeed failed with message:
Non strictly positive occurrence of "List" in "M A $\rightarrow$ M (List M A) $\rightarrow$ List M A".}
\end{quote}

Coq does not allow to define a type definition like \cinl{List}
because of its \emph{strict positivity requirement}.
What is going on this time?

As a first step to understand what is going on here, we will reduce
the above definition to the simplest definition that still triggers
the same error message.

\begin{minted}{coq}
Fail Inductive NonStrictlyPos :=
| con : (NonStrictlyPos -> nat) -> NonStrictlyPos.
\end{minted}

The data type \cinl{NonStrictlyPos} has no type parameters and only
one unary constructor \cinl{con}.
The argument of the constructor \cinl{con} is a function from
\cinl{NonStrictlyPos} to \cinl{nat}.
The domain of this function is the crucial part of the definition and
the origin of the error message.
As so often when using Coq, \citeauthor{chlipala2011certified}'s book is a
great resource for typical obstacles beginners may face when using Coq
for the first time; he has the following intuitive description for the
strict positivity requirement.

\begin{quote}
\emph{We have run afoul of the strict positivity requirement for
  inductive definitions, which says that the type being defined may
  not occur to the left of an arrow in the type of a constructor
  argument.}
\end{quote}

Inductive type definitions obey the strict positivity requirement, if
for all constructors its recursive occurrences only occur strictly
positive in all argument types.
That is, in case of \cinl{NonStrictlyPos} we need to inspect the types
of the arguments of its only constructor \cinl{con}.
The only argument of \cinl{con} is the function type
\cinl{NonStrictlyPos -> nat}.

\begin{excursus}{Positive and Negative Occurrences}
What is a positive occurence that \cinl{List} seems to violate giving
the error message Coq produces when we try to compile the data type
definition?
Taking the quote of Chlipala to a more formal ground, we can describe
a strictly positive occurrence of a type as follows: a type $\tau$
occurs strictly positively in a type $\tau_1\rightarrow \dots
\rightarrow \tau_n \rightarrow tau$, if and only if $\tau$ does not
occur in any of the types $\tau_i$ with $i$ ranging from $1$ to $n$.
Although this description might answer the question we raised to some
extent, but it also opens new ones: how do we distinguish between
\emph{positive} and \emph{strictly positive} occurrences; can an
occurrence be \emph{negative} as well?

For that matter, let us consider an arbitrary type $\tau = t_1
\rightarrow \dots \rightarrow t_n$, where all $t_i$ are types as well.
The type arguments $t_1$ to $t_n$ appear in positive or negative
positions.
A type argument $t_i$ has a negative position if it appears to the
left of an odd number of type arrows.
That is, starting from an inner position, each type arrow flips a
negative position to a positive and vice versa.
In particular, a type argument $t_i$ has a positions position if it
appears to the left of an even number of type arrows or no type arrows
at all.
We can define the set of negative and positive positions, $Pos^{+}$
and $Pos^{-}$, respectively, of a type $\tau$ inductively given a set of
inductive types $I$ as described by
\citet{blanqui2002inductivedatatype}.

\begin{alignat*}{2}
  &Pos^{+} (\tau \in I) &&= \epsilon\\
  &Pos^{-} (\tau \in I) &&= \{\}\\
  &Pos^{+} (t \rightarrow \tau) &&= 1 \cdot Pos^{-} (t) \cup 2 \cdot Pos^{+} (\tau)\\
  &Pos^{-} (t \rightarrow \tau) &&= 1 \cdot Pos^{+} (t) \cup 2 \cdot Pos^{-} (\tau)
\end{alignat*}

Based on this definition, we can specify that a type $t$ occurs
positively in $\tau$ if the set $Pos^{+} (\tau)$ contains every occurrence of $\tau$ in
$t$.
Moreover, a type $t$ occurs strictly positively in

\[
\tau = t_1 \rightarrow \dots \rightarrow t_n \rightarrow t
\]

if $t$ occurs in no $t_i$.

Consider the following examples of possible types in Coq, where
\cinl{A} is a type variable.

\begin{enumerate}
\item[(1)] \cinl{A -> nat}
\item[(2)] \cinl{nat -> A}
\item[(3)] \cinl{(A -> nat) -> nat}
\item[(4)] \cinl{((A -> nat) -> nat) -> nat}
\end{enumerate}

The type \cinl{A} occurs positively in (2) and (3), and negatively in
(1) and (4).
The occurrence in (2) is also strictly positive.

In dependently typed languages, the strict positivity
requirement plays an important role for the definition of inductive
data types.
An inductive type t obeys the strict positivity requirement if the
recursive occurrences of t are strictly positively in the types of all
the arguments of its constructors.\footnote{The definition by
  \citeauthor{blanqui2002inductivedatatype} also takes care of mutual
  inductive types where the recursive occurrence is only implicit.}

Consider once again the following exemplary type definitions in Coq.

\begin{enumerate}
\item[(1)] \cinl{Inductive T := con : T -> T -> T}
\item[(2)] \cinl{Inductive T := con : (T -> T) -> T}
\item[(3)] \cinl{Inductive T := con : (nat -> T) -> T}
\item[(4)] \cinl{Inductive T := con : (nat -> T) -> (T -> T) -> T}
\end{enumerate}

The inductive type \cinl{T} obeys the strict positivity requirement in
(1) and (3), and violates it in (2) and (4).
In (1) we need to check the following arguments of the constructors
\cinl{con}: \cinl{T} and \cinl{T}; both types are strictly positive.
The argument in question for (3) is \cinl{nat -> T}, where \cinl{T}
does not occur to the left of an arrow, thus, the type is strictly
positive as well.
In (2) we need to inspect the type \cinl{T -> T}; here, \cinl{T}
occurs to the left of an arrow, thus, in a negative position.
The overall definition, then, does not fulfil the requirement.
The inductive type in (4) is a combination of (2) and (3), thus, the
type of the first argument of \cinl{con} fulfils the requirement,
whereas the second arguments violates it again.
\end{excursus}

Let us think again about the definition of \cinl{NonStrictlyPos}.
With the excursus above, we now know that \cinl{NonStrictlyPos}
occurs ``left of an arrow''  in the first argument of the
\cinl{con}-constructor, namely in the function type
\cinl{NonStrictlyPos -> nat}.
Due to this non strictly positive occurence, the overall data type
definition of \cinl{NonStrictlyPos} is non strictly positive as well,
that is, fails the strict positivity requirement for data type
definitions.
In contrast, the following definition is not problematic.

\begin{minted}{coq}
Inductive StrictlyPos :=
| con : StrictlyPos -> (nat -> StrictlyPos) -> StrictlyPos.
\end{minted}

Here, both argument of the constructor \cinl{con} are strictly positive:
the first argument is of type \cinl{StrictlyPos}, thus, trivially
strictly positive; and in the second argument's type \cinl{StrictlyPos}
does not occur to the left, but to the right of an arrow, fulfilling
the positivity requirement as well.

This little excursus explains the origin of the error message Coq
presents us when we try to define data types likes
\cinl{NonStrictlyPos} and \cinl{List}, but two question still remain
open: (1) Why is the strict positivity of data type definition
required in Coq; (2) Why is our definition \cinl{List} non strictly
positive as well, there is not even an arrow in the arguments' type of
\cinl{cons}?

\paragraph{Why does Coq require the strict positivity of data type
  definitions?}

Let us for a moment assume that the definition of
\cinl{NonStrictlyPos} was allowed.
We then define the following function.\footnote{We use a different
  font to distinguish the following hypothetical code from valid Coq code.}

\begin{verbatim}
Definition applyFun (t : NonStrictlyPos) : nat :=
  match t with
  | con f => f t
  end.
\end{verbatim}

The function \cinl{applyFun} takes a value \cinl{t} of type
\cinl{NonStrictlyPos} and applies the function \cinl{f} inside the
argument of the \cinl{con}-constructor to the value \cinl{t} itself.
A problematic example usage of this function is the expression
\cinl{applyFun (con applyFun)}.
Reducing the expression by using the definition of \cinl{applyFun} yields
\cinl{applyFun (con applyFun)} again.
We can apply this reduction infinitely often, thus, we have
constructed an infinite expression that does not terminate.

\begin{verbatim}
  applyFun (con applyFun)
= {- Definition of applyFun -}
  applyFun (con applyFun)
= {- Definition of applyFun -}
  ...
= {- Definition of applyFun -}
  applyFun (con applyFun)
\end{verbatim}

Taking a step back, we observe that the data type
\cinl{NonStrictlyPos} has some resemblance with a specialised instance
of the fix-point combinator \cinl{Mu}.

\begin{minted}{coq}
Fail Inductive Mu A :=
| mu : (Mu A -> A) -> Mu A.
\end{minted}

Note that we cannot define the type \cinl{Mu} in Coq.
The connection to the fix-point combinator explains why Coq needs to
restrict such a definition: we know that all Coq programs need to
terminate and we need to use a special keyword \cinl{Fixpoint} or
\cinl{fix} to indicate recursive function in order to apply
termination checks with respect to recursion.
If we could define a data type like \cinl{Mu}, our definition of
\cinl{applyFun} is an example that shows how we can define
non-terminating programs without using the explicit fix-point
combinator that Coq already provides for recursive constructions.
That is, data types like \cinl{Mu} introduce the capability to express
general recursion and Coq's logic becomes inconsistent.
In order to ensure the consistency of Coq's logic, the strict
positivity requirement needs to be enforced for data type definitions.

\paragraph{Why does \cinl{List} not fulfil the strict positivity requirement?}

Now we know what Coq is nagging about when the error message about a
non strictly positive occurrences for data type definitions appears.
However, it is still not obvious why the definition of \cinl{List}
falls under the same category.
Recall our try to define the data type \cinl{List}.

\begin{minted}{coq}
Fail Inductive List (M : Type -> Type) (A : Type) :=
| nil : List M A
| cons : M A -> M (List M A) -> List M A.
\end{minted}

The type \cinl{List} does not appear to the left of an arrow in the
argument types of its constructor \cinl{cons}, but Coq still rejects
the definition because of the type \cinl{M (List M A)}.
However, Coq is of course on the right track rejecting such a
definition.
While a concrete instantiation using \cinl{partial} instead of the
type parameter \cinl{M} is accepted, since \cinl{List} does not appear
to the left of an arrow, we cannot guarantee that all usages of
\cinl{List} obey this requirement.

For example, consider the following definition that we might use to
instantiate the type parameter with.

\begin{minted}{coq}
Definition Cont R A := (A -> R) -> R.
\end{minted}

The type \cinl{Cont} represents the continuation monad.
Now let us instantiate the type parameter \cinl{M} in the definition
of \cinl{List} with \cinl{Cont}, a concrete monad.
The following type definition \cinl{ListCont} inlines the definition
of \cinl{Cont} in the constructor corresponding \cinl{cons}.

\begin{minted}{coq}
Fail Inductive ListCont R A :=
| nilC  : ListCont R A
| consC : ((A -> R) -> R) -> ((ListCont R A -> R) -> R) -> ListCont R A.
\end{minted}

Due to the inlining, it now becomes apparent that the type we are just
defining, \cinl{ListCont}, appears indeed to the left of an arrow in
one of the type argument of its constructor.
More precisely, \cinl{ListCont} appears to the left of an arrow in the
second argument of the \cinl{consC}-constructor.
Summarising our findings, the type definition \cinl{List} defined
above allows arbitrary type constructor as instances for its type
parameter \cinl{M}.
Since the type parameter is arbitrary, it is not safe to use this
definition for all potential instances of \cinl{M}.
The strict positivity restriction might be violated for a concrete
instation of \cinl{M}, for instance for the concrete instantiation of
\cinl{Cont} as we demonstrated in the definition of \cinl{ListCont}.
Since we cannot guarantee by definition that the data type definition
\cinl{List} is only used with instantiations of \cinl{M} that obey the
strict positivity requirement, Coq rejects the definition.

\subsection{Free Monad and Containers}
\label{subsec:freeAndContainers}

In order to summarise the situation so far: we want to model effectful
data types and functions, for example representing non-strict partial
programs, in a generic way, but cannot use a type constructor variable
to represent this generic effect in Coq due to the strict positivity
requirement.
If we use, however, a concrete effect, like \cinl{partial}, the strict
positivity is guaranteed again.
That is, we want to represent effects using a concrete data type
representation in order to satisfy Coq's requirement.
Recall that the effects we want to represent are all a superset of a
pure value; partiality, for example, adds [undefined] to the set of
[defined] values.
The other mechanism the effects need to offer is a way to apply
functions to the pure value; in case of \cinl{partial} we have used pattern
matching to unwrap the pure values in order the define [head] and
[append].
Fortunately, a monadic abstraction gives us exactly these
capabilities.
A monad describes a type constructor \cinl{M} that allows to define
functions \cinl{return : A -> M A} and \cinl{bind : M A -> (A -> M B)
  -> M B}, where former lifts a pure value into the monadic structure
--- in case of \cinl{partial} we implement the function using [defined] ---
and the latter allows us to apply a function to a pure value within
the monadic structure.
Note that the function that we apply yields a monadic structure as
well, that is, we cannot unwrap the monadic layer for good, but only
to apply the function.

The main goal is to retain the generality to model arbitrary monads,
but to use a concrete data type in order to fulfil the strict
positivity requirement.
We can achieve this goal by using a data type that represents all
strictly positive types in a constructive manner.
Fortunately, \cite{abbott2003categories} introduced the notion of
containers to represent strictly positive types; their main insight is
that all strictly positive types can be expressed using containers.
A container is described as a product of shapes and a position function.
The shape is a type \cinl{S} and the position function \cinl{P} is a type
function that maps shapes to types.
Using these two components we can define a container extension that
gives rise to a functor.

\begin{minted}{coq}
Inductive Ext (Shape : Type) (Pos : Shape -> Type) A :=
| ext : forall s, (Pos s -> A) -> Ext Pos A.
\end{minted}

A container extension \cinl{Ext S P} is then isomorphic to a functor
\cinl{F}.
Since we are mainly interested in monads, we can go even further and
use monadic containers as proposed by \citet{altenkirch2017monadic} and
\citet{uustalu2017partiality}.
However, we decided against using monadic containers directly, as
they, as far as we know, cannot be implemented in a constructive way,
but are an extension of \cinl{Ext} that are modelled using a type
class.

Taking one step back, let us recap again the pieces we have identified
so far.
Since we know that all monads have a constructor that represent
\emph{pure} values, the effect we want to model is actually
everything that we gain on top of these defined values.
We can define a data type to model this property more explicitly: we
either have a pure or an effectful value.

\begin{minted}{coq}
Fail Inductive Free F A :=
| pure   : A -> Free F A
| impure : F (Free F A) -> Free F A.
\end{minted}

This representation is known as free monad \citep{swierstra2008data}.
As the effect is once again represented by a type constructor
variable \cinl{F} that has the data type to be defined as argument,
Coq does not accept the definition.
Fortunately, the type parameter \cinl{F} needs to be functor in order
to make a \cinl{Free F} a monad.
Or to it put differently, given a functor \cinl{F} the free monad
construction lifts \cinl{F} to a monad.
Now we can apply the insight about representing strictly positive
types as containers again: since container extensions are isomorphic
to functors, there are a variety of functors that we can represent
using containers.
We can change the definition of \cinl{Free} as follows to fulfil Coq's
strict positivity requirement.

\begin{minted}{coq}
Inductive Free (Shape : Type) (Pos : Shape -> Type) A :=
| pure   : A -> Free Shape Pos A
| impure : Ext Shape Pos (Free Shape Pos A) -> Free Shape Pos A.
\end{minted}

Now we defined the free monad using the container extension instead of
a generic functor \cinl{F}, that is, we are still generic: not
over all possible type constructors but over all strictly positive
types.
Note, however, that we do not need the indirection using \cinl{Ext}
explicitly, we instead define \cinl{Free} by inlining the definition
of \cinl{Ext} in the constructor \cinl{impure} to make its usage more
convenient.

\begin{minted}{coq}
Inductive Free (Shape : Type) (Pos : Shape -> Type) A :=
| pure   : A -> Free Shape Pos A
| impure : forall s,  Pos s -> Free Shape Pos A -> Free Shape Pos A.
\end{minted}

With this definition of \cinl{Free} at hand we are well-suited to
define a lifted version of \cinl{List} as we wished to do at the
beginning of this section.

\begin{minted}{coq}
Inductive List (Shape : Type) (Pos : Shape -> Type) A :=
| nil : List Shape Pos A
| cons : Free Shape Pos A -> Free Shape Pos (List Pos A) -> List Shape Pos A.
\end{minted}

\paragraph{Representing Partiality using Free Monads and Containers}
\label{par:partiality_container}

In order to understand better how we can work with our lifted data
types based on \cinl{Free}, we will start with a representation of
partiality.
Let us take a look at how we can represent \cinl{partial} using
\cinl{Free}.
As already mentioned, we use free monads by applying a functor
\cinl{F} that describes the effect we want to model, i.e., the
additional constructs on top of pure values.
In case of \cinl{partial} the additional effect is the undefinedness
of values; hence, we need a type with one nullary constructor.
We use the same name for the used functor as \citet{swierstra2008data}
that captures the number of representable values quite well.

\begin{minted}{coq}
Inductive One (A : Type) :=
| one : One A.
\end{minted}

In case of our definition of \cinl{Free}, the functor was exchanged by
a container representation.
That is, we have to represent \cinl{One} as a container
describes as a type of shapes and a position type function.
The data type \cinl{One} has only one constructor, that is,
there is only one shape that we need to represent.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition One!$_\text{S}$! := unit.
\end{minted}

The position type function, on the other hand, describes the possible
positions of polymorphic arguments.
In case of \cinl{One} its constructors does not have any
polymorphic arguments, so we need to use the empty type.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition One!$_\text{P}$! (s : One!$_\text{S}$!) := Empty.
\end{minted}

Recall that the position type function depends on the corresponding
shape.
Here, however, the shape does not matter as we do not have any
position anyhow.

Using Coq's ability to prove properties about programs, we can show
that the container representation is isomorphic to the original data
type.
More precisely, we define two functions \cinl{from_One} and
\cinl{to_One}, and show that both compositions yield the
identity.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition from_One A (o : One A) : Ext One!$_\text{S}$! One!$_\text{P}$! A :=
  ext tt (fun (p : One!$_\text{P}$! tt) => match p with end).

Definition to_One A (e : Ext One!$_\text{S}$! One!$_\text{P}$! A) : One A :=
  one.

Lemma from_to_One : forall (A : Type) (e : Ext One!$_\text{S}$! One!$_\text{P}$! A),
    from_One (to_One e) = e.
Proof.
  intros A e.
  destruct e as [[] pf]; simpl.
  f_equal. extensionality p. destruct p.
Qed.

Lemma to_from_One : forall (A : Type) (o : One A),
    to_One (from_One o) = o.
Proof.
  intros A o.
  destruct o; reflexivity.
Qed.\end{minted}

Note that we need to use functional extensionality to compare the
position functions in the second argument of \cinl{ext} in Lemma
\cinl{from_to_One}.

Now we have the container that we want to use as to instantiate
\cinl{Free} with in place.
Next up, we can also show that the resulting \cinl{Free One__S One__P}
is isomorphic to the monadic structure \cinl{partial}.
First, we define the conversion functions \cinl{to_partial} and
\cinl{from_partial} analogues to the setup for \cinl{One} above.

\begin{minted}{coq}
Definition to_partial A (fx : Free One__S One__P A) : partial A :=
 match fx with
 | pure x     => defined x
 | impure _ _ => undefined
 end.

Definition from_partial A (p : partial A) : Free One__S One__P A :=
  match p with
  | undefined => let '(ext s pf) := from_One one in impure s pf
  | defined x => pure x
  end.
\end{minted}

Based on the conversion functions, we prove to lemmas that state that
the possible compositions of these functions is the identity.

\begin{minted}{coq}
Lemma from_to_partial : forall (A : Type) (fx : Free One__S One__P A),
    from_partial (to_partial fx) = fx.
Proof.
  intros A fx.
  destruct fx as [x | [] pf]; simpl.
  - reflexivity.
  - do 2 f_equal. extensionality p. destruct p.
Qed.

Lemma to_from_partial : forall (A : Type) (p : partial A),
    to_partial (from_partial p) = p.
Proof.
  intros A p.
  destruct p; reflexivity.
Qed.
\end{minted}

\paragraph{Representing Totality using Free Monads and Containers}
\label{par:totality_container}
In order to see a second effect, we find some inspiration by
\citet{abel2005verifying} who are interested in two effects:
partiality and totality.
Since we have already discussed partiality, we will now take a look at
how to model totality.
Totality describes the absence of any additional effects, we have pure
values only.
A suitable monad to represent totality is the identity monad; in order
to match our naming scheme used for partiality, we name the data type
\cinl{total}.

\begin{minted}{coq}
Inductive total (A : Type) :=
| totality : A -> total A.
\end{minted}

When using a free monad to represent \cinl{total}, we only need to
give a functor for the additional effect on top of pure values.
Since totality does not add any effects and describes pure values
only, we need to model this absence of effects with the functor.
In terms of defining values using \cinl{Free F} that represent total
values only, we only want to be able to use the
\cinl{pure}-constructor.
The \cinl{impure}-constructor, on the other hand, should not be
available, it should be impossible to construct a value using
\cinl{impure}.
That is, we need a functor without any constructors.
When an inductive type has no constructors, there is no way to
construct a value of that type.
Once again, we use the naming scheme as \citeauthor{swierstra2008data}
and define the type constructor \cinl{Zero} that has no values.

\begin{minted}{coq}
Inductive Zero (A : Type) := .
\end{minted}

Note that, in contrast to the \cinl{Empty} type, \cinl{Zero} is a type
constructor as it has an additional type parameter \cinl{A}.
Similar to the definition of \cinl{One}, we do not use this type
parameter.
A type variable that appears on the left-hand site of a definition but
is not used on the right-hand side is called a phantom type.\todo{cite}

In order to represent \cinl{Zero} as container, we once again need to
define the corresponding shape and position type function.
Since \cinl{Zero} has no constructors, it has no shapes and no
polymorphic values that we might want to access.
For both types we can reuse \cinl{Empty}.

\begin{minted}{coq}
Definition Zero__S := Empty.
Definition Zero__P (s : Zero__S) := Empty.
\end{minted}

For both conversion functions, \cinl{from_Zero} and \cinl{to_Zero},
the definition simply matches on the non-existent value to define a
function with the wanted type.

\begin{minted}{coq}
Definition from_Zero A (u : Zero A) : Ext Zero__S Zero__P A :=
  match u with end.

Definition to_Zero A (e : Ext Zero__S Zero__P A) : Zero A :=
  match e with
  | ext s pf => match s with end
  end.
\end{minted}

It is quite trivial to prove that the conversion functions form an
isomorphism as the following reasoning shows.

\begin{minted}{coq}
Lemma from_to_Zero : forall (A : Type) (e : Ext Zero__S Zero__P A),
    from_Zero (to_Zero e) = e.
Proof.
  intros A e.
  destruct e as [[] pf].
Qed.

Lemma to_from_Zero : forall (A : Type) (z : Zero A),
    to_Zero (from_Zero z) = z.
Proof.
  intros A z.
  destruct z.
Qed.
\end{minted}

The next step is to define the conversion functions \cinl{to_total}
and \cinl{from_total} to show that using
the container representation for \cinl{Zero} in combination with
\cinl{Free} yields the original monad \cinl{total} again.

\begin{minted}{coq}
Definition to_total A (fx : Free Zero__S Zero__P A) : total A :=
  match fx with
  | pure x   => totality x
  | impure (ext s _) => match s with end
  end.

Definition from_total A (t : total A) : Free Zero__S Zero__P A :=
  match t with
  | totality x => pure x
  end.
\end{minted}

\noindent
In fact, similar as for the case of the partiality monad we can even
show that the conversion functions form an isomorphism as well.

\begin{minted}{coq}
Lemma from_to_total : forall (A : Type) (fx : Free Zero__S Zero__P A),
    from_total (to_total fx) = fx.
Proof.
  intros A fx.
  destruct fx as [x | [] pf]; reflexivity.
Qed.

Lemma to_from_total : forall (A : Type) (t : total A),
    to_total (from_total t) = t.
Proof.
  intros A t.
  destruct t; reflexivity.
Qed.
\end{minted}

\paragraph{Other Containers and Limitations}

We will later see that monads like tree and list, which are usually
used when modelling non-determinism, can be represented using our
approach as well.
There also common monads from Haskell like writer or state that are
used to model tracing or I/O-interactions with the user, that have
corresponding effects that are interesting to reason about and
possible to model using \cinl{Free} and the suitable container
representation of the underlying effect.

Since we use container to ensure Coq that we do not define a
potentially non-strictly positive type, the class of strictly positive
types is the natural limitation when using our approach.
An example for a monad that we cannot represent with our approach is
the continuation monad.
If we recall the concrete instantiation that we used to understand the
problem when defining a monadically lifted version of \cinl{List},
this limitation should not come with a surprise.
The continuation monad \cinl{Cont} was an exemplary instantiation of
the type constructor variable \cinl{M}, such that \cinl{List} became
non-strictly positive.
The goal was to convince Coq that we won't use an instantiation like
\cinl{Cont}, so it makes sense that we indeed cannot define a data
type that is isomorphic to \cinl{Cont}. \todo{Is it?}
The other thing that we can observe is that the other monads we looked
at had at least two constructors, where one of them represents the
pure value.
With one representative for pure values as constructor, it was a
rather simple task to figure out how to represent only the additional
effect: we basically defined a data type with the remaining
constructors.
In case of \cinl{Cont}, there is not representative constructor for
pure values --- there are even no constructors at all, because
\cinl{Cont} is a function.\footnote{Strictly speaking, the definition
  for the continuation monad in Haskell is based on a \hinl{newtype}
  definition with exactly one constructor. This representation is due
  to the fact that we can only define an instance of a type classes
  for data types, not for type synonyms. Defining an instance of a type
synonym is only allowed when enabling the language extension
\hinl{TypeSynonymInstances}.}

In the end, we have to keep in mind that our approach using
\cinl{Free} as representative for a generic monadic parametrisation
can only represent monad that correspond to strictly positive types.

\subsection{Working with Free to Define Lifted Functions}

With the definition of \cinl{List} using \cinl{Free} to model generic
effectful lists at hand, we can take a look at the definition of the
function \cinl{append} again.
Analogous to the definition of \cinl{append} at the end of
\autoref{subsec:partial}, we need to split function into two parts:
one part works on pure \cinl{List}s in case of the demanded argument
while the second part handles \cinl{Free}-lifted arguments only.

For the remainder of this chapter, we will use \cinl{Free} and
data types like \cinl{List} as type constructors of kind \cinl{Type ->
  Type} when used with a generic container, that is, we do not pass
the corresponding shape and position function as argument.
Note, however, that this convention is a simplification for better
readability only and the resulting definition would not compile in

In order to compare the differences to our concrete representation
using \cinl{partial}, recall the definition of \cinl{append} and
\cinl{append'}, respectively.

\begin{minted}{coq}
Fixpoint appendP' (A : Type) (xs : List A) (oys : partial (List A))
  : partial (List A) :=
  match xs with
  | nil         => oys
  | cons oz ozs => Cons oz (match ozs with
                            | undefined    => undefined
                            | defined zs => appendP' zs oys
                            end)
  end.

Definition appendP (A : Type) (oxs oys : partial (List A)) : partial (List A) :=
  match oxs with
  | undefined  => undefined
  | defined xs => appendP' xs oys
  end.
\end{minted}

For a better readiblity, we added the suffix \cinl{P} for this version
of \cinl{append} that uses \cinl{partial}.
Let us now try to transfer the general idea of \cinl{appendP'} to
define a version using \cinl{Free}.
In the following we assume --- for convenience reasons only --- that
all functions are parametrised over variables \cinl{Shape} and
\cinl{Pos} of suitable type.
More particular, we will write types parametrised by these types, like
\cinl{Free} or \cinl{List}, without the type parameters when they are
polymorphic.

\begin{minted}{coq}
Fail Fixpoint append' A (xs : List A) (fys : Free (List A)) :=
 match xs with
 | nil => fys
 | cons fz fzs => Cons fz (match fzs with
                          | pure zs     => append' zs fys
                          | impure s pf => _ (* what to do here? *)
                          end)
 end.
\end{minted}

A case distinction on the concrete constuctors of \cinl{partial} was
quite simple, in the case of \cinl{Free} and its representation using
\cinl{Ext}, however, the second constructor \cinl{impure} has
recursive occurrences of values of type \cinl{Free}.
That is, a case distinction like in the definition of \cinl{appendP'}
needs to be defined as recursive function when using \cinl{Free}.

Recall that the basic idea is to model monadically lifted data types,
that is, \cinl{Free} is a representative for a monad.
The case distinction we are using in the definition of \cinl{appendP'} is
the monadic \emph{bind} function (\cinl{(>>=)}) in disguise.
Hence, we need to define bind for \cinl{Free} in order to transfer the
above definition successfully.

\begin{minted}{coq}
Fixpoint free_bind A B (fx : Free A) (f : A -> Free B) : Free B :=
 match fx with
 | pure x      => f x
 | impure s pf => impure s (fun p => free_bind (pf p) f)
 end.
\end{minted}

The definition of \cinl{free_bind} distinguishes between the two
possible constructors \cinl{pure} and \cinl{impure}; in the former
case we have a value \cinl{x} in place that \cinl{f} can be applied
to.
In the latter case we have variable bindings \cinl{s} and \cinl{pf}
for the shape and position function to work with.
Note that the position function applied to a position
yields a \cinl{Free}-value again, that is, \cinl{pf} has type
\cinl{Pos s -> Free A}.
The clou now is that we just need to reconstruct the effect that we
have seen, characterised by its shape \cinl{s}, and apply the function
\cinl{f} recursively for all recursive occurences of the effect that
we can access using the position function \cinl{pf}.

With the definition of \cinl{free_bind} at hand, we can go ahead and
start the second try to define \cinl{append'}: now we know that we need
to use \cinl{free_bind} instead of an explicit case distinction.

\begin{minted}{coq}
Fail Fixpoint append' A (xs : List A) (fys : Free (List A)) :=
  match xs with
  | nil => fys
  | cons fz fzs => pure (cons fz (free_bind fzs (fun zs => append' zs fys)))
  end.
\end{minted}

Unfortunately, the definition of \cinl{append'} is not accepted by
Coq, because it cannot guess the decreasing argument of the provided
fixpoint function.
More precisely, Coq gives the following error message when we
provide the information that the list \cinl{xs} is supposed to be the
decreasing argument.

\begin{quote}
\emph{Recursive call to append' has principal argument equal to "zs" instead of
"fzs".}
\end{quote}

What is the problem now?

\begin{excursus}{Definition of recursive, higher-order functions}

Once again Coq is not content with the way we define our programs.
In this case, the fault is not with \cinl{append}, but with the
definition of \cinl{free_bind}.
As a recursive, higher-order function that uses the same function as its
functional argument for each recursive call, we need to convince Coq
that the function indeed stays the same.
That way, Coq comprehends that the fact if the overall function
terminates does not depend on the function we pass as higher-order
argument.
That is, the problem is not specific to \cinl{free_bind} and our usage
of \cinl{Free}, but a general problem for recursive, higher-order
functions.
Consider, for example, the definition of \cinl{map} for ordinary
lists as well as a definition for rose trees.

\begin{minted}{coq}
Inductive List A :=
| Nil  : List A
| Cons : A -> List A -> List A.

Fixpoint map A B (f : A -> B) (xs : List A) : List B :=
 match xs with
 | Nil       => Nil
 | Cons x xs => Cons (f x) (map f xs)
 end.

Inductive Rose A :=
| Leaf     : A -> Rose A
| Branches : List (Rose A) -> Rose A.
\end{minted}

In order to now define a map-like function for \cinl{Rose} as well, we
might be tempted to just reuse the \cinl{map} functions for lists to
handle the \cinl{Branches}-constructor.

\begin{minted}{coq}
Fail Fixpoint mapRose A B (f : A -> B) (r : Rose A) : Rose B :=
 match r with
 | Leaf x      => Leaf (f x)
 | Branches rs => Branches (map (mapRose f) rs)
 end.
\end{minted}

However, Coq once again does not recognise that this definition of
\cinl{mapRose} terminates.
It arises the following error message.

\begin{quote}
\emph{Recursive call to mapRose has principal argument equal to "x" instead of "rs".}
 \end{quote}

Due to the usage of \cinl{map}, it is not clear for Coq's termination
checker that the recursive call of \cinl{mapRose} will eventually
terminate.
Fortunately, there is a simple scheme to convince Coq that the
function \cinl{map} is inductively recursive over its list argument
and, more importantly, the supplied function does not determine the
termination.
That is, \cinl{map} terminates independent of its functional argument.
Consider the following alternative definition of \cinl{map}.

\begin{minted}{coq}
Definition map A B (f : A -> B) (xs : List A) : List B :=
 let fix map' xs :=
     match xs with
     | Nil       => Nil
     | Cons x xs => Cons (f x) (map' xs)
     end in
 map' xs.
\end{minted}

Instead of declaring a recursive function on top-level using the
keyword \cinl{Fixpoint}, we declare a local fixpoint only.
In this case, the local recursive function \cinl{map'} has only one
parameter, name the list argument, and reuses the function \cinl{f}
that is passed to the top-level function \cinl{map}.
Due to the explicit fixpoint definition that does not have the
higher-order function as argument anymore, Coq's termination checker
can realise that the termination of \cinl{map} does not depend on the
function \cinl{f}.

An alternative, but equivalent definition, uses section variables to
introduce the type parameters and the higher-order argument.

\begin{minted}{coq}
Section map.

 Variable A B : Type.
 Variable f : A -> B.

 Fixpoint map (xs : List A) : List B :=
   match xs with
   | Nil       => Nil
   | Cons x xs => Cons (f x) (map xs)
   end.

End map.
\end{minted}

In fact, the code that Coq generates for the second version with
section variables is exactly the first implementation given above.

Whatever implementation version we chose, we can now use \cinl{map} to
define \cinl{mapRose} and Coq accepts the definition as terminating.

\begin{minted}{coq}
Fixpoint mapRose A B (f : A -> B) (r : Rose A) : Rose B :=
 match r with
 | Leaf x      => Leaf (f x)
 | Branches rs => Branches (map (mapRose f) rs)
 end.
\end{minted}
\end{excursus}

Now let us go back to our initial problem with the definition of
\cinl{append'} using the higher-order, polymorphic auxiliary function
\cinl{free_bind}.
The problem that arose for the definition of \cinl{append'} using
\cinl{free_bind} is analogous to the definition of \cinl{roseMap}
using \cinl{map}.
That is, we need an alternative implementation of \cinl{free_bind}
that follows the scheme above: the recursion of \cinl{Free} needs to
be explicitly independent of the functional argument.
We then end up with the following definition of \cinl{free_bind}.

\begin{minted}{coq}
Definition free_bind A B (f : A -> Free B) (fx : Free A) : Free B :=
 let fix free_bind' fx :=
     match fx with
     | pure x      => f x
     | impure s pf => impure s (fun p => free_bind' (pf p))
     end
     in free_bind' fx.
\end{minted}

In order to use \cinl{free_bind} as an operator \cinl{(>>=)} as known
from Haskell, we additionally define the following notation.

\begin{minted}{coq}
Notation "fx >>= f" := (free_bind f fx) (at level 40, left associativity).
\end{minted}

Last but not least, we are finally equipped to define the auxiliary
function \cinl{append'} as well as the final \cinl{append}-function
that is the generically lifted version of the corresponding Haskell
function.

\begin{minted}{coq}
Fixpoint append' A (xs : List A) (fys : Free (List A)) :=
  match xs with
  | nil => fys
  | cons fz fzs => pure (cons fz (fzs >>= fun zs => append' zs fys))
  end.

Definition append A (fxs fys : Free (List A)) : Free (List A) :=
  fxs >>= fun xs => append' xs fys.
\end{minted}

\section{Partiality as Effect to Model Haskell Programs}

While we discussed the overall infrastructure and necessary
preliminaries for a general framework to model non-strict effectful
programs, we will focus on two effects occurring in Haskel: totality
and partiality.
Of course, totality is, strictly speaking, not an effect, but the
absense of any effect, as we have already seen in the previous
section.
Nevertheless, in this section both instantiations are of interest to
motivate our effect-generic reasoning.
That is, we follow the idea of \citet{abel2005verifying} and prove
general propositions about Haskell functions in three steps: first, we
show that the proposition holds in the total setting and then show that it
also holds in the partial setting.
On top of these both proofs, the last step is to make the case for our
generic approach and show our framework allows to prove properties
once and for all for a whole class of effects.

\subsection{Three Proofs for the Associativity of Append}

Since it took as a whole section to define the function \cinl{append}
for an effect-generic \cinl{List} data types, it seems reasonable to
first prove a property for that function.
Thus, in this subsection we will focus on the associativity of append
and prove this proposition in the total, partial and generic setting.
Since we encounter proofs for lifted data types and functions for the
first time, we will present the proofs step-by-step.
We will, however, postpone technical details to the end of this
subsection.
Thus, we explain the details of the proof from a more abstract
perspective rather than diving deep into the technical details of the
used tactics.

\paragraph{Totality}
In order to refresh the memory, the definition of the
container to represent total programs shown in
\autoref{par:totality_container} looks as follows.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition Zero!$_\text{S}$! := Empty.
Definition Zero!$_\text{P}$! (s : Zero!$_\text{S}$!) := Empty.
\end{minted}

That is, the container representing totality has neither a position
nor a shape, thus, programs modeled as \cinl{Free Zero__S Zero__P} do
not have any \cinl{impure} values by construction.
Whenever we encounter an \cinl{impure}-constructor, we know that the
accompanying shape \cinl{s : Zero__S} cannot exist.
Let us now take a look at the associativity of append in the total
setting and see how we use this observation about the corresponding
container when proving a proposition.

\begin{minted}{coq}
Lemma append_assoc_total :
 forall (A : Type) (fxs fys fzs : Free Zero__S Zero__P (List Zero__S Zero__P A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 intros A fxs fys fzs.
 destruct fxs as [ xs | [ s pf ] ]; simpl.
 (* fxs = pure xs *)
\end{minted}

In order to evaluate \cinl{append}, we make a case distinction on the
first list argument \cinl{fxs}.
In case of a pure value, we have the following goal and assumptions.

\begin{minted}{coq}
  A : Type
  xs : List Zero__S Zero__P A
  fys, fzs : Free Zero__S Zero__P (List Zero__S Zero__P A)
  ============================
  append' xs (append fys fzs) = append (append' xs fys) fzs
\end{minted}

Now we can proceed as if we were working with ordinary list: we need
to do induction on the \cinl{List} argument \cinl{xs}.

\begin{minted}{coq}
 - induction xs as [ | fx fxs IH ]; simpl.
   (* xs = nil *)
   + reflexivity.
\end{minted}
 
We then need to prove the proposition for \cinl{nil} and \cinl{cons}.
The former is trivial as both sides of the terms are already equal.
For the latter case, the goal looks as follows.

\begin{minted}{coq}
  A : Type
  fx : Free Zero__S Zero__P A
  fxs, fys, fzs : Free Zero__S Zero__P (List Zero__S Zero__P A)
  IH : ForFree (fun xs => append' xs (append fys fzs)
                        = append (append' xs fys) fzs) fxs
  ============================
  Cons fx (fxs >>= (fun zs => append' zs (append fys fzs)))) =
  Cons fx (fxs >>= (fun zs => append' zs fys) >>= (fun zs => append' zs fzs)))
\end{minted}

We proceed by stripping away the \cinl{Cons}-constructor and take
another look at \cinl{fxs} by destructing the induction hypothesis
\cinl{IH}, which produces to cases: one for \cinl{pure} and one for
\cinl{impure}.

\begin{minted}{coq}
   (* xs = cons fx fxs; induction hypothesis IH *)
   + do 2 f_equal.
     destruct IH as [ xs H | ]; simpl.
     * rewrite H. reflexivity.
     * contradiction.
\end{minted}

In the former case, the induction hypothesis brings our current goal
in the right form such that we can finish the subproof easily using
\cinl{reflexivity}.
For the latter case we only need to focus on one of the assumptions,
namely, \cinl{s : Zero__S}.

\begin{minted}{coq}
  ...
  s : Zero__S
  ...
  ============================
  ...
\end{minted}

Since there cannot exist any value of type \cinl{Zero__S}, the subgoal
is trivially true as one of the assumptions is a contradiction.
There are several to actually finish the proof, here we use
\cinl{contradiction}, we could also use \cinl{destruct s} in order to
force Coq to produce subgoals for all constructors.
As no constructors exist, there are no more subgoals and we have
successfully proven the current goal.

The same reasoning applies for the last open goal.
We started with a case distinction on the original first list
arguments \cinl{fxs} and are now in the \cinl{impure}-case.

\begin{minted}{coq}
  A : Type
  s : Zero__S
  pf : Zero__P s -> Free Zero__S Zero__P (List Zero__S Zero__P A)
  fys, fzs : Free Zero__S Zero__P (List Zero__S Zero__P A)
  ============================
  impure s (fun p : Zero__P s => append (pf p) (append fys fzs)) =
  impure s (fun p : Zero__P s => append (append (pf p) fys) fzs)
\end{minted}

The assumption \cinl{s : Zero__S} is once again a bogus assumptions,
so we clear the last remaining goal by using \cinl{contradiction} again.

\begin{minted}{coq}
  (* fxs = impure s pf *)
  - contradiction.
Qed.
\end{minted}

Now that we have successfully proven this statement, we will take a
second look at the complete proof script, without the additional
remarks and assumptions.
We improved the scripts a little bit and moved the
\cinl{contradiction} tactic directly after destructing the
\cinl{Free}-values, to finish the second subgoal immediately.
Alternatively, we could use a nested introduction pattern for
\cinl{s} as well and destruct it directly using the pattern \cinl{[]}.
Then, the additional cases for \cinl{impure} would not be generated at
all.

\begin{minted}{coq}
Lemma append_assoc_total :
 forall (A : Type) (fxs fys fzs : Free Zero__S Zero__P (List Zero__S Zero__P A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 intros A fxs fys fzs.
 destruct fxs as [ xs | [ s pf ] ]; try contradiction; simpl.
 - (* fxs = pure xs *) induction xs as [ | fx fxs IH ]; simpl.
   + (* xs = nil *) reflexivity.
   + (* xs = cons fx fxs; induction hypothesis IH *)
     do 2 f_equal. destruct IH as [ xs H | ]; try contradiction; simpl;
     * (* fxs = pure xs *) rewrite H. reflexivity.
Qed.
\end{minted}

The main difference between the above proof and a proof for
associativity of the append function ordinary lists is the unboxing of
the additional \cinl{Free}-layer of the list argument.

\paragraph{Partiality}
As next step, we consider an actual effect: partiality.
Again, we recall the definition of the container to represent partiality
when using \cinl{Free} as introduced in
\autoref{par:partial_container}.

\begin{minted}[escapeinside=!!,mathescape=true]{coq}
Definition One!$_\text{S}$! := unit.
Definition One!$_\text{P}$! (s : One!$_\text{S}$!) := Empty.
\end{minted}

This time, the corresponding container has one possible shape, but no
positions.
The additional effect of representing undefined values does not
contain any recursive occurence of the \cinl{Free} values, thus, the
effect does not have any polymorphic components in its constructors.

Let us take look at the proof for the associativity of append; we
focus on the differences, as most of the proof is actually the same.
Hence, this time we show the entire proof script first and take a
closer look at some subgoals afterwards.

\begin{minted}{coq}
Lemma append_assoc_partial :
 forall (A : Type) (fxs fys fzs : Free One__S One__P (List One__S One__P A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 intros A fxs fys fzs.
 destruct fxs as [ xs | [ s pf ] ]; simpl.
 - (* fxs = pure xs *) induction xs as [ | fx fxs IH ]; simpl.
   + (* xs = nil *) reflexivity.
   + (* xs = cons fx fxs; induction hypothesis IH *)
     do 2 f_equal. destruct IH as [ xs | s pf ]; simpl.
     * (* fxs = pure xs *) rewrite H. reflexivity.
     * (* fxs = impure s pf *)
       do 2 f_equal. extensionality p. contradiction.
  - (* fxs = impure s pf *)
    do 2 f_equal. extensionality p. contradiction.
Qed.
\end{minted}

We observe that both cases of \cinl{impure}-values, we do not have a
contradiction in place as we had in the total setting.
The contradiction in the total setting was introduced by the shape of
the container that did not have any constructors.
Now, we are working with \cinl{One__S}, which is a renaming for the
\cinl{unit} type and has exactly one constructor, namely \cinl{tt}.
We can, however, finish the \cinl{impure}-cases using
\cinl{contradiction} again, but we need to have a position as an
assumption.
The position is introduced as assumption when we strip away the prefix
of \cinl{impure s pf} on both sides of the equation, such that
only the position functions \cinl{pf} remain to be proven equivalent.

The initial situation for the first \cinl{impure}-case looks as
follows.

\begin{minted}{coq}
  ...
  s : One__S
  ============================
  impure s (fun p => ...) =
  impure s (fun p => ...)
\end{minted}

As mentioned above, after stripping away the prefix both expressions
have in common, we end up with two functions that we need to prove
equal.
We introduce the function argument \cinl{p} using \cinl{extensionality
  p} and end up with \cinl{p : One__P s} added to the assumptions and a changed
goal as follows.

\begin{minted}{coq}
  s : One__S
  p : One__P s
  ============================
  pf p >>= (fun zs => append' zs (append fys fzs)) =
  pf p >>= (fun zs => append' zs fys) >>= (fun zs => append' zs fzs)
\end{minted}

With \cinl{One__P s} being a renaming for \cinl{Empty}, the position
\cinl{p} has no constructors and we can finish the proof using
\cinl{contradiction}, again.

We follow the same approach to finish the second \cinl{impure}-case.

\paragraph{Generic Effect}
Last but not least, we take a look at a generic proof for the
associativity of append.

\begin{minted}{coq}
Lemma append_assoc_generic :
 forall (Sh : Type) (Ps : Sh -> Type) (A : Type)
   (fxs fys fzs : Free Sh Ps (List Sh Ps A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
intros Sh Ps A fxs fys fzs.
\end{minted}

Instead of introducing components of a concrete container, the shape
\cinl{Sh} and position function \cinl{Ps} are all-quantified.

The main difference to the concrete proofs above is that in case of a
generic effect, we cannot hope to have a false assumption, like a
value of type \cinl{Empty}, in place to finish the
\cinl{impure}-cases.
Considering a generic effect has the consequence that we need to
consider all possible instantiations.
In particular, using the effect in combination with \cinl{Free} might
lead to a recursive occurrence, that is, the effect might have a
polymorphic argument.

By means of proving the proposition, this observation leads to the
consequence that a simple case distinction over the \cinl{Free}-value
\cinl{fxs} is not enough, we need to proceed by induction over
\cinl{fxs}.

\begin{minted}{coq}
 induction fxs as [ xs | s pf IH ]; simpl.
 - (* fxs = pure xs *) induction xs as [ | fx fxs IH ]; simpl.
   + (* xs = nil *) reflexivity.
   + (* xs = cons fx fxs *) do 2 f_equal.
     induction IH as [ xs H | s pf _ IH' ]; simpl.
     * (* fxs = pure xs *) rewrite H. reflexivity.
     * (* fxs = impure s pf *) do 2 f_equal. extensionality p.
       apply IH'.
\end{minted}

The \cinl{pure}-case stays basically the same, the difference, once
again, lies in the nested \cinl{impure}-case.

\begin{minted}{coq}
  ...
  s : Sh
  IH' : forall p : Ps s,
        pf p >>= (fun zs => append' zs (append fys fzs)) =
        pf p >>= (fun zs => append' zs fys) >>= (fun zs => append' zs fzs)
  p : Ps s
  ============================
  pf p >>= (fun zs => append' zs (append fys fzs)) =
  pf p >>= (fun zs => append' zs fys) >>= (fun zs => append' zs fzs)
\end{minted}

Here, we cannot prove the subgoal by contradiction but need to
actually use the induction hypothesis \cinl{IH'} generated by
\cinl{induction IH}.

A similar situation appears for the second \cinl{impure}-case that
originated from the initial induction on \cinl{fxs}.
\begin{minted}{coq}
  IH : forall p : Ps s,
       append (pf p) (append fys fzs) = append (append (pf p) fys) fzs
  ============================
  impure s (fun p : Ps s => append (pf p) (append fys fzs)) =
  impure s (fun p : Ps s => append (append (pf p) fys) fzs)
\end{minted}

In this case, the induction hypothesis is directly applicable when
proving the functions equal.
This last subgoal then finishes the proof.

\begin{minted}{coq}
 - (* fxs = impure s pf *) do 2 f_equal. extensionality p.
   apply IH.
Qed.
\end{minted}

\paragraph{The Generic Proof Owns them All}

Now comes the best part.
The generic proof is applicable for the concrete proofs in the total
and partial setting as well.
That is, instead of proving the proposition for all concrete effects
again and again, as necessary in the approach introduced by
\citet{abel2005verifying}, we prove the proposition once and for all.

Of course, if we want to prove a property in a concrete setting, we
can still reuse the generic propositions as the following alternative
proofs for the concrete settings of totality and partiality
illustrate.

\begin{minted}{coq}
Lemma append_assoc_total' :
 forall (A : Type) (fxs fys fzs : Free Zero__S Zero__P (List Zero__S Zero__P A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 apply append_assoc_generic.
Qed.

Lemma append_assoc_partial' :
 forall (A : Type) (fxs fys fzs : Free One__S One__P (List One__S One__P A)),
   append fxs (append fys fzs) = append (append fxs fys) fzs.
Proof.
 apply append_assoc_generic.
Qed.
\end{minted}

\subsection{Induction Principle}

In the preceding section we proved associativity of append using
induction on the first list.
The \cinl{induction} tactic in Coq on an expression triggers the
associated induction principle for the corresponding type.
An induction principle is a proposition with a special
purpose.
Hence, the induction principle for a data type is an ordinary function
in Coq.
Moreover, Coq automatically generates this induction principle for
each data type declaration using \cinl{Inductive}.
The induction principle for a inductive type \cinl{T} is available as
function named \cinl{T_ind}.

\paragraph{Induction on Peano Numbers}
Let us take a look at an example: the induction principle for Peano
numbers \cinl{nat}.

\begin{minted}{coq}
nat_ind : forall P : nat -> Prop,
 P 0 ->
 (forall n : nat, P n -> P (S n)) ->
 forall n : nat, P n
\end{minted}

Dissecting this type signatures gives us the following parts: given a
proposition \cinl{P} on Peano Numbers, we need to supply two proofs,
one in case of \cinl{0} and one in case of \cinl{S n}, where \cinl{n}
is universally quantified.
The first proof is the base case of the induction principles for Peano
numbers, while the second proof is the inductive case.
That is, in the second proof we assume that the proposition already
holds for an arbitrary but fixed \cinl{n} and can then prove that the
proposition also holds for \cinl{S n}.

As an example, we prove that doubling a Peano numbers always yields an
even number.
We define the following functions \cinl{even} and {double}.

\begin{minted}{coq}
  Fixpoint even (n : nat) : bool :=
    match n with
    | 0   => true
    | S 0 => false
    | S (S n) => even n
    end.

  Definition double (n : nat) : nat :=
    n * 2.
\end{minted}

 Based on these functions, we now prove the proposition by induction
 on \cinl{n}.

\begin{minted}{coq}
Lemma even_double : forall (n : nat),
   even (double n) = true.
Proof.
 intros n. induction n as [ | n' IH ]; simpl.
 - reflexivity.
 - apply IH.
Qed.
\end{minted}

There is nothing spectacular happing in this proof.
Using the induction principle directly, the above proof translated to
the following code.

\begin{minted}{coq}
Lemma even_double' : forall (n : nat),
   even (double n) = true.
Proof.
 apply nat_ind.
 - reflexivity.
 - intros n IH. apply IH.
Qed.
\end{minted}

When using backward-reasoning, we have to use the function
\cinl{nat_ind} on a function of type \cinl{n -> P  n}, which is
exactly the type of our lemma.
Since \cinl{nat_ind} has three arguments, these arguments are now the
new subgoals we need to prove.
One of these arguments is the proposition \cinl{P} that automatically
proven because it can be inferred from the goal we apply the function
to.
That is, we end up with only two subgoals: we need to prove that the
proposition holds for \cinl{0} and for \cinl{S n}.
The first goal simplifies to \cinl{even 0 = true}, which is just the
definition of \cinl{even}.
The second goal looks as follows.

\begin{minted}{coq}
  ============================
  forall n : nat, even (double n) = true -> even (double (S n)) = true
\end{minted}

Given a Peano number \cinl{n} and the induction hypothesis that the
proposition already holds for that \cinl{n}, we need to prove that
proposition holds for \cinl{S n} as well.
While Coq's \cinl{induction} tactic introduces these universally
quantified for us, the direct variant is not as comfortable.
That is, we need to introduce these variables ourselves, but can then
prove the goal using the induction hypothesis like in the first
variant.

\paragraph{Induction on Free and List}

Since our proofs depend on induction on values of type \cinl{Free}, we
will now consider the corresponding induction principle that Coq
generates.

\begin{minted}{coq}
Free_ind : forall (Sh: Type) (Pos : Sh -> Type) A (P : Free A -> Prop),
   (forall x : A, P (pure x)) ->
   (forall (s : Sh) (pf : Pos s -> Free A),
     (forall p : Pos s, P (pf p)) -> P (impure s pf)) ->
   forall fx : Free A, P fx
\end{minted}

For the base case we need to show that a given predicate \cinl{P}
holds for \cinl{pure x} for all \cinl{x : A}.
The \cinl{impure} case is a bit more interesting: given a shape
\cinl{s} and a position function \cinl{pf}, we need to prove that the
predicate holds for \cinl{impure s pf} with an additional induction
hypothesis in place.
The hypothesis states that for all possible positions \cinl{p} the
predicate already holds for all recursive values we can access using
the position function \cinl{pf}.
Note that these arguments correspond to the variables introduced in
the patterns when using the \cinl{induction} tactic.

\begin{minted}{coq}
induction fx as [ x | s pf IH ].
\end{minted}

The variable \cinl{xs} in the left branch of the introduction pattern
corresponds to the pure value, while \cinl{s} \cinl{pf} are the
arguments of the \cinl{impure} constructor and \cinl{IH} is the
generated induction hypothesis.

In case of data types that contain arguments of type \cinl{Free} due
to the lifting of the constructors, the induction principle generated
by Coq is not strong enough to fulfil its purpose.
Consider, for example, the induction principle Coq generates for the
\cinl{List} data type defined in \autoref{subsec:freeAndContainers}.

\begin{minted}{coq}
List_ind : forall (Sh : Type) (Pos : Sh -> Type) A (P : List A -> Prop),
      P nil ->
      (forall (fx : Free A) (fxs : Free (List A)), P (cons fx fxs)) ->
      forall l : List Pos A, P l
\end{minted}

While the base case for \cinl{nil} looks fine, the generated function
for the \cinl{cons} constructor looks a bit odd.
More precisely, the second function misses an induction hypothesis for
the list \cinl{fxs}; without such a hypothesis at hand, there are not
much propositions that we would be able to prove.
Fortunately, we can define a custom induction principle for
\cinl{List} and other data types that we might define.
Since an induction principle is an ordinary proposition, that is,
function of type \cinl{Prop}, we just need to implement a function of
the right type.
By enabling some options\footnote{\cinl{Unset Elimination Schemes.}},
we deactivate the automatic generation and define the custom induction
principle named \cinl{List_ind}.
That way, we can use \cinl{induction} as usual the tactic always
applies the \cinl{_ind}-function of the corresponding type.

First of all, we declare the types and the functions we want to use in
the induction principle.

\begin{minted}{coq}
Variable A : Type.
Variable P : List A -> Prop.

Hypothesis nilP : P nil.
Hypothesis consP : forall fx fxs, ?IH -> P (cons fx fxs).
\end{minted}

In order to specify the missing induction hypothesis in case of
\cinl{cons}, we need to work out how this hypothesis looks like in the
lifted case.
When we consider ordinary lists, we demand that the predicate holds
for a list \cinl{fxs} in order to prove that it also holds for the list
\cinl{cons fx fxs} for an arbitrary \cinl{fx} of appropriate type as
well.
In case of a lifted list, the predicate is supposed to hold for all
pure and effectful lists.
The needed property is similar to stating that a predicate of type
\cinl{A -> Prop} should hold for all elements of a list-like
structure.
In our case the list-like structure is the \cinl{Free} wrapper coming
with its two constructors \cinl{pure} and \cinl{impure}.
We define an auxiliary proposition \cinl{ForFree} that states when a
predicate of type \cinl{A -> Prop} holds for all elements occurring in
a value wrapped using \cinl{Free}.

\begin{minted}{coq}
Inductive ForFree (P : A -> Prop) : Free A -> Prop :=
| forPure   : forall x   , P x -> ForFree P (pure x)
| forImpure : forall s pf,
    (forall p, ForFree P (pf p)) -> ForFree P (impure s pf).
\end{minted}

In case of \cinl{pure x} we can directly apply the predicate on the
element \cinl{x}.
The \cinl{impure} constructor, on the other hand, embeds values of
type \cinl{Free A}, again, thus, we can apply the overall proposition
\cinl{ForFree} recursively.
We access the values of type \cinl{Free A} by applying the position
function to all valid positions with respect to the used container.
That is, the predicate holds for \cinl{impure s pf} if it already if
\cinl{ForFree P} already holds for all elements that can be accessed
using the position function.

Now we use the proposition \cinl{ForFree} to redeclare the necessary
induction hypothesis in case of the \cinl{cons} constructor.

\begin{minted}{coq}
Hypothesis consP : forall fx fxs, ForFree P fxs -> P (cons fx fxs).
\end{minted}

Note that the predicate \cinl{P} is of type \cinl{List A -> Prop},
that is, it is a predicate on lists.
Based on these hypothesis we define our custom induction principle by
implementing a function with the following type signature.

\begin{minted}{coq}
Fixpoint List_ind (xs : List A) : P xs.
\end{minted}

\noindent%
Due to the declared hypothesis the goal and associated assumptions
looks as follows.

\begin{minted}{coq}
  A : Type
  P : List A -> Prop
  nilP : P nil
  consP : forall (fx : Free A) (fxs : Free (List A)),
    ForFree P fxs -> P (cons fx fxs)
  List_ind : forall xs : List A, P xs
  xs : List A
  ============================
  P xs
\end{minted}

In order to show that the predicate \cinl{P} holds for the list
\cinl{xs}, we make a case distinction using the tactic \cinl{destruct
  xs as [ | fy fys ]}.
The case distinction leads to the following two subgoals.

\begin{minted}{coq}
  ...
  nilP : P nil
  ============================
  P nil

  ...
  consP : forall (fx : Free A) (fxs : Free (List A)),
    ForFree P fxs -> P (cons fx fxs)
  List_ind : forall xs : List A, P xs
  fy : Free A
  fys : Free  (List A)
  ============================
  P (cons fy fys)
\end{minted}

We finish the first subgoal by applying the hypotheses \cinl{apply
  nilP}; for the second goal we proceed by applying the hypothesis
\cinl{consP}.
The new subgoal is not the precondition of the hypothesis
\cinl{consP}, namely \cinl{ForFree P fys}.
We proceed by induction on \cinl{fys} since the proposition
\cinl{ForFree} is an inductively defined proposition with constructors
in case of \cinl{pure} and \cinl{impure} values.
Applying the tactic \cinl{induction fys as [ ys | s pf IH ]} yields
two new subgoals.

\begin{minted}{coq}
  ...
  List_ind : forall xs : List A, P xs
  ys : List A
  ============================
  ForFree P (pure ys)

  ...
  IH : forall (p : Ps s), ForFree P (pf p)
  ============================
  ForFree P (impure s pf)
\end{minted}

In both cases we apply the corresponding constructor of the
proposition \cinl{ForFree}, namely, \cinl{forPure} and
\cinl{forImpure}.

\begin{minted}{coq}
  ...
  List_ind : forall xs : List A, P xs
  ============================
  P ys

  ...
  IH : forall (p : Ps s), ForFree P (pf p)
  ============================
  forall p : Ps s, ForFree P (pf p)
\end{minted}

We finish both subgoals by simply applying the appropriate assumption.
In the first case we apply the recursive function \cinl{List_ind} that
we are currently defining.
In the \cinl{impure} case we use the induction hypothesis generated
for \cinl{Free}.
The complete proof script is finalised by using \cinl{Defined} and
looks as follows.

\begin{minted}{coq}
Fixpoint List_ind (xs : List Sh Ps A) : P xs.
 destruct xs as [ | fy fys ].
 - apply nilP.
 - apply consP.
   induction fys as [ ys | s pf IH ].
   + apply forPure.
     apply List_ind.
   + apply forImpure.
     apply IH.
Defined.
\end{minted}

Note that the difference between \cinl{Defined} and \cinl{Qed} to
finalise a proof influences the visibility (mostly called
\emph{opacity}) of the associated function.
As the difference is rather technical, let us rely on the description
by \cite{chlipala2011certified}.

\begin{quote}
We end the "proof" with \cinl{Defined} instead of \cinl{Qed}, so that
the definition we constructed remains visible.
This contrasts to the case of ending a proof with \cinl{Qed}, where
the details of the proof are hidden afterward.
(More formally, \cinl{Defined} marks an identifier as transparent,
allowing it to be unfolded; while \cinl{Qed} marks an identifier as
opaque, preventing unfolding.)
\end{quote}

Alternatively, we can define the induction principle as function
definition directly.
In that case, instead of using induction on \cinl{Free}, we need a
recursive helper function \cinl{free_ind} to work as induction
hypothesis in case of \cinl{impure} values.

\begin{minted}{coq}
Fixpoint List_ind (xs : List A) : P xs :=
 match xs with
 | nil         => nilP
 | cons fy fys =>
   consP fy (let fix free_ind (fxs : Free (List A)) : ForFree P fxs :=
                 match fxs with
                 | pure xs => forPure P xs (List_ind xs)
                 | impure s pf => forImpure (fun p => free_ind (pf p))
                 end in free_ind fys)
 end.
\end{minted}

Note that the preceding sections used this definition of
\cinl{List_ind} whenever we used the tactic \cinl{induction} on list
value.
Hence, using introduction pattern \cinl{[ | fy fys IH ]} corresponds
to the arguments of the \cinl{cons} constructor and the induction
hypothesis of type \cinl{ForFree}.

\subsection{A Little Case Study on Something}

\section{First Ideas to Model Curry Programs}

In this section we want to take a look at how to model the functional
logic language Curry.
As we have seen in previous chapters Curry combines the functional
programming paradigm with concepts known from logic programming.
More precisely, Curry combines non-strictness and non-determinism
leading to a call-time-choice semantics.
The approach we illustrated in the first sections enables to reason
about non-strict functional programs.
The difference that we want to illuminate in this section is that
sharing expression via let-bindings in a model of Haskell with
\hinl{undefined} values is an optimisation only, but cannot be
observed by the programmer.
In Curry, on the other side, we can observe the difference between
sharing a non-deterministic computation that is evaluated once and
duplicating non-deterministic computations due to Curry's call-time
choice semantics.

Before we dive deep into a potential implementation of call-time
choice, we first model Curry's non-determinism effect using
\cinl{Free}.
Based on this implementation, we discuss why the models cannot express
call-time choice and possible ideas to implement the intended semantics.

There are two aspects we want to note here.

First, the ideas we illustrate to model call-time choice can be used
to incorporate sharing for other effects as well.
For instance, a common extension of Haskell is the function
\hinl{trace} that enables to track information of type \hinl{String}
while evaluating a program.
The effect of tracing results in an observable difference between
sharing and duplicating an effectful expression.
Hence, we need a similar technique for more involved effects than we
have seen so far.

Second, the ideas about how to model sharing are still
work-in-progress.
That is, we illustrate the motivation only and then reference related work that
tackle similar problems and we think is applicable for our problem.

\subsection{Non-Determinism as Effect}
\subsection{Sharing as Effect}

\section{Related Work}
\section{Conclusion and Future Work}

\section{Final Remarks}
