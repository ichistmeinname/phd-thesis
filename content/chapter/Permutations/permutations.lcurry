%if False

> import qualified Findall as FA

%endif

The most prominent use of non-determinism in combination with sorting is permutation sort: a sorting algorithm that generates all permutations and selects the one that is sorted to yield as result.
This sorting function has a bad running time: the best case performs in $O(2^n)$ for an input list of length $n$.
On the good side, we can argue that the worst case is as good as the best case.
However, the best case is also as bad as the worst case.

In this chapter we shed some light on a different combination of sorting functions and non-determinism: we enumerate permutations by applying sorting functions to a non-deterministic comparison function.
First, we take a look at implementations of some famous sorting functions in Curry and define a suitable comparison function to enumerate permutations.
Thanks to Curry's built-in non-determinism, we can reuse all common sorting functions as they are.
We discuss the resulting permutation enumeration functions; the number of results is of special interest here.
A selection of questions that we will answer reads as follows.

\begin{itemize}
\item Can we enumerate all possible permutations of the input list using any sorting function?
\item Is there a sorting function that can enumerate exactly the permutations of the input list?
\item Can we visualise how a sorting function enumerates the permutations?
\end{itemize}

As a quick teaser for these questions, we anticipate that all (correct) sorting functions indeed enumerate every permutation of the input list at least once. However, enumerating every permutation exactly once is a property that not all sorting functions share.

In the second part of this chapter we transfer our implementation in Curry to Haskell.
One possible model of non-determinism in a functional language is to use lists to represent all non-deterministic results as we discussed in \autoref{subsec:monadicAbstractions}.
We go even one step further and generalise all functions to monadic functions and use a more specialised version of monads that have an additional \hinl{mplus} function that is especially suitable for non-determinism.
Using these monadically lifted functions, we are interested in a multi-set model of non-determinism using lists.
We compare the monadic representation of non-determinism with the built-in non-determinism of Curry by means of these sorting functions to enumerate permutations.

The main observation of the comparison is that Curry's built-in non-determinism can be less strict than a naive monadic model in Haskell.
This observation is not new, there are other applications that exploit this advantage as well.
Using non-determinism to transform sorting functions into permutation functions is an interesting use case of this advantage nonetheless.

%if False
Last but not least, we leverage the monadic implementation of the sorting functions to discuss possibilities to get rid of duplicates when enumerating permutations.
The main idea here is to enhance the underlying monad to track the decisions the non-deterministic comparison function makes when traversing the input list.
%endif

In summary, this chapter makes the following contributions.

\begin{itemize}
\item We inspect sorting functions implemented in Curry and apply these functions to a non-deterministic comparison function and a given list to enumerate permutations of that given list.
\item When taking a closer look at the resulting lists, we observe that the functions enumerate every possible permutation of the input list at least once.
\item Some sorting functions yield duplicate results. We investigate why these duplicates emerge.
\item Furthermore, we discover that some sorting functions even enumerate lists that are not a permutation of the input list.
\item As a second step, we transfer the sorting functions to Haskell and model non-determinism explicitly using monads.
\item We investigate the difference between Curry's non-determinism and the list-based model in Haskell for the resulting permutation enumeration functions
%if False
\item Thanks to the flexibility of using monads, we can enrich the non-deterministic comparison function which necessary properties to eliminate duplicate results. We show three examples for properties that yield to an enumeration of the exact number of permutations for sorting functions that yield too many results with a simple non-deterministic comparison function.
%endif
\item At last, we discuss a variety of questions that follow from the results and observations presented above.
\end{itemize}

\section{Non-deterministic Sorting Functions in Curry}
\label{sec:NDCurry}

We start this chapter with an overview of common sorting functions, which we implement using a version that is parametrised by a comparison function.
The main quest of this section is to document the behavior of these sorting functions when applied to a particular comparison function.
Hereunto, consider the following non-deterministic comparison function that ignores both its arguments and non-deterministically yields \cyinl{True} and \cyinl{False}.

%if False

> coinCmp :: a -> a -> Bool
> coinCmp _ _ = True ? False

%endif

\begin{curry}
coinCmp :: a -> a -> Bool
coinCmp _ _ = True ? False
\end{curry}

The name \cyinl{coinCmp} suggests a similarity to the popular \cyinl{coin} definition as an example for non-determinism; the difference here is that we define a binary function with a non-deterministic result, whereas \cyinl{coin} is a nullary function.

In the remainder of this section we will apply all sorting functions to the non-deterministic comparison function \cyinl{coinCmp}.
We can already anticipate here that the non-determinism introduced by \cyinl{coinCmp} will transform the sorting functions with resulting list type \cyinl{[a]} to functions that produce several lists non-deterministically.
That is, the non-determinism of \cyinl{coinCmp} propagates to the result.

The interesting thing about using these sorting functions with a non-deterministic comparison function like \cyinl{coinCmp} is that we expect that each permutation of the input list is part of the resulting lists.
Why is it reasonable to expect to see all permutations?
We expect the original sorting function, say \cyinl{sort :: (Int -> Int -> Bool) -> [Int] -> [Int]}, to actually sort a list in ascending order when we apply it to the comparison function \cyinl{(<=)}.
If \cyinl{sort (<=)} is indeed such a sorting function, then every permutation of a sorted list \cyinl{[1..n]} of length $n$ can be sorted by \cyinl{sort (<=)}.
That is, there are decisions of \cyinl{(<=)} that result in a sorted list.
If we apply \cyinl{sort coinCmp} to a list, then \cyinl{coinCmp} tries every possible decision when comparing two elements.
Hence, there is a sequence of decisions that leads to a specific permutation of the input list.
As we are trying every possible decision, we expect all possible permutations to be part of the result.
Otherwise, if a specific permutation is not part of the result, we can deduce that \cyinl{sort (<=)} does not correctly sort this permutation.

In the following all of our examples use lists of integer, more particular, we use lists of the shape \cyinl{[1..n]} with $n$ as length of the list.
These integers are only meant to be placeholders for concrete values and represent the position of the element within the original list.
That is, when we produce permutations of the input list, we can deduce the behaviour for a variety of input lists of other types, because we know where elements end up in the result based on their position in the input list.
Moreover, when we describe how a function produces its results, we use \emph{less than or equal} with respect to the comparison function in question, that is, not every usage of \emph{less than or equal} refers to the natural order on integer values $\leq$.
For example, we will use the same terminology when describing the behaviour of the non-deterministic predicate \cyinl{coinCmp}.
We think, however, these descriptions are easier to read when we use \emph{less than or equal} as an overloaded relation.

\subsection{Insertion Sort}
\label{subs:insertion}
The first sorting function we take a look at is insertion sort.
The key idea behind the sorting algorithm is to traverse the input list and insert each element in the right position within the resulting list.
That is, the element in focus is inserted in front of the first element of the list that is greater than or equal to the former.
In order to implement \cyinl{insertionSort}, we implement a function \cyinl{insert} first that does exactly that task: it inserts an element in a list with respect to the given comparison function.

%if False

> insert :: (a -> a -> Bool) -> a -> [a] -> [a]
> insert _ x []                 = [x]
> insert p x (y:ys) | p x y     = x:y:ys
>                   | otherwise = y : insert p x ys

%endif

\begin{curry}
insert :: (a -> a -> Bool) -> a -> [a] -> [a]
insert _ x []                 = [x]
insert p x (y:ys) || p x y     = x : y : ys
                  || otherwise = y : insert p x ys
\end{curry}

We then define \cyinl{insertionSort} using \cyinl{insert} to sort a list by inserting each element into the already sorted intermediate result.

%if False

> insertionSort :: (a -> a -> Bool) -> [a] -> [a]
> insertionSort _ []     = []
> insertionSort p (x:xs) = insert p x (insertionSort p xs)

%endif

\begin{curry}
insertionSort :: (a -> a -> Bool) -> [a] -> [a]
insertionSort _ []     = []
insertionSort p (x:xs) = insert p x (insertionSort p xs)
\end{curry}

Let us test if the function works as expected.
The following example sorts a list of integers in ascending order.

\begin{cyrepl}
\curryrepl insertionSort (<=) (reverse [1..5])
[1,2,3,4,5]
\end{cyrepl}

As the definition of \cyinl{insertionSort} is parametric over the comparison function, we can apply different orderings using the same function.
Besides a deterministic order specified by \cyinl{(<=)} or \cyinl{(>=)}, there is nothing that stops us from using a non-deterministic comparison function instead.
Consider the following example, where we apply \cyinl{insertionSort} to the non-deterministic comparison function \cyinl{coinCmp}.\footnote{If the result of an evaluated expression in the REPL yields more than four results, we will display the results side-by-side to ease readibility.}

\begin{cyrepl}
\curryrepl insertionSort coinCmp [1,2,3]
[1,2,3]  [1,3,2]
[2,1,3]  [3,1,2]
[2,3,1]  [3,2,1]
\end{cyrepl}

We see that the expression non-deterministically yields six different results.
All of these results are a permutation of the input list \cyinl{[1,2,3]}.
Since a list of length $n$ has $n!$ number of permutations, the example above yields exactly all $3!=6$ permutations of the list.

In order to better understand how \cyinl{insertSort} computes the permutations of its input list when applied to \cyinl{coinCmp}, we take a look at the decision tree for the exemplary call above on the left of \autoref{fig:dtInsert}.
As the comparison function \cyinl{coinCmp} non-deterministically yields \cyinl{True} and \cyinl{False}, the decision tree of our example reflects all possible control flows for \cyinl{insertionSort} depending on the results of \cyinl{coinCmp}.

\begin{figure}[t]
\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{alltt}
?
├── L: ?
│       ├── L: [1,2,3]
│       └── R: ?
│               ├── L: [2,1,3]
│               └── R: [2,3,1]
└── R: ?
        ├── L: [1,3,2]
        └── R: ?
                ├── L: [3,1,2]
                └── R: [3,2,1]
\end{alltt}
\end{minipage}
$\quad$ \vline $\quad$
\begin{minipage}{0.4\textwidth}
\begin{alltt}
2 \(\leq\) 3
├── L: 1 \(\leq\) 2
│       ├── L: [1,2,3]
│       └── R: 1 \(\leq\) 3
│               ├── L: [2,1,3]
│               └── R: [2,3,1]
└── R: 1 \(\leq\) 3
        ├── L: [1,3,2]
        └── R: 1 \(\leq\) 2
                ├── L: [3,1,2]
                └── R: [3,2,1]
\end{alltt}
\end{minipage}
\end{center}
\caption{Decision tree for \cyinl{insertionSort coinCmp [1,2,3]} as produced by KiCS2 (left) and in a modified version to highlight compared elements of the list (right)}
\label{fig:dtInsert}
\end{figure}

We already introduced the option to draw the decision tree for a non-deterministic expression in \autoref{ch:dp}.
Recall that we do not display labels for the branches if the evaluated expression does not make use of sharing.
Moreover, all branches in this decision tree correspond to non-determinism spawned by \cyinl{coinCmp}.

An interesting insight that we, unfortunately, do not gain from the decision tree is \emph{how} exactly the permutations are computed on the way.
In order to make the computation more transparent, we adjust the above decision tree and annotate each branch point with the comparison that takes place.
That is, as each branch corresponds to an application of \cyinl{coinCmp} to arguments, we can annotate the branches with these arguments.
The right tree of \autoref{fig:dtInsert} displays the modified decision tree.

Note that the first comparison is between the last two elements of the list: \cyinl{2} and \cyinl{3}.
Thus, \cyinl{insertionSort} starts by inserting the last element into the empty list, moves one position to the front at each recursive step and inserts the next element to the currently accumulated list.
Depending on the decision of \cyinl{coinCmp} that takes place when evaluating \cyinl{insert}, the element to be inserted moves one position to the right in the resulting list.
For example, the decisions that lead to the permutation \cyinl{[1,2,3]} are that \cyinl{2} and \cyinl{3} as well as \cyinl{1} and \cyinl{2} relate with respect to \cyinl{coinCmp}.
The first decision leads to the temporary list \cyinl{[2,3]}, as \cyinl{2} and \cyinl{3} are already in correct order.
As next step we want to insert \cyinl{1}; as \cyinl{1} and \cyinl{2} are in the correct order as well, we insert \cyinl{1} at the front of the list yielding the resulting permutation \cyinl{[1,2,3]}.

We take a second step to demystify the generation of permutations using \cyinl{coinCmp} as predicate.
Let us revise the implementation of \cyinl{insert} by inlining the applied predicate \cyinl{coinCmp}.

%if False

> insertCoin :: a -> [a] -> [a]
> insertCoin x []     = [x]
> insertCoin x (y:ys) = x:y:ys ? y : insertCoin x ys

%endif

\begin{curry}
insertCoin :: a -> [a] -> [a]
insertCoin x []     = [x]
insertCoin x (y:ys) = x:y:ys ? y : insertCoin x ys
\end{curry}

This variant of \cyinl{insert} is exactly the definition of a non-deterministic insertion that is used to define a permutation function, for example in the overview of Curry by \citet{hanus1994integration}.
The attentive reader recognises the definition as the Curry equivalent of \hinl{insertND} we defined in Haskell using a representation for non-determinism in \autoref{subsec:monadicAbstractions}.

\subsection{Selection Sort}
Next, we consider the permutation function derived from selection sort.
The key idea of selection sort is to find the minimum of the list and placing it at the front of the resulting list.
First, we define a function to find a minimum of a given list parametrised by the comparison function.

%if False

> minList :: (a -> a -> Bool) -> [a] -> a
> minList _ [x]      = x
> minList p (x:y:ys) = min p x (minList p (y:ys))

%endif

\begin{curry}
minList :: (a -> a -> Bool) -> [a] -> a
minList _ [x]      = x
minList p (x:y:ys) = min p x (minList p (y:ys))
\end{curry}

The function \cyinl{minList} is partial, because we cannot yield a value in case of the empty list.
If the list has one element, we yield that element, otherwise we compare the first element with the minimum of the remaining list.
That is, we define a helper function \cyinl{min}, a parametrised version of a function that takes two arguments and yields the smaller one.

%if False

> min :: (a -> a -> Bool) -> a -> a -> a
> min p x y  | p x y     = x
>            | otherwise = y

%endif

\begin{curry}
min :: (a -> a -> Bool) -> a -> a -> a
min p x y || p x y     = x
          || otherwise = y
\end{curry}

After picking a minimum, we need to delete that minimum from the list to recursively sort the remaining list.
We define \cyinl{delete} to remove an element from a list.

%if False

> delete :: Eq a => a -> [a] -> [a]
> delete _ [] = []
> delete x (y:ys)  | x == y     = ys
>                  | otherwise  = y : delete x ys

%endif

\begin{curry}
delete :: Eq a => a -> [a] -> [a]
delete _ [] = []
delete x (y:ys) || x == y    = ys
                || otherwise = y : delete x ys
\end{curry}

Here, it is crucial that we use the comparison function \cyinl{(==)} to make sure that the element is correctly removed from the list.
Now we can define \cyinl{selectionSort}: we pick the minimum of the input list, place it into the front of the resulting list, and continue with the list without the minimum.

%if False

> selectionSort :: Eq a => (a -> a -> Bool) -> [a] -> [a]
> selectionSort _ []         = []
> selectionSort p l@(_ : _)  =  let y = minList p l
>                               in y : selectionSort p (delete y l)

%endif

\begin{curry}
selectionSort :: Eq a => (a -> a -> Bool) -> [a] -> [a]
selectionSort _ []        = []
selectionSort p l@@(_ : _) = let y = minList p l
                            in y : selectionSort p (delete y l)
\end{curry}

We are ready to take a look at the resulting permutations.

\begin{cyrepl}
\curryrepl selectionSort coinCmp [1,2,3]
[1,2,3]  [2,3,1]
[1,3,2]  [3,1,2]
[2,1,3]  [3,2,1]
\end{cyrepl}

We see that \cyinl{selectionSort} yields exactly the permutations of the input list like \cyinl{insertionSort}.
One difference of both implementation comes apparent when we look at the type: \cyinl{selectionSort} has an \cyinl{Eq}-constraint on the elements of the list.
As the resulting \cyinl{Eq}-constraint breaks with the general scheme that we parametrise all functions with a comparison function, we define a function \cyinl{pickMin} that finds the minimum and yields the remaining list in one traversal of the input list.

%if False

> pickMin :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMin _ [x]             = (x,[])
> pickMin p (x:xs@(_ : _))  =  let (m,l) = pickMin p xs
>                              in if p x m then (x,xs) else (m,x:l)

%endif

\begin{curry}
pickMin :: (a -> a -> Bool) -> [a] -> (a,[a])
pickMin _ [x]            = (x,[])
pickMin p (x:xs@@(_ : _)) = let (m,l) = pickMin p xs
                           in if p x m then (x,xs) else (m,x:l)
\end{curry}

We adapt the implementation of \cyinl{selectionSort} to use \cyinl{pickMin} instead of using a combination of \cyinl{minList} and \cyinl{delete} as follows.

%if False

> selectionSortPick :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortPick _ []         = []
> selectionSortPick p l@(_ : _)  =  let (m,l') = pickMin p l
>                                   in m : selectionSortPick p l'

%endif

\begin{curry}
selectionSortPick :: (a -> a -> Bool) -> [a] -> [a]
selectionSortPick _ []        = []
selectionSortPick p l@@(_ : _) = let (m,l') = pickMin p l
                                in m : selectionSortPick p l'
\end{curry}

Sorting the same example list as before using the adapted implementation \cyinl{selectionSortPick} yields the expected results.

\begin{cyrepl}
\curryrepl selectionSortPick coinCmp [1,2,3]
[1,2,3]  [2,3,1]
[1,3,2]  [3,1,2]
[2,1,3]  [3,2,1]
\end{cyrepl}

%if False

> pickMinCase :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinCase p xs = case xs of
>                 [x] -> (x,[])
>                 x:xs -> let (m,l) = pickMinCase p xs
>                         in if p x m then (x,m:l) else (m, x:l)

> pickMin' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMin' _ [x]     = (x,[])
> pickMin' p (x:xs@(_ : _))  =  let (m,l) = pickMin' p xs
>                               in if p x m then (x,xs) else (m, x:l)

> pickMinCase' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinCase' p xs = case xs of
>                      [x] -> (x,[])
>                      y:ys -> let (m,l) = pickMinCase' p ys
>                              in if p y m then (y,ys) else (m, y:l)

> selectionSortPick' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortPick' _ []         = []
> selectionSortPick' p l@(_ : _)  =  let (m,l') = pickMin' p l
>                                    in m : selectionSortPick' p l'

> selectionSortPickCase' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortPickCase' _ []         = []
> selectionSortPickCase' p l@(_ : _)  =  let (m,l') = pickMinCase' p l
>                                        in m : selectionSortPickCase' p l'

> selectionSortDel :: Eq a => (a -> a -> Bool) -> [a] -> [a]
> selectionSortDel _ []       = []
> selectionSortDel p l@(_:_)  =  let y = minList p l
>                                in y : selectionSortDel p (delete y l)

> delete' :: (a -> a -> Bool) -> a -> [a] -> [a]
> delete' p _ [] = []
> delete' p x (y:ys)  | p x y     = ys
>                     | otherwise = y : delete' p x ys

> selectionSort'' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSort'' _ []       = []
> selectionSort'' p l@(_ : _)  =  let y = minList p l
>                                 in y : selectionSort'' p (delete' (\x y -> p x y && p y x) y l)

> pickMinS :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinS _ [x]     = (x,[])
> pickMinS p (x:xs@(_ : _))  = case pickMinS p xs of
>                                (m,l) -> if p x m then (x,xs) else (m,x:l)
>
> pickMinS' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinS' _ [x]             = (x,[])
> pickMinS' p (x:xs@(_ : _))  = uncurry (,)  (case pickMinS' p xs of
>                                              (m,l) -> if p x m then (x,xs) else (m,x:l))
>
> selectionSortS :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortS _ []       = []
> selectionSortS p l@(_ : _)  =  case pickMinS p l of
>                                  (m,l') -> m : selectionSortS p l'

> pickCoin :: [a] -> (a,[a])
> pickCoin [x] = (x,[])
> pickCoin (x:xs@(_:_)) = (x,xs) ? fSnd (x:) (pickCoin xs) --let (m,l) = pickCoin xs in (m, x:l)
>  where fSnd f (a,b) = (a, f b)
>
> selectionSortCoin :: [a] -> [a]
> selectionSortCoin [] = []
> selectionSortCoin xs@(_ : _) = case pickCoin xs of
>                                 (m,l) -> m : selectionSortCoin l

%endif

Due to the let-bindings used in the implementation of \cyinl{selectionSortPick} as well as the auxiliary function \cyinl{pickMin}, the corresponding decision tree is not as easy to look at as for \cyinl{insertionSort}.
Instead, we take a look at the decision tree for \cyinl{pickMin} and \cyinl{minList} in \autoref{fig:select1}.

\begin{figure}
\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{alltt}
?3
├── L: (1,[2,3])
└── R: ?6
        ├── L: ?6
        │       ├── L: (2,[1,3])
        │       └── R: (2,[1,2])
        └── R: ?6
                ├── L: (3,[1,3])
                └── R: (3,[1,2])
\end{alltt}
\end{minipage}
$\quad\quad\quad$ \vline $\quad\quad\quad$
\begin{minipage}{0.2\textwidth}
\begin{alltt}
?
├── L: 1
└── R: ?
        ├── L: 2
        └── R: 3





\end{alltt}
\end{minipage}
\end{center}
\caption{Decision trees for the expressions \cyinl{pickMin coinCmp [1,2,3]} (left) and \cyinl{minList coinCmp [1,2,3]} (right)}
\label{fig:select1}
\end{figure}

Note that the decision tree for \cyinl{pickMin} is an example for the visualisation of sharing: the decision labeled \emph{?6} occurs in each of the two preceding sub-trees again.
This decision originates in the usage of the let-binding for the recursive call in the second rule for \cyinl{pickMin}.
The recursive call \cyinl{pickMin p xs} binds the minimum and the list without that minimum to the variables \cyinl{m} and \cyinl{l}, respectively.
In particular, we cannot use case-expressions without altering the non-strictness-property of the original definition using let-bindings.
Therefore, in the following, we represent decision trees in a reduced version, where we fuse shared decisions by only displaying the branches that would be considered in a search traversal.
\autoref{fig:selectAndBubble} displays this reduced decision tree --- with the additional modification that we label branches with the corresponding comparisons like before.
%
\begin{figure}
\begin{center}
\begin{minipage}{0.25
\textwidth}
\begin{alltt}
1 \(\leq\) _ (*)
├── 2 \(\leq\) 3
│   ├── [1,2,3]
│   └── [1,3,2]
└── 2 \(\leq\) 3
    ├── 1 \(\leq\) 3
    │   ├── [2,1,3]
    │   └── [2,3,1]
    └── 1 \(\leq\) 2
        ├── [3,1,2]
        └── [3,2,1]
\end{alltt}
\end{minipage}
$\quad$ \vline $\quad$ $\quad$
\begin{minipage}{0.6\textwidth}
\begin{alltt}
1 \(\leq\) head (bubble [2,3])
├── 2 \(\leq\) head (bubble [3])         *** / ****
│    ├── 2 \(\leq\) head (bubble [3])    ***
│    │    ├── [1,2,3]
│    │    └── [1,3,2]              <+++
│    └── 3 \(\leq\) head (bubble [2])    ****
│        ├── [1,3,2]
│        └── [1,2,3]               <++++
└── 2 \(\leq\) head (bubble [3])
    ├── 1 \(\leq\) head (bubble [3])
    │   ├── [2,1,3]
    │   └── [2,3,1]
    └── 1 \(\leq\) head (bubble [2])
        ├── [3,1,2]
        └── [3,2,1]
\end{alltt}
\end{minipage}
\end{center}
\caption{Reduced and modified decision tree for \cyinl{bubbleSort coinCmp [1,2,3]} (left) and reduced decision tree for \cyinl{selectionSortPick coinCmp [1,2,3]} (right)}
\label{fig:selectAndBubble}
\end{figure}
%
As an interesting aside, note that we cannot give the second argument of the comparison for the first branch --- marked with \texttt{(*)} in \autoref{fig:selectAndBubble}.
We do not have this information, because \cyinl{coinCmp} does not demand its second argument.
In the example above the second argument is the expression \cyinl{pickMin coinCmp [2,3]}; a demand is only necessary if we want to compute the entire list structure of the first solution.
We can observe this non-strict behaviour when computing only the head element of the resulting permutations.
Consider the following expressions involving a list with \cyinl{failed} as element.

\begin{cyrepl}
\curryrepl selectionSortPick coinCmp [1,failed]
\curryrepl head (selectionSort coinCmp [1,failed])
1
\end{cyrepl}
\noindent
In theory, the permutations of the list \cyinl{[1,failed]} are \cyinl{[1,failed]} and \cyinl{[failed,1]}; in practice, the expression \cyinl{failed} is not a value like \cyinl{42} or \cyinl{True}, printing \cyinl{failed} in the REPL propagates the failure to the top-level, that is, there are no results to print.
The first expression computes all possible permutations, but the expression does not have any result: \cyinl{failed} causes the computation propagate the failure to the top-level.
The second expression, however, computes only the head element and yields indeed a solution.
That is, in order to yield the first element of the first list, we do not need to compute any further elements of the input list.

\subsection{Bubble Sort}
\label{subsec:CurryBubble}

The next sorting function we examine is bubble sort.
We define an implementation of the bubble sort algorithm that bubbles the minimum element to the front of a list.
Bubbling to the front of the list allows for a more efficient implementation with respect to the selecting the minimum and the remaining list.
The following function \cyinl{bubble} defines the bubbling of the minimum element of the list to the front.

%if False

> bubble :: (a -> a -> Bool) -> [a] -> [a]
> bubble _ [x]             = [x]
> bubble p (x:xs@(_ : _))  =  let (y:ys) = bubble p xs
>                             in if p x y then x:y:ys else y:x:ys

%endif

\begin{curry}
bubble :: (a -> a -> Bool) -> [a] -> [a]
bubble _ [x]            = [x]
bubble p (x:xs@@(_ : _)) = let (y:ys) = bubble p xs
                          in if p x y then x:y:ys else y:x:ys
\end{curry}

%if False

> bubble2 :: (a -> a -> Bool) -> [a] -> [a]
> bubble2 _ [x]              = [x]
> bubble2 p (x:xs@(y : ys))  = if p x y then x : bubble2 p (y:ys) else y : bubble2 p (x:ys)
>
> bubble' :: (a -> a -> Bool) -> [a] -> [a]
> bubble' _ [x]             = [x]
> bubble' p (x:xs@(_ : _))  =  let (y:ys) = bubble' p xs
>                              in if p x y then x:xs else y:x:ys
>
> bubbleSort2 :: (a -> a -> Bool) -> [a] -> [a]
> bubbleSort2 _ []       = []
> bubbleSort2 p xs@(_:_) = let (y:ys) = bubble2 p xs in y : bubbleSort2 p ys

%endif

When used with a deterministic comparison function like \cyinl{(<=)}, the implementation potentially bubbles more elements than the minimum to the front of the list.

\begin{cyrepl}
\curryrepl bubble (<=) [2,3,4,1]
[1,2,3,4]
\curryrepl bubble (<=) [1,3,4,2]
[1,2,3,4]
\curryrepl bubble (<=) [2,4,3,1]
[1,2,4,3]
\curryrepl bubble (<=) [1,4,3,2]
[1,2,4,3]
\curryrepl bubble (<=) [2,1,4,3]
[1,2,3,4]
\end{cyrepl}

During the traversal of the list, each local minumum of a comparison bubbles to a front position of the list.
That is, while the first two examples use lists with only on element that occurs out of order (\cyinl{1} for the first and \cyinl{2} for the second example), the next three lists have at least two elements that need to be rearranged to be sorted.
Bubbling the local minimum to the front yields, nevertheless, a sorted list for the last example: the pairs \cyinl{4 <= 3}, \cyinl{1 <= 4} and \cyinl{2 <= 1} make sure that \cyinl{3} and \cyinl{1} bubble to the right place within the list.
This behaviour, however, is rather than a lucky coincidence than the normal case for the usage of \cyinl{bubble}.
The third and fourth lists are counterexamples: when bubbling \cyinl{1} (in the third example) and \cyinl{2} (in the fourth example), respectively, to the front of the list, \cyinl{3} is never picked as local minumum to bubble to the front.

Using a non-deterministic comparison function like \cyinl{coinCmp}, enumerates all possible \emph{bubblings}.
Consider the following two examples.

\begin{cyrepl}
\curryrepl  bubble coinCmp [1,2,3]
[1,2,3]   [2,1,3]
[1,3,2]   [3,1,2]

\curryrepl bubble coinCmp [1,2,3,4]
[1,2,3,4]  [2,1,3,4]
[1,2,4,3]  [2,1,4,3]
[1,3,2,4]  [3,1,2,4]
[1,4,2,3]  [4,1,2,3]
\end{cyrepl}

We can now define \cyinl{bubbleSort} by means of \cyinl{bubble}: \cyinl{bubble} gives us easy access to the minimum of the list that we use as head element and sort the remaining list recursively.

%if False

> bubbleSort :: (a -> a -> Bool) -> [a] -> [a]
> bubbleSort _ []       = []
> bubbleSort p xs@(_ : _) = let (y:ys) = bubble p xs in y : bubbleSort p ys

%endif

\begin{curry}
bubbleSort :: (a -> a -> Bool) -> [a] -> [a]
bubbleSort _ []         = []
bubbleSort p xs@@(_ : _) = let (y:ys) = bubble p xs
                          in y : bubbleSort p ys
\end{curry}

Finally, the application of the sorting function to the non-deterministic comparison function \cyinl{coinCmp} yields more results than expected.

\begin{cyrepl}
\curryrepl bubbleSort coinCmp [1,2,3]
[1,2,3]    [2,1,3]
[1,3,2]    [2,3,1]
[1,3,2]    [3,1,2]
[1,2,3]    [3,2,1]
\end{cyrepl}

Instead of six results corresponding to all permutations of the input list, we observe that two permutations occur twice: \cyinl{[1,2,3]} and \cyinl{[1,3,2]}.
In order to understand why these duplicates occur, we take a look at the decision tree for the example call above listed in \autoref{fig:selectAndBubble}.

Note that the second argument of the comparison function \cyinl{coinCmp} is, again, an unevaluated expression --- we have already seen a similar example when talking about \cyinl{selectionSort}.
The computation of all results in the REPL as well as drawing the decision tree demand the evaluation of expressions like \cyinl{head (bubble [2,3])} not until the corresponding list element will be printed.\footnote{The actual expression appearing in the evaluation steps is a let-binding that references the head element in the comparison. That is, \cyinl{let (x:xs) = bubble [2,3] in if 1 <= x then ... else ...} is closer to the expressions occurring during the evaluation.}x
The new thing about the decision tree for an application of \cyinl{bubbleSort} is that some results occur twice.
The duplicated results are marked with \texttt{<+++} and \texttt{<++++}, respectively.
Note, that it is by intention that we marked the first occurence in case of \cyinl{[1,3,2]} and the second one in case of the result \cyinl{[1,2,3]}.
Consider the path from the root to the result marked with \texttt{<+++}.
The crucial parts are the comparisons marked with \texttt{***}: we compare \cyinl{2} and \cyinl{head (bubble [3])} twice.
In a setting where we use a deterministic comparison function, the first path to \cyinl{[1,3,2]} does not make sense.
The decision for the first comparison \cyinl{2 <= head (bubble [3])} yields \cyinl{True} --- otherwise we would not take the first branch, that is, doing the same comparison a second time should yield \cyinl{True} again.
In the path from the root to the first occurence \cyinl{[1,3,2]}, the comparison of \cyinl{2} and \cyinl{head (bubble [3])} yields \cyinl{True} the first and \cyinl{False} the second time.
Note that there is no deterministic comparison function that yields \cyinl{True} for a comparison first and \cyinl{False} later.
In the following we reference the following property as \emph{behaving consistently}: a non-deterministic predicate behaves consistently, if it yields the same Boolean value for every application to the same values.

The other result marked with $\text{\texttt{<++++}}$ is the second occurence of \cyinl{[1,2,3]}.
Here, the relevant comparisons taken on the path are mark with \texttt{****}: \cyinl{2 <= head (bubble [3])} and \cyinl{3 <= head (bubble [2])}.
Note that the expression \cyinl{head (bubble [x])} evaluates to \cyinl{x} for all \cyinl{x} of appropriate type.
That is, \cyinl{head (bubble [3]) = 3} and \cyinl{head (bubble [2]) = 2}.
Below we only reference the comparisons with the evaluated function calls to simplify the reasoning.
As the second comparison takes place in the second branch of the decision corresponding to \cyinl{2 <= 3}, we know that the decision was \cyinl{False}.
That is, \cyinl{2} is not smaller than or equal to \cyinl{3}, \cyinl{2} is greater than \cyinl{3}.
We then take the second branch for the decision \cyinl{3 <= 2}: \cyinl{2} is greater than \cyinl{3}.
Note that this decision does not make sense when using \cyinl{bubbleSort} with a reasonable comparison function like \cyinl{(<=)} on integer values.
The important property missing here is that the relation described by \cyinl{<=} needs the connex property.
The connex property describes that any two pairs of elements of appropriate type are comparable with respect to \cyinl{<=}.

\[
\forall xy, x \leq y \vee y \leq x \tag*{(Connexity)}
\]

Binary relations that are total orders (like for example the less-than-or-equal-to-relation on integers) fulfil the connex property by definition.
That is, the implementation of \cyinl{bubbleSort} needs to be used with a comparison function corresponding to a binary relation that is a total order, otherwise it cannot sort all lists correctly.

\subsection{Quicksort}
\label{subsec:quicksort}

In this section we take a look at an implementation of \emph{quicksort} that is known for its particular declarative realisation.
The general idea behind the quick sort algorithm is to choose a pivot element and split the remaining list into two parts: one with all elements that are smaller than or equal to the pivot element and one with the all elements that do not fulfil this criterion.
The algorithm is then recursively applied to these two sublists.

The following function \cyinl{quickSort} uses the head element of the given list as the pivot element and the function \cyinl{filter} to split the input list into the two parts.

%if False

> type Values a = [a]

> allValues :: a -> Values a
> allValues x = FA.allValues x

> foldValues :: (a -> a -> a) -> a -> Values a -> a
> foldValues = foldr

> mapValues :: (a -> b) -> Values a -> Values b
> mapValues = map

> quickSort :: (a -> a -> Bool) -> [a] -> [a]
> quickSort _  []      = []
> quickSort p  (x:xs)  =  let  l1 = filter (\y -> p y x) xs
>                              l2 = filter (\y -> not (p y x)) xs
>                         in quickSort p l1 ++ x : quickSort p l2

%endif

\begin{curry}
quickSort :: (a -> a -> Bool) -> [a] -> [a]
quickSort _  []     = []
quickSort p  (x:xs) = let l1 = filter (\y -> p y x) xs
                          l2 = filter (\y -> not (p y x)) xs
                      in quickSort p l1 ++ x : quickSort p l2
\end{curry}

Let us take a look at the resulting permutations as well as the number of results for exemplary calls.
Note that we use the encapsulation function \cyinl{allValues} as well as the convenience functions introduced in \autoref{subsec:encapsulation} to count the number of deterministic values in the resulting multiset by means of a helper function \cyinl{lengthValues}.

\begin{cyrepl}
\curryrepl quickSort coinCmp [1,2]
[2,1]
[2,1,2]
[1]
[1,2]

\curryrepl lengthValues (allValues (quickSort coinCmp [1,2,3]))
49

\curryrepl lengthValues (allValues (quickSort coinCmp [1,2,3,4]))
4225
\end{cyrepl}

That escalated quickly.
The first example call was already odd: for a list with two elements we get four results, of which two are not even permutations of the original list.
The second and third example illustrate why we did not print all results for a list with more than two elements: the number of results grows way worse than expected for an algorithm that enumerates permutations.
The expected number of results for three elements is $3!=6$ and $4!=24$ for four elements, respectively.

A quick look at the two filter calls alone will get us closer to understand what is going on here.

\begin{cyrepl}
\curryrepl filter (coinCmp 1) [2]
[2]
[]

\curryrepl filter (not . coinCmp 1) [2]
[]
[2]
\end{cyrepl}

Both bindings, \cyinl{l1} and \cyinl{l2}, evaluate to the same two values, just in reversed order.
These two times two sublists yield four overall results, since all lists for \cyinl{l1} are combined with all lists of \cyinl{l2} to yield \cyinl{l1 ++ x : l2}.
In general, the resulting function enumerates the cross product of all subsequences of the input list.

We can again observe that the definition of \cyinl{quickSort} uses the comparison function \cyinl{coinCmp} inconsistently, thus, yields the same results for both application of filter.
Using a deterministic comparison function \cyinl{p}, the sublists \cyinl{l1} and \cyinl{l2} are disjoint, since we are using \cyinl{p} for the first and \cyinl{not . p} for the second list.

We can overcome this drawback when using two \cyinl{filter} applications by using \cyinl{split} instead.
The function \cyinl{split :: (a -> Bool) -> [a] -> ([a],[a])} traverses a list only once to split it into two sublists fulfilling exactly the property we use above: the first list contains only elements that fulfil the given predicate and the second list contains the elements that do not.
We define \cyinl{split} as follows; note, that it is crucial that split traverses its input list only once.

%if False

> split :: (a -> a -> Bool) -> a -> [a] -> ([a],[a])
> split p x l = split' l ([],[])
>  where
>   split' [] ls                          = ls
>   split' (y:ys) (l1,l2)  | not (p x y)  = split' ys (l1,y:l2)
>                          | otherwise    = split' ys (y:l1,l2)

%endif

\begin{curry}
split :: (a -> a -> Bool) -> a -> [a] -> ([a],[a])
split p x l = split' l ([],[])
 where
  split' []     ls                    = ls
  split' (y:ys) (l1,l2) || not (p x y) = split' ys (l1,y:l2)
                        || otherwise   = split' ys (y:l1,l2)
\end{curry}

Based on \cyinl{split} we can define a second version of quick sort.
We reuse the variable names \cyinl{l1} and \cyinl{l2} for the two sublists to indicate that the underlying idea of the algorithm stays exactly the same.

%if False

> quickSortSplit :: (a -> a -> Bool) -> [a] -> [a]
> quickSortSplit _ []     = []
> quickSortSplit p (x:xs) =  let (l1,l2) = split p x xs
>                            in quickSortSplit p l1 ++ x : quickSortSplit p l2

%endif

\begin{curry}
quickSortSplit :: (a -> a -> Bool) -> [a] -> [a]
quickSortSplit _ []     = []
quickSortSplit p (x:xs) = let (l1,l2) = split p x xs
                          in quickSortSplit p l1 ++ x : quickSortSplit p l2
\end{curry}

Let us once again take a look at the resulting permutations.

\begin{cyrepl}
\curryrepl quickSortSplit coinCmp [1,2,3]
[2,3,1]   [3,1,2]
[3,2,1]   [1,2,3]
[2,1,3]   [1,3,2]
\end{cyrepl}

As \cyinl{split} only traverses its input list once, each comparison happens only once.
The pivot element is compared to each element of the remaining list, the recursive calls to \cyinl{quickSortSplit} then pick new pivot elements that are used for comparison.
That is, we end up with exactly all permutations of the input list, again.

\subsection{Merge Sort}

Last but not least, we take a look at merge sort.
The general idea of the sorting algorithm is to divide the input list of length $n$ into $n$ sublists, that is, all sublists are singleton lists.
These singleton lists, which are trivially sorted, are merged into new sorted sublists.
The algorithm repeats the merging step until only one list remains: the resulting sorted list.

First, we define a function \cyinl{divideN} to divide the input lists into two lists of approximately the same length.
The first list is short by one element n case of an odd number of elements.

%if False

> divideN :: [a] -> ([a],[a])
> divideN xs = divideN' xs (length xs `div` 2)
>  where  divideN' []      _  = ([],[])
>         divideN' (y:ys)  n  | n == 0     = ([],y:ys)
>                             | otherwise  =  let (l1,l2) = divideN' ys (n-1)
>                                             in (y:l1,l2)

> merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
> merge _ []     l       = l
> merge _ (x:xs) []      = x:xs
> merge p (x:xs) (y:ys)  | p x y      = x : merge p xs (y:ys)
>                        | otherwise  = y : merge p (x:xs) ys

> mergeSort :: (a -> a -> Bool) -> [a] -> [a]
> mergeSort _ []               = []
> mergeSort _ [x]              = [x]
> mergeSort p l@(_ : (_ : _))  =  let (l1,l2) = divideN l
>                                 in merge p (mergeSort p l1) (mergeSort p l2)

%endif

\begin{curry}
divideN :: [a] -> ([a],[a])
divideN xs = divideN' xs (length xs `div` 2)
 where  divideN' []     _  = ([],[])
        divideN' (y:ys) n || n == 0    = ([],y:ys)
                          || otherwise = let (l1,l2) = divideN' ys (n-1)
                                        in (y:l1,l2)
\end{curry}

Second, we define a function \cyinl{merge} that merges two lists based on a comparison function.

\begin{curry}
merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
merge _ []     l      = l
merge _ (x:xs) []     = x:xs
merge p (x:xs) (y:ys) || p x y      = x : merge p xs (y:ys)
                      || otherwise  = y : merge p (x:xs) ys
\end{curry}

The first two rules cover the cases that it is not necessary to merge if one of lists is empty, we just yield the other one.
If both lists are non-empty, we decide based on the comparison function \cyinl{p} which element to put at the front of the resulting list and merge recursively with the remaining lists.
Note that we assume that both list arguments of \cyinl{merge} are already sorted.
Finally, we define the overall sorting function \cyinl{mergeSort} that uses \cyinl{divideN} to divide the lists into two sublists that are sorted recursively, and \cyinl{merge} to merge the sorted sublists.

\begin{curry}
mergeSort :: (a -> a -> Bool) -> [a] -> [a]
mergeSort _ []              = []
mergeSort _ [x]             = [x]
mergeSort p l@@(_ : (_ : _)) = let (l1,l2) = divideN l
                              in merge p (mergeSort p l1) (mergeSort p l2)
\end{curry}

Once again we take a look at an exemplary application of \cyinl{mergeSort} to the non-deterministic comparison function \cyinl{coinCmp}.

\begin{cyrepl}
\curryrepl mergeSort coinCmp [1,2,3]
[1,2,3]   [1,3,2]
[2,1,3]   [3,1,2]
[2,3,1]   [3,2,1]
\end{cyrepl}

We are pleased to observe that the resulting function enumerates exactly all permutations.
The procedure followed by \cyinl{mergeSort} does not make any redundant comparisons.
The first step of dividing the list into sublists is not based on the predicate but based on the length of the list only.
The comparison takes place when using \cyinl{merge}.
As \cyinl{merge} has the precondition that both argument lists are already sorted, it is sufficient to compare the lists head-wise.
That is, if one head element is smaller than the other head element, we put the former in front of the list and do not need to consider it anymore.
The utilisation of the precondition leads to a efficient sorting algorithm: no two elements are compared more than once.

%include Permutations.lhs

\section{Future Work}
While we started first investigations to compare the strictness behaviour of different sorting functions, we think that a more rigorous investigation might lead to further interesting properties.
For example, it would be interesting to analyse the run-time behaviour for the resulting permutation functions.
As we only compared the non-deterministic version in Curry and the monadic version in Haskell, it would be interesting to compare the non-deterministic version with deterministic permutation algorithms as well.
For example, according to \citet{sedgewick1977permutation} the classical permutation
algorithm based on inserting an element at each possible position in a list was developed independently by \citet{trotter1962algorithm}
and \citet{johnson1963generation}.
The implementation of the \hinl{permutations :: [a] -> [[a]]} function in Haskell is also
based on this approach but has been improved with respect to
non-strictness via a mailing list discussion by
\citet{vanlaarhoven2007haskell}.
A comparison of the improved permutation algorithm used in Haskell and the best-performing non-deterministic Curry version would be an intersting topic for future work.

A different line of future work could be to focus more on the resulting permutations function.
For example, we noticed only by chance that selection sort enumerates all permutation in lexicographic order when evaluated using depth-first-search instead of the default behaviour of breadth-first-search.
It would be interesting to analyse the order of results for all other sorting algorithms as well.
This analysis can then be extended to other non-deterministic sorting functions, which are perhaps more strict than \cyinl{coinCmp}, but yield an interesting property.
An example of an alternative non-deterministic comparison function is the following definition of \cyinl{liftCmp} that lifts a comparison function \cyinl{cmp} into a monadic context.

\begin{curry}
liftCmp :: (a -> a -> Bool) -> a -> a -> Bool
liftCmp cmp x y = p x y ? not (cmp x y)
\end{curry}

There are lots of other properties related to permutations.
For example, enumerating derangements, that is, enumerating all permutations where an element does not appear at its original position, enumerating all permutations of a sublist of a given list, or analysing the resulting order of permutation with respect to the parity for the transposition from one permutation to the next.

Besides a further investigation of permutation enumeration functions, we are interested if there are other predicate-based functions that do a useful task when applied to a non-deterministic predicate.
The other example next to sorting we have discussed is filtering a list.
Namely, we used \cyinl{filter} to implement quick sort in \ref{subsec:quicksort}.
We have seen that using \cyinl{filter} with a non-deterministic predicate yields all sublists of the input list.
It might be interesting to search for more predicate-based functions and their non-deterministic counterparts.
The first other common functions that come to mind are \cyinl{takeWhile, dropWhile :: (a -> Bool) -> [a] -> [a]}, but we are keen to search for other functions that have interesting and useful non-deterministic counterparts.

\section{Conclusion}
In this chapter we implemented a variety of sorting functions parametrised over a comparison function in Curry as well as in Haskell.
Instead of ordinary sorting tasks, we applied the sorting functions to a non-deterministic comparison function.
The resulting function enumerates permutations of the input list.
For the Curry implementation there are several sorting functions that compute only the permutations of the input list without any duplicates: insertion sort, selection sort, merge sort and a variant of quick sort that uses \cyinl{partition} instead of two \cyinl{filter} calls.
We then compared these Curry implementations to their Haskell counterparts.
In order to mimic the non-deterministic component that Curry brings along out of the box, we use a monadic lifting to define potentially effectful computations in Haskell.
In the end, the Haskell implementations use a monadic lifting of the ordinary, pure sorting function in order to use a non-deterministic comparison function and compute non-deterministic results.
One particularly interesting observation was that whereas the Curry version of selection sort computes only the permutations, the Haskell version does not.
This difference was the main reason we investigated the difference of both implementations in the first place.
The other sorting functions compute the same non-deterministic results: insertion sort, merge sort, and quick sort using \cyinl{partition} do not compute duplicate results and bubble sort computes duplicates in Curry as well as in Haskell.
Although we did not find other differences with respect to the computed permutations, we observed that the Curry version of these implementations can exploit non-strictness better than their Haskell counterparts.
As an example, we demanded the head elements of all permutations and counted the number of non-deterministic choices that were triggered in to compute the result.
The most impressive sorting functions for this example were selection sort and bubble sort implemented in Curry as they only demanded $n$ non-deterministic choices for a list of length $n$.
On top of that, none of the Curry implementations need to trigger all $n!$ non-deterministic computations for a list of length $n$, whereas the Haskell implementations trigger at least $n!$ computations.
This property for the Curry implementation feels impressive since $n!$ non-deterministic computations corresponds to evaluating all non-deterministic computations that occur for an implementation that yields exactly all permutations.
That is, selecting only the head element of the permutations has no effect on the non-determinism that needs to be triggered.

\section{Final Remarks}

The basis of the work discussed in this chapter has been published as functional pearl in the Proceedings of the twentieth International Conference on Functional Programming \citep{christiansen2016all}.
The conference paper motivates the investigation of non-deterministic sorting functions solely based on the monadic Haskell version.
The generic monadic interface allows for a more detailed investigation of the behaviour of the resulting permutation functions.
We enhance the monadic comparison function \cyinl{coinCmp} with an additional state in order to mimic a comparison function that meets additional properties like consistency and totality.
In case of consistency, for example, the state collects all compared value pairs and the corresponding decision of their comparison in order to repeat that decision when the same values are compared again.

On top of that, the conference paper formulates and proves a theorem stating that no matter which sorting function we use, the corresponding permutation function enumerates all permutations of the input list.
In order to prove this statement, we use free theorems as presented by \citet{wadler1989theorems}, which are derived from the type of a function alone.

The novelty of the content presented in this chapter lies in the comparison to a direct implementation in Curry.
Instead of modelling non-determinism with monads, we reused Curry's built-in non-determinism.
The main insight of this comparison is the advantage of Curry's built-in non-determinism as it can exploit non-strictness that a naive Haskell implementation using a list monad cannot.