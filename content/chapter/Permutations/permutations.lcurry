The most prominent combination of sorting functions and non-determinism is permutation sort, a sorting algorithm that generates all permutation and selects the one that is sorted to yield as result.
This sorting function has a bad running time: the best case performs in $O(2^n)$ for an input list of length $n$.
On the good side, we can argue that the worst case is as good as the best case.
However, the best case is also as bad as the worst case.

In this chapter we shed some light on a different combination of sorting functions and non-determinism: we enumerate permutations by applying sorting functions to a non-deterministic comparison function.
First, we take a look at implementations of some famous sorting functions in Curry and define a suitable comparison functions to enumerate permutations.
Thanks to Curry's built-in non-determinism we can reuse all common sorting functions as they are.
We discuss the resulting permutation enumeration functions, the number of results is of special interest here.
A selection of questions that we will answer read as follows.

\begin{itemize}
\item Can we enumerate all possible permutations of the input list using any sorting function?
\item Is there a sorting function that can enumerate exactly the permutations of the input list?
\item Can we visualise how a sorting function enumerates the permutations?
\end{itemize}

As a quick teaser for these question, we anticipate that all (correct) sorting functions indeed enumerate every permutation of the input list at least once. However, enumerating every permutation exactly once is a property that not all sorting functions share.

In the second part of this chapter we transfer our implementation in Curry to Haskell.
One possible model of non-determinism in a functional language is to use lists to represent all non-deterministic results.
We go even one step further and generalise all functions to monadic functions.
Using these monadically lifted functions, we try out different representation of non-determinism --- like multi-sets, sets, or trees --- but need only one implementation of the sorting function.
We compare the monadic representation of non-determinism with the built-in non-determinism of Curry by means of these sorting functions to enumerate permutations.

The main observation of the comparison is that Curry's built-in non-determinism can be less strict than a naive monadic model in Haskell.
This observation is not new, there are other applications that exploit this advantage as well, it is an interesting use case of this advantage nonetheless.

Last but not least, we leverage the monadic implementation of the sorting functions to discuss possibilities to get rid of duplicates when enumerating permutations.
The main idea here is to enhance the underlying monad to track the decisions the non-deterministic comparison function makes when traversing the input list.

In summary, this chapter makes the following contributions.

\begin{itemize}
\item We inspect sorting functions implemented in Curry and apply these functions to a non-deterministic comparison function and a given list to enumerate permutations of that given list.
\item When taking a closer look at the resulting lists, we observe that the functions enumerate every possible permutation of the input list at least once.
\item Some sorting functions yield duplicate results, we investigate why these duplicates emerge.
\item Furthermore, we discover that some sorting functions even enumerate lists that are not a permutation of the input list.
\item As a second step, we transfer the sorting functions to Haskell and model non-determinism explicitly using monads.
\item Thanks to the flexibility of using monads, we can enrich the non-deterministic comparison function which necessary properties to eliminate duplicate results. We show three examples for properties that yield to an enumeration of the exact number of permutations for sorting functions that yield too many results with a simple non-deterministic comparison function.
\item At last, we discuss a variety of questions that follow from the results and observations presented above.
\end{itemize}

\section{Non-deterministic Sorting Functions in Curry}

\begin{itemize}
\item examples use integer, but arbitrary types can be used
\item integer values represent positions within the list
\item less than although the comparison function could be an arbitrary one
\item argue about sorting function enumerating all permutations as otherwise it couldn't sort the list that was not enumerated
\end{itemize}

Consider the following non-deterministic comparison function that ignores both its arguments and non-deterministically yields |True| and |False|.

> coinCmp :: a -> a -> Bool
> coinCmp _ _ = True ? False

The name |coinCmp| suggests a similarity to the popular |coin|-definition as an example for non-determinism; the difference here is that we define a two-ary function with a non-deterministic result, whereas |coin| is a nullary function.

\label{sec:sortCurry}

\subsection{InsertionSort}
\label{subs:insertion}
The first sorting function we take a look at is insertion sort.
The key idea behind the sorting algorithm is to traverse the input list and insert each element in the right position within the resulting list.
That is, the element in focus is inserted in front of the first element of the list that is greater than or equal to the former.
In order to implement |insertionSort|, we implement a function |insert| first that does exactly that task: it inserts an element in a list with respect to the given comparison function.

> insert :: (a -> a -> Bool) -> a -> [a] -> [a]
> insert _ x []                 = [x]
> insert p x (y:ys) | p x y     = x:y:ys
>                   | otherwise = y : insert p x ys

We then define |insertionSort| using |insert| to sort a list.

> insertionSort :: (a -> a -> Bool) -> [a] -> [a]
> insertionSort _ []     = []
> insertionSort p (x:xs) = insert p x (insertionSort p xs)

Let us test if the function does as it supposed to do.
The following example sorts a list of integer in ascending order.

\begin{spec}
repl> insertionSort (<=) (reverse [1..5])
[1,2,3,4,5]
\end{spec}

As the definition of |insertionSort| is parametric over the comparision function, we can apply different orderings using the same function.
Besides a deterministic order specified by |(<=)| or |(>=)|, there is nothing that stops us to use a non-deterministic comparison function instead.
Consider the following example, where we apply |insertionSort| to the non-deterministic comparison function |coinCmp|.

\begin{spec}
repl> insertionSort coinCmp [1,2,3]
[1,2,3]  [1,3,2]
[2,1,3]  [3,1,2]
[2,3,1]  [3,2.1]
\end{spec}

We see that the expression non-deterministically yields six different results.
All of these results is a permutation of the input list |[1,2,3]|.
Since a list of length $n$ has $2^n$ number of permutations, the example above yields exactly all $2^3=6$ permutations of the list.
Testing |insertionSort| more systematically with EasyCheck reveals that it was not a coincidence that the function yields exactly all permutations.

In order to understand better how |insertSort| computes the pemutations of its input list when applied to |coinCmp|, we take a look at the decision tree for the exemplary call above in \autoref{fig:dtInsert}.
As the comparison function |coinCmp| non-deterministically yields |True| and |False|, the decision tree of our example reflects all possible control flows for |insertionSort| depending on the results of |coinCmp|.

\begin{figure}[t]
\begin{alltt}
?1
├── L: ?8
│       ├── L: [1,2,3]
│       └── R: ?b
│               ├── L: [2,1,3]
│               └── R: [2,3,1]
└── R: ?8
        ├── L: [1,3,2]
        └── R: ?b
                ├── L: [3,1,2]
                └── R: [3,2,1]
\end{alltt}
\caption{Decision tree for |insertionSort coinCmp [1,2,3]| as produced by KiCS2}
\label{fig:dtInsert1}
\end{figure}

We already introduced the option to draw the decision tree for a non-deterministic expression in \autoref{ch:dp}.
In this example we do not care about the numbering of the choices as sharing is not used in the definition of |insert| nor |insertionSort|.
That is, all choice numbers within one path are unique.
Moreover, all branches in this decision tree correspond to non-determinism spawned by |coinCmp|.
We observe that |insertionSort| traverses the input list and spawns two branches for each element of that list in all paths.
Hence, we end up with a exponential number of results with respect to the length of the input list.
An interesting insight that we, unfortunately, do not gain from the decision tree is \emph{how} exactly the permutations are computed on the way.
In order to make the computation more transparent, we adjust the above decision tree and annotate each branch point with the comparison that takes place.
That is, as each branch corresponds to a application of |coinCmp| to arguments, we can annotate the branches with these arguments.
\autoref{fig:dtInsert1} displays the modified decision tree.

\begin{figure}[t]
\begin{alltt}
2 <= 3
├── L: 1 <= 2
│       ├── L: [1,2,3]
│       └── R: 1 <= 3
│               ├── L: [2,1,3]
│               └── R: [2,3,1]
└── R: 1 <= 3
        ├── L: [1,3,2]
        └── R: 1 <= 2
                ├── L: [3,1,2]
                └── R: [3,2,1]
\end{alltt}
\caption{Modified decision tree for |insertionSort coinCmp [1,2,3]| to highlight compared elements of the list}
\label{fig:dtInsert2}
\end{figure}

Note that the first comparison is between the last two elements of the list: |2| and |3|.
Thus, |insertionSort| starts by inserting the last element into the empty list, moves one position to the front at each recursive step and inserts the next element to the currently accumulated list.
Depending on the decision of |coinCmp| that takes place when evaluating |insert|, the element to be inserted moves one position to the right in the resulting list.
For example, the decisions that lead to the permutation |[1,2,3]| are that |2| and |3| as well as |1| and |2| relate with respect to |coinCmp|.
The first decision leads to the temporary list [2,3], as |2| and |3| are already in the correct order.
As next step we want to insert |1|; as |1| and |2| are in the correct order as well, we insert |1| at the front of the list yielding the resulting permutation [1,2,3].

We take a second step to demystify the generation of permutations using |coinCmp| as predicate.
Let us revise the implementation of |insert| by inlining the applied predicate |coinCmp|.

> insertCoin :: a -> [a] -> [a]
> insertCoin x []     = [x]
> insertCoin x (y:ys) = x:y:ys ? y : insertCoin x ys

This variant of |insert| is exactly the definition of a non-deterministic insertion that is used to define a permutation function, for example in the overview of Curry by \citet{hanus1994integration}.

\subsection{SelectionSort}
Next, we consider the permutation function derived from selection sort.
The key idea of selection sort is to find the minimum of the list and placing it to the front of the resulting list.
First, we define a function to find a minimum of a given list parametrised by the comparision function.

> minList :: (a -> a -> Bool) -> [a] -> a
> minList _ [x]      = x
> minList p (x:y:ys) = min p x (minList p (y:ys))
>

The function |minList| is partial, because we cannot yield a value in case of the empty list.
If the list has one element, we yield that element, otherwise we compare the first element with the minimum of the remaining list.
That is, we define a helper function |min|, a parametrised version of a function that takes two arguments and yields the smaller one.

> min :: (a -> a -> Bool) -> a -> a -> a
> min p x y  | p x y     = x
>            | otherwise = y

After picking a minimum, we need to delete that minimum from the list to recursively sort the remaining list.
We define |delete| to remove an element from a list.

> delete :: Eq a => a -> [a] -> [a]
> delete _ [] = []
> delete x (y:ys)  | x == y     = ys
>                  | otherwise  = y : delete x ys

Here, it is crucial that we use the comparision function |(==)| to make sure that the element is correctly removed from the list.
Now we can define |selectionSort|: we pick the minimum of the input list, place it into the front of the resulting list, and continue with the list without the minimum.

> selectionSort :: Eq a => (a -> a -> Bool) -> [a] -> [a]
> selectionSort _ []         = []
> selectionSort p l@(_ : _)  =  let y = minList p l
>                               in y : selectionSort p (delete y l)

We are ready to take a look at the resulting permutations.

\begin{spec}
repl> selectionSort coinCmp [1,2,3]
[1,2,3]  [2,3,1]
[1,3,2]  [3,1,2]
[2,1,3]  [3,2,1]
\end{spec}

Exactly like |insertionSort|, we see that |selectionSort| yields exactly the permutations of the input list.
One difference of both implementation comes apparent when we look at the type: |selectionSort| has an |Eq|-constraint on the elements of the list.
As the resulting |Eq|-contraint brakes with the general scheme that we parametrise all functions with a comparision function, we define a function |pickMin| that finds the minimum and yields the remaining list in one traversal of the input list.

> pickMin :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMin _ [x]     = (x,[])
> pickMin p (x:xs@(_ : _))  =  let (m,l) = pickMin p xs
>                              in if p x m then (x,xs) else (m,x:l)

We adapt the implementation of |selectionSort| to use |pickMin| instead of using a combination of |minList| and |delete| as follows.

> selectionSortPick :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortPick _ []         = []
> selectionSortPick p l@(_ : _)  =  let (m,l') = pickMin p l
>                                   in m : selectionSortPick p l'

Evaluating our example once again but with the adapted implementation yields the expected results.

\begin{spec}
repl> selectionSortPick coinCmp [1,2,3]
[1,2,3]  [2,3,1]
[1,3,2]  [3,1,2]
[2,1,3]  [3,2,1]
\end{spec}

%if False

> pickMinCase :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinCase p xs = case xs of
>                 [x] -> (x,[])
>                 x:xs -> let (m,l) = pickMinCase p xs
>                         in if p x m then (x,m:l) else (m, x:l)

> pickMin' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMin' _ [x]     = (x,[])
> pickMin' p (x:xs@(_ : _))  =  let (m,l) = pickMin' p xs
>                               in if p x m then (x,xs) else (m, x:l)

> pickMinCase' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinCase' p xs = case xs of
>                      [x] -> (x,[])
>                      y:ys -> let (m,l) = pickMinCase' p ys
>                              in if p y m then (y,ys) else (m, y:l)

> selectionSortPick' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortPick' _ []         = []
> selectionSortPick' p l@(_ : _)  =  let (m,l') = pickMin' p l
>                                    in m : selectionSortPick' p l'

> selectionSortPickCase' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortPickCase' _ []         = []
> selectionSortPickCase' p l@(_ : _)  =  let (m,l') = pickMinCase' p l
>                                        in m : selectionSortPickCase' p l'

> selectionSortDel :: Eq a => (a -> a -> Bool) -> [a] -> [a]
> selectionSortDel _ []       = []
> selectionSortDel p l@(_:_)  =  let y = minList p l
>                                in y : selectionSortDel p (delete y l)

> delete' :: (a -> a -> Bool) -> a -> [a] -> [a]
> delete' p _ [] = []
> delete' p x (y:ys)  | p x y     = ys
>                     | otherwise = y : delete' p x ys

> selectionSort'' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSort'' _ []       = []
> selectionSort'' p l@(_ : _)  =  let y = minList p l
>                                 in y : selectionSort'' p (delete' (\x y -> p x y && p y x) y l)

> pickMinS :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinS _ [x]     = (x,[])
> pickMinS p (x:xs@(_ : _))  = case pickMinS p xs of
>                                (m,l) -> if p x m then (x,xs) else (m,x:l)
>
> pickMinS' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinS' _ [x]             = (x,[])
> pickMinS' p (x:xs@(_ : _))  = uncurry (,)  (case pickMinS' p xs of
>                                              (m,l) -> if p x m then (x,xs) else (m,x:l))
>
> selectionSortS :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortS _ []       = []
> selectionSortS p l@(_ : _)  =  case pickMinS p l of
>                                  (m,l') -> m : selectionSortS p l'

> pickCoin :: [a] -> (a,[a])
> pickCoin [x] = (x,[])
> pickCoin (x:xs@(_:_)) = (x,xs) ? fSnd (x:) (pickCoin xs) --let (m,l) = pickCoin xs in (m, x:l)
>  where fSnd f (a,b) = (a, f b)
>
> selectionSortCoin :: [a] -> [a]
> selectionSortCoin [] = []
> selectionSortCoin xs@(_ : _) = case pickCoin xs of
>                                 (m,l) -> m : selectionSortCoin l

%endif

Due to the let-bindings used in the implementation of |selectionSortPick| as well as the auxiliary function |pickMin|, the corresponding decision tree is not as easy to look at as for |insertionSort|.
Instead, we take a look at the decision tree for |pickMin| and |minList| in \autoref{fig:select1}.

\begin{figure}
\begin{minipage}{0.50\textwidth}
\begin{alltt}
?3
├── L: (1,[2,3])
└── R: ?6
        ├── L: ?6
        │       ├── L: (2,[1,3])
        │       └── R: (2,[1,2])
        └── R: ?6
                ├── L: (3,[1,3])
                └── R: (3,[1,2])
\end{alltt}
\end{minipage}
\vline $\quad$
\begin{minipage}{0.44\textwidth}
\begin{alltt}
?4
├── L: 1
└── R: ?8
        ├── L: 2
        └── R: 3





\end{alltt}
\end{minipage}
\caption{Decision trees for the expressions |pickMin coinCmp [1,2,3]| (left) and |minList coinCmp [1,2,3]| (right)}
\label{fig:select1}
\end{figure}

Note that the decision tree for |pickMin| is an example for the visualisation of sharing: the decision labeled \emph{?6} occurs in each of the two preceding subtrees again.
This decision origins in the usage of the let-binding for the recursive call in the second rule for |pickMin|.
The recursive call |(m,l) = pickMin p xs| binds the minimum and the list without that minimum to the variables |m| and |l|, respectively.
This example is an instance for space leaks that we mentioned in \autoref{ch:dp}.
In particular, we cannot use case-expressions without altering the non-strictness-property of the original definition using let-bindings.
Therefore, in the following, we represent decision trees in a reduced version, where we fuse shared decisions by only displaying the branches that would be considered in a search traversal.
We compute this reduced decision tree by computing the internal representation by means of |someSearchTree|.
That is, the following expression computes the decision tree for the exemplary application of |selectionSortPick| from above.

\begin{spec}
putStrLn (showSearchTree (someSearchTree (selectionSortPick coinCmp [1,2,3])))
\end{spec}
\noindent
\autoref{fig:select} displays the output of this expression --- with the additional modification that we label branches with the corresponding comparisons.

\begin{figure}
\begin{alltt}
1 <= _ (*)
├─ 2 <= 3
│  ├─ [1,2,3]
│  └─ [1,3,2]
└─ 2 <= 3
   ├─ 1 <= 3
   │  ├─ [2,1,3]
   │  └─ [2,3,1]
   └─ 1 <= 2
      ├─ [3,1,2]
      └─ [3,2,1]
\end{alltt}
\caption{Reduced decision tree for |selectionSortPick coinCmp [1,2,3]|}
\label{fig:select}
\end{figure}

As an interesting aside, note that we cannot give the second argument of the comparison for the first branch --- marked with \emph{(*)} in \autoref{fig:select}.
This is due to the fact that |coinCmp| does not demand its second argument.
In the example above the second argument is the expression |pickMin coinCmp [2,3]|; a demand is only necessary if we want to compute the entire list structure of the first solution.
We can observe this non-strict behaviour when computing only the head element of the resulting permutations.
Consider the following expressions involving a list with |failed| as element.

\begin{spec}
repl> selectionSortPick coinCmp [1,failed]
repl> head (selectionSort coinCmp [1,failed])
1
\end{spec}
\noindent
In theory, the permutations of the list |[1,failed]| are |[1,failed]| and |[failed,1]|; in practice, the expression |failed| is not a value like |42| or |True|, printing |failed| in the REPL propagates the failure to the top-level, so no results are printed.\footnote{Note that KiCS2 does not behave consistent with respect to printing |failed|. A deterministic expression based on |failed| will be printed using |!| as symbol, for non-determinstic expressions, however, no results will be printed.}
The first expression computes all possible permutations, but the expression does not have any results: |failed| causes the computation propagate the failure to the top-level.
The second expression, however, computes only the head element and yields indeed a solution.
That is, in order to yield the first element of the first list, we do no need to compute any further elements of the input list.

\subsection{BubbleSort}

The next sorting function we examine is bubble sort.
We define an implementation of the bubble slort algorithm that bubbles the minimum element to the front of a list.
Bubbling to the front of the list allows for a more efficient implementation with respect to the selecting the minimum and the remaining list.
The following function |bubble| defines the bubbling of the minimum element of the list to the front.

> bubble :: (a -> a -> Bool) -> [a] -> [a]
> bubble _ [x]             = [x]
> bubble p (x:xs@(_ : _))  =  let (y:ys) = bubble p xs
>                             in if p x y then x:y:ys else y:x:ys

%if False

> bubble2 :: (a -> a -> Bool) -> [a] -> [a]
> bubble2 _ [x]              = [x]
> bubble2 p (x:xs@(y : ys))  = if p x y then x : bubble2 p (y:ys) else y : bubble2 p (x:ys)
>
> bubble' :: (a -> a -> Bool) -> [a] -> [a]
> bubble' _ [x]             = [x]
> bubble' p (x:xs@(_ : _))  =  let (y:ys) = bubble' p xs
>                              in if p x y then x:xs else y:x:ys
>
> bubbleSort2 :: (a -> a -> Bool) -> [a] -> [a]
> bubbleSort2 _ []       = []
> bubbleSort2 p xs@(_:_) = let (y:ys) = bubble2 p xs in y : bubbleSort2 p ys

%endif

When used with a deterministic comparison function like |(<=)|, the implementation potentially bubbles more than one local minimum to the beginning of the list.

\begin{spec}
repl> bubble (<=) [2,3,4,1]
[1,2,3,4]
repl> bubble (<=) [1,3,4,2]
[1,2,3,4]
repl> bubble (<=) [2,1,4,3]
[1,2,3,4]\end{spec}

Using a non-deterministic comparison function like |coinCmp|, enumerates all possible \emph{bubblings}.
Consider the following two examples.

\begin{spec}
repl>  bubble coinCmp [1,2,3]
[1,2,3]   [2,1,3]
[1,3,2]   [3,1,2]

repl> bubble coinCmp [1,2,3,4]
[1,2,3,4]  [2,1,3,4]
[1,2,4,3]  [2,1,4,3]
[1,3,2,4]  [3,1,2,4]
[1,4,2,3]  [4,1,2,3]
\end{spec}

We can now define |bubbleSort| by means of |bubble|: |bubble| gives us easy access to the minimum of the list that we use as head element and sort the remaining list recursively.

> bubbleSort :: (a -> a -> Bool) -> [a] -> [a]
> bubbleSort _ []       = []
> bubbleSort p xs@(_ : _) = let (y:ys) = bubble p xs in y : bubbleSort p ys

Finally, the application of a sorting function to the non-deterministic comparison function |coinCmp| yields more results than expected.

\begin{spec}
repl> bubbleSort coinCmp [1,2,3]
[1,2,3]    [2,1,3]
[1,3,2]    [2,3,1]
[1,3,2]    [3,1,2]
[1,2,3]    [3,2,1]
\end{spec}

Instead of six results corresponding to all permutations of the input list, we observe that two permutation are computed twice: |[1,2,3]| and |[1,3,2]|.
In order to understand how these duplicates are computed, we take a look at the decision tree for the example call above listed in \autoref{fig:bubble}.
\begin{figure}
\begin{alltt}
1 <= head (bubble [2,3])
├─ 2 <= head (bubble [3])       ***/*
│  ├─ 2 <= head (bubble [3])    ***
│  │  ├─ [1,2,3]
│  │  └─ [1,3,2]                <<<
│  └─ 3 <= head (bubble [2])    ****
│     ├─ [1,3,2]
│     └─ [1,2,3]                <<<<
└─ 2 <= head (bubble [3])
   ├─ 1 <= head (bubble [3])
   │  ├─ [2,1,3]
   │  └─ [2,3,1]
   └─ 1 <= head (bubble [2])
      ├─ [3,1,2]
      └─ [3,2,1]
\end{alltt}
\caption{Reduced and modified decision tree for |bubbleSort coinCmp [1,2,3]|}
\label{fig:bubble}
\end{figure}
Note that the second argument of the comparision function |coinCmp| are unevaluated expressions, again --- we have already seen a similar example when talking about |selectionSort|.
The computation of all results in the REPL as well as drawing the decision tree demand the evaluation of expressions like |head (bubble [2,3])|\footnote{The actual expression appearing in the evaluation steps is a let-binding that references the head element in the comparision. That is, |let (x:xs) = bubble [2,3] in if 1 <= x then ... else ...| is closer to the expressions occuring during the evaluation.} not until the corresponding list element will be printed.
The new thing about the decision tree for an application of |bubbleSort| is that some results occur twice.
The duplicated results are marked with \texttt{<<<} and \texttt{<<<<}, respectively.
Note, that it is by intention that we marked the first occurence in case of |[1,3,2]| and the second one in case of the result |[1,2,3]|.
Consider the path from the root to the result marked with \texttt{<<<}.
The crucial parts are the comparison marked with \texttt{***}: we compare |2| and |bubble [3]| twice.
In a setting where we use a deterministic comparision function, the first path to |[1,3,2]| does not make any sense.
The decision for the first comparison |2 <= bubble [3]| yields |True| --- otherwise we would not take the first branch, that is, doing the same comparision a second time should like |True| again.
In the path from the root to the first occurence |[1,3,2]|, the comparision of |2| and |bubble [3]| yields |True| the first and |False| the second time.
Note that there is no deterministic comparision function that yields |True| for a comparision first and |False| later.
In the following we reference this property as \emph{behaving consistently}: a non-deterministic predicate behaves consistently, if it yields the same Boolean value for every application to the same values.

The other result marked with \texttt{<<<<} is the second occurence of |[1,2,3]|.
Here, the relevant comparisons taken on the path are |2 <= bubble [3]| and |3 <= head (bubble [2])|.
Note that the |head (bubble [x])| evaluates to |x| for all |x| of appropriate type.
That is, |head (bubble [3]) = 3| and |head (bubble [2]) = 2|.
Below we only reference the comparisons with the evaluated function calls to simplify the reasoning.
As the second comparison takes place in the second branch of the decision corresponding to |2 <= 3|, we know that the decision was |False|.
That is, |2| is not smaller or equal than |3|, |2| is greater than |3|.
We then take the second branch for the decision |3 <= 2|: |2| is greater than |3|.
Note that this decision does not make any sense when using |bubbleSort| with a reasonable comparision function like |(<=)| on integer values.
The important property missing here is that the relation described by |<=| needs the connex property.
The connex property describes that any two pairs of elements of appropriate type are comparable with respect to |<=|.
Binary relations that are total orders (like for example the smaller-or-equal-than-relation on integers) fulfill the connex property by definition.
That is, the implementation of |bubbleSort| needs to be used with an comparison function corresponding to a binary relation that is a total order, otherwise it cannot sort all lists correctly.

\subsection{QuickSort}

In this section we take a look at an implementation of \emph{quicksort} that is known for its particular declarative realisation.
The general idea behind the quicksort algorithm is to choose a pivot element and split the remaining list into two parts: one with all elements that are smaller or equal than the pivot and one with the all elements that do not fulfil this criterion.
The algorithm is then recursively applied to these two sublists.

The following function |quickSort| uses the head element of the given list as pivot element and the function |filter| to split the input list into the two parts.

> quickSort :: (a -> a -> Bool) -> [a] -> [a]
> quickSort _  []      = []
> quickSort p  (x:xs)  =  let  l1 = filter (\y -> p y x) xs
>                              l2 = filter (\y -> not $ p y x) xs
>                         in quickSort p l1 ++ x : quickSort p l2

Let us take a look at the resulting permutations for exemplary calls.

\begin{spec}
repl> quickSort coinCmp [1,2]
[2,1]
[2,1,2]
[1]
[1,2]

repl> length (allValues (quickSort coinCmp [1,2,3]))
49

repl> length (allValues (quickSort coinCmp [1,2,3]))
4225
\end{spec}

That escalated quickly.
The first example call was already odd: for a list with two elements we get four results, of which two are not even permutations of the original list.
The second and third example illustrates why did not evaluate all results for a list with more than 2 elements: the number of results grows way worse than expected for an algorithm that enumerates permutations.
The expected number of results for three elements is $3!=6$ and $4!=24$ for four elements, respectively.

A quick look at the two filter calls alone will get us closer to understand what is going on here.

\begin{spec}
repl> filter (coinCmp 1) [2]
[2]
[]

repl> filter (not . coinCmp 1) [2]
[]
[2]
\end{spec}

Both bindings, |l1| and |l2|, evaluate to the same two values, just in reversed order.
These two times two sublists yield four overall results, since all lists for |l1| are combined with all lists of |l2| to yield |l1 ++ x : l2|.
In general, the resulting function enumerates the cross product of all subsequences of the input list.

We can again observe that the definition of |quickSort| uses the comparison function |coinCmp| inconsistently, thus, yields the same results for both application of filter.
Using a determinstic comparision function |p|, the sublists |l1| and |l2| would be disjunct, since we are using |p| for the first and |not . p| for the second list.

We can overcome this drawback when using two |filter| applications by using |split| instead.
The function |split :: (a -> Bool) -> [a] -> ([a],[a])| traverses a list only once to split it into two sublists fulfiling exactly the property we use above: the first list contains only elements that fulfill the given predicate and the second list contains the elements that do not.
We define |split| as follows; note, that it is crucial that split traverses its input list only once.

> split :: (a -> a -> Bool) -> a -> [a] -> ([a],[a])
> split p x l = split' l ([],[])
>  where
>   split' [] ls                          = ls
>   split' (y:ys) (l1,l2)  | not (p x y)  = split' ys (l1,y:l2)
>                          | otherwise    = split' ys (y:l1,l2)

Based on |split| we can define a second version of quick sort.
We reuse the variable names |l1| and |l2| for the two sublists to indicate the the underlying idea of the algorithm stays exactly the same.

> quickSortSplit :: (a -> a -> Bool) -> [a] -> [a]
> quickSortSplit _ []     = []
> quickSortSplit p (x:xs) =  let (l1,l2) = split p x xs
>                            in quickSortSplit p l1 ++ x : quickSortSplit p l2

Let us once again take a look at the resulting permutations.

\begin{spec}
repl> quickSortSplit coinCmp [1,2,3]
[2,3,1]   [3,1,2]
[3,2,1]   [1,2,3]
[2,1,3]   [1,3,2]
\end{spec}

As |split| only traverses its input list once, each comparison happens only once.
The pivot element is compared to each element of the remaining list, the recursive calls to |quickSortSplit| then pick new pivot elements that are used for comparison.
That is, we end up with exact all permutations of the input list, again.

\subsection{MergeSort}

Last but not least, we take a look at merge sort.
The general idea of the sorting algorithm it to divide the input list of length $n$ into $n$ sublists, that is, all sublists are singleton lists.
These singleton lists, which are trivially sorted, are merged into new sorted sublists.
The merging is repeated until only one list is remaining: the resulting sorted list.

First, we define a function |divideN| to divide the input lists into two lists of the same length.

> divideN :: [a] -> ([a],[a])
> divideN xs = divideN' xs (length xs `div` 2)
>  where  divideN' []      _  = ([],[])
>         divideN' (y:ys)  n  | n == 0     = ([],y:ys)
>                             | otherwise  =  let (l1,l2) = divideN' ys (n-1)
>                                             in (y:l1,l2)


Second, we define a function |merge| that merges two lists based on a comparison function.

> merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
> merge _ []     l       = l
> merge _ (x:xs) []      = x:xs
> merge p (x:xs) (y:ys)  | p x y      = x : merge p xs (y:ys)
>                        | otherwise  = y : merge p (x:xs) ys

The first two rules cover the cases that it is not necessary to merge if one of lists is empty, we just yield the other one.
If both lists are non-empty, we decide based on the comparison function |p| which element to put at the front of the resulting list and merge recursively with the remaining lists.
Note that we assume that both list arguments of |merge| are already sorted.
Finally, we define the overall sorting function |mergeSort| that uses |divideN| to divide the lists into two sublists that are sorted recursively, and |merge| to merge the sorted sublists.
 
> mergeSort :: (a -> a -> Bool) -> [a] -> [a]
> mergeSort _ []               = []
> mergeSort _ [x]              = [x]
> mergeSort p l@(_ : (_ : _))  =  let (l1,l2) = divideN l
>                                 in merge p (mergeSort p l1) (mergeSort p l2)

Once again we take a look at an exemplary application of |mergeSort| to the non-deterministic comparison function |coinCmp|.

\begin{spec}
repl> mergeSort coinCmp [1,2,3]
[1,2,3]   [1,3,2]
[2,1,3]   [3,1,2]
[2,3,1]   [3,2,1]
\end{spec}

We are pleased to observe that the resulting function enumerates exactly all permutations.
The procedure follows by |mergeSort| does not make any redundant comparisons.
The first step of dividing the list into sublists is not based on the predicate but based on the length of the list only.
The comparison take place when using |merge|.
As |merge| has the precondition that both argument list are already sorted, it is sufficient to compare the lists head-wise.
That is, if one head element is smaller than the other head element, the former is put in front of the list and does not need to be considered anymore.
The utilisation of the precondition leads to a efficient sorting algorithm: no two elements are compared more than once.

\section{Non-deterministic Sorting Functions in Haskell}
\subsection{Modelling Non-determinism}
\begin{itemize}
\item using list monad
\item generalisation to arbitrary monad: enables usage of set-based instance as well
\end{itemize}
\subsection{Exemplary Sorting Functions}
\begin{itemize}
\item monadic abstraction for sorting function sufficient; |?|-like operator only necessary for comparison function
\end{itemize}
\subsection{Curry vs Monadic Non-determinism}
\begin{itemize}
\item non-determinism is not visible at the type-level
\item non-determinism can occur in constructor components (deep vs. flat)
\item thus, non-determinism can be non-stricter than instances using lists (or trees)
\end{itemize}
\subsection{Getting Rid of Duplicates}
\begin{itemize}
\item drawing decision tree using free monad
\item properties of predicates to prevent duplicates
  \begin{itemize}
  \item state monad to track result of compared pairs
  \item consistency, totality, transitivity
  \end{itemize}
\end{itemize}

\section{Conclusion and Future Work}
\begin{itemize}
\item specific enumerations of permutations (lexicographic sorting, even/odd sorting, only one transposition from one to the next)
\item possibility to produce derangements
\item other functions parametrised by predicates
\item investigate strictness properties and running time complexity of permutation enumeration function
\end{itemize}

\section{Final Remarks}
\begin{itemize}
\item ICFP publication with additional proofs
\item bachelor's thesis with adaptation to Curry
\end{itemize}