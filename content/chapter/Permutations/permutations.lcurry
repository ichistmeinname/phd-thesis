The most prominent combination of sorting functions and non-determinism is permutation sort, a sorting algorithm that generates all permutation and selects the one that is sorted to yield as result.
This sorting function has a bad running time: the best case performs in $O(2^n)$ for an input list of length $n$.
On the good side, we can argue that the worst case is as good as the best case.
However, the best case is also as bad as the worst case.

In this chapter we shed some light on a different combination of sorting functions and non-determinism: we enumerate permutations by applying sorting functions to a non-deterministic comparison function.
First, we take a look at implementations of some famous sorting functions in Curry and define a suitable comparison functions to enumerate permutations.
Thanks to Curry's built-in non-determinism we can reuse all common sorting functions as they are.
We discuss the resulting permutation enumeration functions, the number of results is of special interest here.
A selection of questions that we will answer read as follows.

\begin{itemize}
\item Can we enumerate all possible permutations of the input list using any sorting function?
\item Is there a sorting function that can enumerate exactly the permutations of the input list?
\item Can we visualise how a sorting function enumerates the permutations?
\end{itemize}

As a quick teaser for these question, we anticipate that all (correct) sorting functions indeed enumerate every permutation of the input list at least once. However, enumerating every permutation exactly once is a property that not all sorting functions share.

In the second part of this chapter we transfer our implementation in Curry to Haskell.
One possible model of non-determinism in a functional language is to use lists to represent all non-deterministic results.
We go even one step further and generalise all functions to monadic functions.
Using these monadically lifted functions, we try out different representation of non-determinism --- like multi-sets, sets, or trees --- but need only one implementation of the sorting function.
We compare the monadic representation of non-determinism with the built-in non-determinism of Curry by means of these sorting functions to enumerate permutations.

The main observation of the comparison is that Curry's built-in non-determinism can be less strict than a naive monadic model in Haskell.
This observation is not new, there are other applications that exploit this advantage as well, it is an interesting use case of this advantage nonetheless.

Last but not least, we leverage the monadic implementation of the sorting functions to discuss possibilities to get rid of duplicates when enumerating permutations.
The main idea here is to enhance the underlying monad to track the decisions the non-deterministic comparison function makes when traversing the input list.

In summary, this chapter makes the following contributions.

\begin{itemize}
\item We inspect sorting functions implemented in Curry and apply these functions to a non-deterministic comparison function and a given list to enumerate permutations of that given list.
\item When taking a closer look at the resulting lists, we observe that the functions enumerate every possible permutation of the input list at least once.
\item Some sorting functions yield duplicate results, we investigate why these duplicates emerge.
\item Furthermore, we discover that some sorting functions even enumerate lists that are not a permutation of the input list.
\item As a second step, we transfer the sorting functions to Haskell and model non-determinism explicitly using monads.
\item Thanks to the flexibility of using monads, we can enrich the non-deterministic comparison function which necessary properties to eliminate duplicate results. We show three examples for properties that yield to an enumeration of the exact number of permutations for sorting functions that yield too many results with a simple non-deterministic comparison function.
\item At last, we discuss a variety of questions that follow from the results and observations presented above.
\end{itemize}

\section{Non-deterministic Sorting Functions in Curry}

\begin{itemize}
\item examples use integer, but arbitrary types can be used
\item integer values represent positions within the list
\item less than although the comparison function could be an arbitrary one
\item argue about sorting function enumerating all permutations as otherwise it couldn't sort the list that was not enumerated
\end{itemize}

Consider the following non-deterministic comparison function that ignores both its arguments and non-deterministically yields |True| and |False|.

> coinCmp :: a -> a -> Bool
> coinCmp _ _ = True ? False

The name |coinCmp| suggests a similarity to the popular |coin|-definition as an example for non-determinism; the difference here is that we define a two-ary function with a non-deterministic result, whereas |coin| is a nullary function.

\label{sec:sortCurry}

\subsection{InsertionSort}
\label{subs:insertion}
The first sorting function we take a look at is insertion sort.
The key idea behind the sorting algorithm is to traverse the input list and insert each element in the right position within the resulting list.
That is, the element in focus is inserted in front of the first element of the list that is greater than or equal to the former.
In order to implement |insertionSort|, we implement a function |insert| first that does exactly that task: it inserts an element in a list with respect to the given comparison function.

> insert :: (a -> a -> Bool) -> a -> [a] -> [a]
> insert _ x []                 = [x]
> insert p x (y:ys) | p x y     = x:y:ys
>                   | otherwise = y : insert p x ys

We then define |insertionSort| using |insert| to sort a list.

> insertionSort :: (a -> a -> Bool) -> [a] -> [a]
> insertionSort _ []     = []
> insertionSort p (x:xs) = insert p x (insertionSort p xs)

Let us test if the function does as it supposed to do.
The following example sorts a list of integer in ascending order.

\begin{spec}
repl> insertionSort (<=) (reverse [1..5])
[1,2,3,4,5]
\end{spec}

As the definition of |insertionSort| is parametric over the comparision function, we can apply different orderings using the same function.
Besides a deterministic order specified by |(<=)| or |(>=)|, there is nothing that stops us to use a non-deterministic comparison function instead.
Consider the following example, where we apply |insertionSort| to the non-deterministic comparison function |coinCmp|.

\begin{spec}
repl> insertionSort coinCmp [1,2,3]
[1,2,3]  [1,3,2]
[2,1,3]  [3,1,2]
[2,3,1]  [3,2.1]
\end{spec}

We see that the expression non-deterministically yields six different results.
All of these results is a permutation of the input list |[1,2,3]|.
Since a list of length $n$ has $2^n$ number of permutations, the example above yields exactly all $2^3=6$ permutations of the list.
Testing |insertionSort| more systematically with EasyCheck reveals that it was not a coincidence that the function yields exactly all permutations.

In order to understand better how |insertSort| computes the pemutations of its input list when applied to |coinCmp|, we take a look at the decision tree for the exemplary call above in \autoref{fig:dtInsert}.
As the comparison function |coinCmp| non-deterministically yields |True| and |False|, the decision tree of our example reflects all possible control flows for |insertionSort| depending on the results of |coinCmp|.

\begin{figure}[t]
\begin{alltt}
?1
├── L: ?8
│       ├── L: [1,2,3]
│       └── R: ?b
│               ├── L: [2,1,3]
│               └── R: [2,3,1]
└── R: ?8
        ├── L: [1,3,2]
        └── R: ?b
                ├── L: [3,1,2]
                └── R: [3,2,1]
\end{alltt}
\caption{Decision tree for |insertionSort coinCmp [1,2,3]| as produced by KiCS2}
\label{fig:dtInsert1}
\end{figure}

We already introduced the option to draw the decision tree for a non-deterministic expression in \autoref{ch:dp}.
In this example we do not care about the numbering of the choices as sharing is not used in the definition of |insert| nor |insertionSort|.
That is, all choice numbers within one path are unique.
Moreover, all branches in this decision tree correspond to non-determinism spawned by |coinCmp|.
We observe that |insertionSort| traverses the input list and spawns two branches for each element of that list in all paths.
Hence, we end up with a exponential number of results with respect to the length of the input list.
An interesting insight that we, unfortunately, do not gain from the decision tree is \emph{how} exactly the permutations are computed on the way.
In order to make the computation more transparent, we adjust the above decision tree and annotate each branch point with the comparison that takes place.
That is, as each branch corresponds to a application of |coinCmp| to arguments, we can annotate the branches with these arguments.
\autoref{fig:dtInsert1} displays the modified decision tree.

\begin{figure}[t]
\begin{alltt}
2 <= 3
├── L: 1 <= 2
│       ├── L: [1,2,3]
│       └── R: 1 <= 3
│               ├── L: [2,1,3]
│               └── R: [2,3,1]
└── R: 1 <= 3
        ├── L: [1,3,2]
        └── R: 1 <= 2
                ├── L: [3,1,2]
                └── R: [3,2,1]
\end{alltt}
\caption{Modified decision tree for |insertionSort coinCmp [1,2,3]| to highlight compared elements of the list}
\label{fig:dtInsert2}
\end{figure}

Note that the first comparison is between the last two elements of the list: |2| and |3|.
Thus, |insertionSort| starts by inserting the last element into the empty list, moves one position to the front at each recursive step and inserts the next element to the currently accumulated list.
Depending on the decision of |coinCmp| that takes place when evaluating |insert|, the element to be inserted moves one position to the right in the resulting list.
For example, the decisions that lead to the permutation |[1,2,3]| are that |2| and |3| as well as |1| and |2| relate with respect to |coinCmp|.
The first decision leads to the temporary list [2,3], as |2| and |3| are already in the correct order.
As next step we want to insert |1|; as |1| and |2| are in the correct order as well, we insert |1| at the front of the list yielding the resulting permutation [1,2,3].

We take a second step to demystify the generation of permutations using |coinCmp| as predicate.
Let us revise the implementation of |insert| by inlining the applied predicate |coinCmp|.

> insertCoin :: a -> [a] -> [a]
> insertCoin x []     = [x]
> insertCoin x (y:ys) = x:y:ys ? y : insertCoin x ys

This variant of |insert| is exactly the definition of a non-deterministic insertion that is used to define a permutation function, for example in the overview of Curry by \citet{hanus1994integration}.

\subsection{SelectionSort}
Next, we consider the permutation function derived from selection sort.
The key idea of selection sort is to find the minimum of the list and placing it to the front of the resulting list.
First, we define a function to find a minimum of a given list parametrised by the comparision function.

> minList :: (a -> a -> Bool) -> [a] -> a
> minList _ [x]      = x
> minList p (y:x:xs) = min p y (minList p (x:xs))
>

The function |minList| is partial, because we cannot yield a value in case of the empty list.
If the list has one element, we yield that element, otherwise we compare the first element with the minimum of the remaining list.
That is, we define a helper function |min|, a parametrised version of a function that takes two arguments and yields the smaller one.

> min :: (a -> a -> Bool) -> a -> a -> a
> min p x y  | p x y     = x
>            | otherwise = y

After picking a minimum, we need to delete that minimum from the list to recursively sort the remaining list.
We define |delete| to remove an element from a list.

> delete :: Eq a => a -> [a] -> [a]
> delete _ [] = []
> delete x (y:ys)  | x == y     = ys
>                  | otherwise  = y : delete x ys

Here, it is crucial that we use the comparision function |(==)| to make sure that the element is correctly removed from the list.
As the resulting |Eq| context brakes with the general scheme that we parametrise all functions with a comparision function, we define a function that finds the minimum and yields the remaining list in one traversal of the input list.

> pickMin :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMin _ [x]     = (x,[])
> pickMin p (x:xs@(_ : _))  =  let (m,l) = pickMin p xs
>                              in if p x m then (x,xs) else (m, x:l)

%if False

> selectionSort' :: Eq a => (a -> a -> Bool) -> [a] -> [a]
> selectionSort' _ []       = []
> selectionSort' p l@(_:_)  =  let y = minList p l
>                              in y : selectionSort' p (delete y l)

> delete' :: (a -> a -> Bool) -> a -> [a] -> [a]
> delete' p _ [] = []
> delete' p x (y:ys)  | p x y     = ys
>                     | otherwise = y : delete' p x ys

> selectionSort'' :: (a -> a -> Bool) -> [a] -> [a]
> selectionSort'' _ []       = []
> selectionSort'' p l@(_ : _)  =  let y = minList p l
>                                 in y : selectionSort'' p (delete' (\x y -> p x y && p y x) y l)

%endif

Now we can define |selectionSort|: we pick the minimum of the input list, place it into the front of the resulting list, and continue with the list without the minimum.

> selectionSort :: (a -> a -> Bool) -> [a] -> [a]
> selectionSort _ []         = []
> selectionSort p l@(_ : _)  =  let (m,l') = pickMin p l
>                               in m : selectionSort p l'

%if False

> pickMinS :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinS _ [x]     = (x,[])
> pickMinS p (x:xs@(_ : _))  = case pickMinS p xs of
>                                (m,l) -> if p x m then (x,xs) else (m,x:l)
>
> pickMinS' :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMinS' _ [x]             = (x,[])
> pickMinS' p (x:xs@(_ : _))  = uncurry (,)  (case pickMinS' p xs of
>                                              (m,l) -> if p x m then (x,xs) else (m,x:l))
>
> selectionSortS :: (a -> a -> Bool) -> [a] -> [a]
> selectionSortS _ []       = []
> selectionSortS p l@(_ : _)  =  case pickMinS p l of
>                                  (m,l') -> m : selectionSortS p l'

> pickCoin :: [a] -> (a,[a])
> pickCoin [x] = (x,[])
> pickCoin (x:xs@(_:_)) = (x,xs) ? fSnd (x:) (pickCoin xs) --let (m,l) = pickCoin xs in (m, x:l)
>  where fSnd f (a,b) = (a, f b)
>
> selectionSortCoin :: [a] -> [a]
> selectionSortCoin [] = []
> selectionSortCoin xs@(_ : _) = case pickCoin xs of
>                                 (m,l) -> m : selectionSortCoin l

%endif
We are ready to take a look at the resulting permutations.

\begin{spec}
repl> selectionSort coinCmp [1,2,3]
[1,2,3]  [2,3,1]
[1,3,2]  [3,1,2]
[2,1,3]  [3,2,1]
\end{spec}

Exactly like |insertionSort|, we see that |selectionSort| yields exactly the permutations of the input list.
Due to the let-bindings used in the implementation of |selectionSort| as well as the auxiliary function |pickMin|, the corresponding decision tree is not as easy to look at as for |insertionSort|.
Instead, we take a look at the decision tree for |pickMin| and |minList| in \autoref{fig:select1}.

\begin{figure}
\begin{minipage}{0.50\textwidth}
\begin{alltt}
?3
├── L: (1,[2,3])
└── R: ?6
        ├── L: ?6
        │       ├── L: (2,[1,3])
        │       └── R: (2,[1,2])
        └── R: ?6
                ├── L: (3,[1,3])
                └── R: (3,[1,2])
\end{alltt}
\end{minipage}
\vline $\quad$
\begin{minipage}{0.44\textwidth}
\begin{alltt}
?4
├── L: 1
└── R: ?8
        ├── L: 2
        └── R: 3





\end{alltt}
\end{minipage}
\caption{Decision trees for the expressions |pickMin coinCmp [1,2,3]| (left) and |minList coinCmp [1,2,3]| (right)}
\label{fig:select1}
\end{figure}

Note that the decision tree for |pickMin| is an example for the visualisation of sharing: the decision labeled \emph{?6} occurs in each of the two preceding subtrees again.
This decision origins in the usage of the let-binding for the recursive call in the second rule for |pickMin|.
The recursive call |(m,l) = pickMin p xs| binds the minimum and the list without that minimum to the variables |m| and |l|, respectively.
This example is an instance for space leaks that we mentioned in \autoref{ch:dp}.
In particular, we cannot use case-expressions without altering the non-strictness-property of the original definition using let-bindings.
Therefore, in the following, we represent decision trees in a reduced version, where we fuse shared decisions by only displaying the branches that would be considered in a search traversal.
We compute this reduced decision tree by computing the internal representation by means of |someSearchTree|.
That is, the following expression computes the decision tree for the exemplary application of |selectionSort| from above.

\begin{spec}
putStrLn $ showSearchTree (someSearchTree (selectionSortCoin [1,2,3]))
\end{spec}

\autoref{fig:select} displays the output of this expression --- with the additional modification that we label branches with the corresponding comparisons.
\begin{figure}
\begin{alltt}
2 <= 3
├─ ?
│  ├─ [1,2,3]
│  └─ [1,3,2]
└─ ?
   ├─ ?
   │  ├─ [2,1,3]
   │  └─ [2,3,1]
   └─ ?
      ├─ [3,1,2]
      └─ [3,2,1]
\end{alltt}
\caption{Reduced decision tree for |selectionSort coinCmp [1,2,3]|}
\end{figure}

\subsection{BubbleSort}

> bubble :: (a -> a -> Bool) -> [a] -> [a]
> bubble _ [x] = [x]
> bubble p (x:xs@(_:_)) = let (y:ys) = bubble p xs
>                         in if p x y then x:y:ys else y:x:ys
> 
> bubbleSort :: (a -> a -> Bool) -> [a] -> [a]
> bubbleSort _ []       = []
> bubbleSort p xs@(_:_) = let (y:ys) = bubble p xs in y : bubbleSort p ys

\subsection{QuickSort}

> quickSort' :: (a -> a -> Bool) -> [a] -> [a]
> quickSort' _ []     = []
> quickSort' p (x:xs) = let l1 = filter (\y -> p y x) xs
>                           l2 = filter (\y -> not $ p y x) xs
>                       in quickSort' p l1 ++ x : quickSort' p l2

> quickSort :: (a -> a -> Bool) -> [a] -> [a]
> quickSort _ []     = []
> quickSort p (x:xs) = let t = split p x xs
>                      in quickSort p (fst t) ++ (x:quickSort p (snd t))
> 
> split :: (a -> a -> Bool) -> a -> [a] -> ([a],[a])
> split p x l = split' l ([],[]) where
>   split' [] ls                        = ls
>   split' (y:ys) (l1,l2) | not (p x y) = split' ys (l1,y:l2)
>                         | otherwise   = split' ys (y:l1,l2)


\subsection{MergeSort}

> merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
> merge _ [] l = l
> merge _ (x:xs) [] = x:xs
> merge p (x:xs) (y:ys) | p x y = x : merge p xs (y:ys)
>                       | otherwise = y : merge p (x:xs) ys
> 
> mergeSort :: (a -> a -> Bool) -> [a] -> [a]
> mergeSort p l = let n       = length l `div` 2
>                     (l1,l2) = splitN l n
>                 in if n == 0 then l else merge p (mergeSort p l1) (mergeSort p l2)
> 
> 
> splitN :: [a] -> Int -> ([a],[a])
> splitN [] _ = ([],[])
> splitN (x:xs) n | n == 0 = ([],x:xs)
>                 | otherwise = let (l1,l2) = splitN xs (n-1) in (x:l1,l2)



\section{Non-deterministic Sorting Functions in Haskell}
\subsection{Modelling Non-determinism}
\begin{itemize}
\item using list monad
\item generalisation to arbitrary monad: enables usage of set-based instance as well
\end{itemize}
\subsection{Exemplary Sorting Functions}
\begin{itemize}
\item monadic abstraction for sorting function sufficient; |?|-like operator only necessary for comparison function
\end{itemize}
\subsection{Curry vs Monadic Non-determinism}
\begin{itemize}
\item non-determinism is not visible at the type-level
\item non-determinism can occur in constructor components (deep vs. flat)
\item thus, non-determinism can be non-stricter than instances using lists (or trees)
\end{itemize}
\subsection{Getting Rid of Duplicates}
\begin{itemize}
\item drawing decision tree using free monad
\item properties of predicates to prevent duplicates
  \begin{itemize}
  \item state monad to track result of compared pairs
  \item consistency, totality, transitivity
  \end{itemize}
\end{itemize}

\section{Conclusion and Future Work}
\begin{itemize}
\item specific enumerations of permutations (lexicographic sorting, even/odd sorting, only one transposition from one to the next)
\item possibility to produce derangements
\item other functions parametrised by predicates
\item investigate strictness properties and running time complexity of permutation enumeration function
\end{itemize}

\section{Final Remarks}
\begin{itemize}
\item ICFP publication with additional proofs
\item bachelor's thesis with adaptation to Curry
\end{itemize}