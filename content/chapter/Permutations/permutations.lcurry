The most prominent combination of sorting functions and non-determinism is permutation sort, a sorting algorithm that generates all permutation and selects the one that is sorted to yield as result.
This sorting function has a bad running time: the best case performs in $O(2^n)$ for an input list of length $n$.
On the good side, we can argue that the worst case is as good as the best case.
However, the best case is also as bad as the worst case.

In this chapter we shed some light on a different combination of sorting functions and non-determinism: we enumerate permutations by applying sorting functions to a non-deterministic comparison function.
First, we take a look at implementations of some famous sorting functions in Curry and define a suitable comparison functions to enumerate permutations.
Thanks to Curry's built-in non-determinism we can reuse all common sorting functions as they are.
We discuss the resulting permutation enumeration functions, the number of results is of special interest here.
A selection of questions that we will answer read as follows.

\begin{itemize}
\item Can we enumerate all possible permutations of the input list using any sorting function?
\item Is there a sorting function that can enumerate exactly the permutations of the input list?
\item Can we visualise how a sorting function enumerates the permutations?
\end{itemize}

As a quick teaser for these question, we anticipate that all (correct) sorting functions indeed enumerate every permutation of the input list at least once. However, enumerating every permutation exactly once is a property that not all sorting functions share.

In the second part of this chapter we transfer our implementation in Curry to Haskell.
One possible model of non-determinism in a functional language is to use lists to represent all non-deterministic results.
We go even one step further and generalise all functions to monadic functions.
Using these monadically lifted functions, we try out different representation of non-determinism --- like multi-sets, sets, or trees --- but need only one implementation of the sorting function.
We compare the monadic representation of non-determinism with the built-in non-determinism of Curry by means of these sorting functions to enumerate permutations.

The main observation of the comparison is that Curry's built-in non-determinism can be less strict than a naive monadic model in Haskell.
This observation is not new, there are other applications that exploit this advantage as well, it is an interesting use case of this advantage nonetheless.

Last but not least, we leverage the monadic implementation of the sorting functions to discuss possibilities to get rid of duplicates when enumerating permutations.
The main idea here is to enhance the underlying monad to track the decisions the non-deterministic comparison function makes when traversing the input list.

In summary, this chapter makes the following contributions.

\begin{itemize}
\item We inspect sorting functions implemented in Curry and apply these functions to a non-deterministic comparison function and a given list to enumerate permutations of that given list.
\item When taking a closer look at the resulting lists, we observe that the functions enumerate every possible permutation of the input list at least once.
\item Some sorting functions yield duplicate results, we investigate why these duplicates emerge.
\item Furthermore, we discover that some sorting functions even enumerate lists that are not a permutation of the input list.
\item As a second step, we transfer the sorting functions to Haskell and model non-determinism explicitly using monads.
\item Thanks to the flexibility of using monads, we can enrich the non-deterministic comparison function which necessary properties to eliminate duplicate results. We show three examples for properties that yield to an enumeration of the exact number of permutations for sorting functions that yield too many results with a simple non-deterministic comparison function.
\item At last, we discuss a variety of questions that follow from the results and observations presented above.
\end{itemize}

\section{Non-deterministic Sorting Functions in Curry}

\begin{itemize}
\item examples use integer, but arbitrary types can be used
\item integer values represent positions within the list
\item less than although the comparison function could be an arbitrary one
\end{itemize}

Consider the following non-deterministic comparison function that ignores both its arguments and non-deterministically yields |True| and |False|.

> coinCmp :: a -> a -> Bool
> coinCmp _ _ = True ? False

The name |coinCmp| suggests a similarity to the popular |coin|-definition as an example for non-determinism; the difference here is that we define a two-ary function with a non-deterministic result, whereas |coin| is a nullary function.

\label{sec:sortCurry}

\subsection{InsertionSort}
\label{subs:insertion}
The first sorting function we take a look at is insertion sort.
The key idea behind the sorting algorithm is to traverse the input list and insert each element in the right position within the resulting list.
That is, the element in focus is inserted in front of the first element of the list that is greater than or equal to the former.
In order to implement |insertionSort|, we implement a function |insert| first that does exactly that task: it inserts an element in a list with respect to the given comparison function.

> insert :: (a -> a -> Bool) -> a -> [a] -> [a]
> insert _ x []                 = [x]
> insert p x (y:ys) | p x y     = x:y:ys
>                   | otherwise = y : insert p x ys

We then define |insertionSort| using |insert| to sort a list.

> insertionSort :: (a -> a -> Bool) -> [a] -> [a]
> insertionSort _ []     = []
> insertionSort p (x:xs) = insert p x (insertionSort p xs)

Let us test if the function does as it supposed to do.
The following example sorts a list of integer in ascending order.

\begin{spec}
repl> insertionSort (<=) (reverse [1..5])
[1,2,3,4,5]
\end{spec}

As the definition of |insertionSort| is parametric over the comparision function, we can apply different orderings using the same function.
Besides a deterministic order specified by `(<=)` or `(>=)`, there is nothing that stops us to use a non-deterministic comparison function instead.
Consider the following non-deterministic comparison function that ignores both its arguments and non-deterministically yields |True| and |False|.

> coinCmp :: a -> a -> Bool
> coinCmp _ _ = True ? False

The name |coinCmp| suggests a similarity to the popular |coin|-definition as an example for non-determinism; the difference here is that we define a two-ary function with a non-deterministic result, whereas |coin| is a nullary function.
Next, we want to evaluate |insertionSort| using the non-deterministic comparison function |coinCmp|.

\begin{spec}
repl> insertionSort coinCmp [1,2,3]
[1,2,3]          [2,3,1]
[1,3,2]          [3,1,2]
[2,1,3]          [3,2,1]
\end{spec}

We see that the expression non-deterministically yields six different results.
All of these results is a permutation of the input list |[1,2,3]|.
Since a list of length $n$ has $2^n$ number of permutations, the example above yields exactly all $2^3=6$ permutations of the list.
Testing |insertionSort| more systematically with EasyCheck reveals that it was not a coincidence that the function yields exactly all permutations.

\subsection{SelectionSort}

> delete :: Eq a => a -> [a] -> [a]
> delete _ [] = []
> delete x (y:ys) | x == y    = ys
>                 | otherwise = y : (delete x ys)
> 
> minE :: (a -> a -> Bool) -> a -> a -> a
> minE p x y | p x y     = x
>            | otherwise = y
> 
> minL :: (a -> a -> Bool) -> [a] -> a
> minL _ [x]      = x
> minL p (y:x:xs) = minE p y $ minL p (x:xs)
> 
> 
> selectionSort' :: Eq a => (a -> a -> Bool) -> [a] -> [a]
> selectionSort' _ []     = []
> selectionSort' p l@(_:_) = let y = minL p l
>                            in y : (selectionSort' p (del y l))

> pickMin :: (a -> a -> Bool) -> [a] -> (a,[a])
> pickMin _ [x]      = (x,[])
> pickMin p (x:xs@(y:_)) = let (m,l) = pickMin p xs in if p x y then (x,xs) else (m,x:l)
> 
> selectionSort :: (a -> a -> Bool) -> [a] -> [a]
> selectionSort _ []      = []
> selectionSort p l@(_:_) = let (m,l') = pickMin p l
>                           in m : (selectionSort p l')

\subsection{BubbleSort}

> bubble :: (a -> a -> Bool) -> [a] -> [a]
> bubble _ [x] = [x]
> bubble p (x:xs@(_:_)) = let (y:ys) = bubble p xs
>                         in if p x y then x:y:ys else y:x:ys
> 
> bubbleSort :: (a -> a -> Bool) -> [a] -> [a]
> bubbleSort _ []       = []
> bubbleSort p xs@(_:_) = let (y:ys) = bubble p xs in y : bubbleSort p ys

\subsection{QuickSort}

> quickSort' :: (a -> a -> Bool) -> [a] -> [a]
> quickSort' _ []     = []
> quickSort' p (x:xs) = let l1 = filter (\y -> p y x) xs
>                           l2 = filter (\y -> not $ p y x) xs
>                       in quickSort' p l1 ++ x : quickSort' p l2

> quickSort :: (a -> a -> Bool) -> [a] -> [a]
> quickSort _ []     = []
> quickSort p (x:xs) = let t = split p x xs
>                      in quickSort p (fst t) ++ (x:quickSort p (snd t))
> 
> split :: (a -> a -> Bool) -> a -> [a] -> ([a],[a])
> split p x l = split' l ([],[]) where
>   split' [] ls                        = ls
>   split' (y:ys) (l1,l2) | not (p x y) = split' ys (l1,y:l2)
>                         | otherwise   = split' ys (y:l1,l2)


\subsection{MergeSort}

> merge :: (a -> a -> Bool) -> [a] -> [a] -> [a]
> merge _ [] l = l
> merge _ (x:xs) [] = x:xs
> merge p (x:xs) (y:ys) | p x y = x : merge p xs (y:ys)
>                       | otherwise = y : merge p (x:xs) ys
> 
> mergeSort :: (a -> a -> Bool) -> [a] -> [a]
> mergeSort p l = let n       = length l `div` 2
>                     (l1,l2) = splitN l n
>                 in if n == 0 then l else merge p (mergeSort p l1) (mergeSort p l2)
> 
> 
> splitN :: [a] -> Int -> ([a],[a])
> splitN [] _ = ([],[])
> splitN (x:xs) n | n == 0 = ([],x:xs)
>                 | otherwise = let (l1,l2) = splitN xs (n-1) in (x:l1,l2)



\section{Non-deterministic Sorting Functions in Haskell}
\subsection{Modelling Non-determinism}
\begin{itemize}
\item using list monad
\item generalisation to arbitrary monad: enables usage of set-based instance as well
\end{itemize}
\subsection{Exemplary Sorting Functions}
\begin{itemize}
\item monadic abstraction for sorting function sufficient; |?|-like operator only necessary for comparison function
\end{itemize}
\subsection{Curry vs Monadic Non-determinism}
\begin{itemize}
\item non-determinism is not visible at the type-level
\item non-determinism can occur in constructor components (deep vs. flat)
\item thus, non-determinism can be non-stricter than instances using lists (or trees)
\end{itemize}
\subsection{Getting Rid of Duplicates}
\begin{itemize}
\item drawing decision tree using free monad
\item properties of predicates to prevent duplicates
  \begin{itemize}
  \item state monad to track result of compared pairs
  \item consistency, totality, transitivity
  \end{itemize}
\end{itemize}

\section{Conclusion and Future Work}
\begin{itemize}
\item specific enumerations of permutations (lexicographic sorting, even/odd sorting, only one transposition from one to the next)
\item possibility to produce derangements
\item other functions parametrised by predicates
\item investigate strictness properties and running time complexity of permutation enumeration function
\end{itemize}

\section{Final Remarks}
\begin{itemize}
\item ICFP publication with additional proofs
\item bachelor's thesis with adaptation to Curry
\end{itemize}