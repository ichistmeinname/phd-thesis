\chapter{Appendix}
\label{sec:appendix}

\Blindtext[1][1]

\section{Example Programs in Probabilistic Programming Languages}
\label{sec:appendix:ppl}

\subsection{WebPPL}

\paragraph{Bayesian Network}
\begin{minted}{javascript}
var raining = function() {
    return flip(0.2);
};

var sprinkler = function(r) {
    if (r) {
        return flip(0.01)
    } else {
        return flip(0.4);
    }
};

var grassWet = function(s,r) {
    if (s && r) {
        return flip(0.99);
    } else {
        if (s && !r) {
            return flip(0.9);
        } else {
            if (!s && r) {
                return flip(0.8);
            } else {
                return flip(0.0);
            };
        }
    };
};

var grassModel = function () {
    var r = raining();
    var s = sprinkler(r);
    var g = grassWet(s,r);
    return { isRaining : r, isSprinklerOn : s, isGrassWet : g };
}

var grassWetWhenRaining = function() {
    var g = grassModel();
    return (g.isRaining && g.isGrassWet);
};

\end{minted}

\begin{minted}{javascript}
Infer({ model: grassWetWhenRaining
        , method: 'enumerate'
        , maxRuntimeInMS: Infinity});
\end{minted}

\paragraph{Replicate Die}

\begin{minted}{javascript}
var die = function() {
    return uniformDraw([1,2,3,4,5,6]);
};

var replicateDist = function (n, dist) {
    if (n == 0) {
        return uniformDraw([[]]);
    } else {
        return [dist()].concat(replicateDist(n-1,dist));
    }
};

// allSix n = all (== Six) ?? replicateDist n (\ () -> die)
var allSix = function(n) {
    var list = replicateDist(n,die);
    all(function(x) { isSix(x) }, list);
}

var isSix = function(dist) {
    var x = dist;
    return x == 6 ? true : false;
};

\end{minted}

\begin{minted}{javascript}
Infer({ model: function() { allSix(5) }
        , method: 'enumerate'
        , maxRuntimeInMS: Infinity});
\end{minted}

\paragraph{Strings}

\begin{minted}{javascript}
var pickChar = function () {
    return uniformDraw(['a','b']);
};

var replicateDist = function (n, dist) {
    if (n == 0) {
        return uniformDraw([[]]);
    } else {
        return [dist()].concat(replicateDist(n-1,dist));
    }
};

var randomString = function(n) {
    replicateDist(n, pickChar);
};

var isPalindrome = function(str) {
    return (JSON.stringify(str) == JSON.stringify(str.reverse()));
};

var hasConsecutiveBs = function(str) {
    if (str.length < 2) {
        return false;
    } else {
        return helper(str,0,str.length-1);
    }
}

var helper = function (str,n,max) {
    if (n == max) {
        return false;
    } else {
        if (str[n] == 'b' && str[n+1]  == 'b') {
            return true;
        } else {
            return helper(str,n+1,max);
        }
    }
};
\end{minted}

\paragraph{Strings (efficient)}

\begin{minted}{javascript}
var pickChar = function () {
    return uniformDraw(['a','b']);
};

var palindrome = function(n) {
    return helper(1,n);
};

var helper = function (n,m) {
    if (n > m) {
        return true;
    } else if (n == m) {
        let x = pickChar();
        return true;
    } else {
        let x1 = pickChar();
        let x2 = pickChar();
        if (x1 == x2) {
            return helper(n+1,m-1);
        } else
            return false;
    }
};
\end{minted}

\begin{minted}{javascript}
Infer({ model: function () { isPalindrome(randomString(5)) }
        , method: 'enumerate', maxRuntimeInMS: Infinity});
Infer({ model: function () { hasConsecutiveBs(randomString(5)) }
        , method: 'enumerate', maxRuntimeInMS: Infinity});
Infer({ model: function () { palindrome(5) }
        , method: 'enumerate', maxRuntimeInMS: Infinity});
\end{minted}


\paragraph{Secret Santa}

\subsection{ProbLog}

\paragraph{Bayesian Network}

\begin{minted}{prolog}
0.2 :: raining.
0.01 :: sprinkler :- raining.
0.04 :: sprinkler :- \+raining.
0.8 :: grassWet :- \+sprinkler, raining.
0.9 :: grassWet :- sprinkler, \+raining.
0.99 :: grassWet :- sprinkler, raining.

grassWetWhenRaining :- raining, grassWet.
query(grassWetWhenRaining).
\end{minted}

\paragraph{Replicate Die}
\begin{minted}{prolog}
% In ProbLog everything is tabled (or memoized).
% Tabling is an advanced form of caching that is
% used to speed-up the execution of logic programs
% and that allows certain types of cyclic programs.

% We need to add some kind of ID in order to "disable" tabling.
  
(1/6)::die(D,1).
(1/6)::die(D,2).
(1/6)::die(D,3).
(1/6)::die(D,4).
(1/6)::die(D,5).
(1/6)::die(D,6).

isSix(N) :- N == 6.
allSix([]).
allSix([X|XS]) :- isSix(X), allSix(XS).

replicateDie(0,[]).
replicateDie(N,[X|XS]) :- N \== 0, die(N,X), N1 is N-1, replicateDie(N1,XS).

dieSix :- die(42,N), isSix(N).
allRepSix(N) :- replicateDie(N,XS), allSix(XS).

query(allRepSix(N)).
\end{minted}

\paragraph{Strings}
\begin{minted}{prolog}
0.5::pick(N, a) ; 0.5::pick(N,b).

random_string(0,[]).
random_string(N,[X|L]) :-
     N > 0,
     pick(N,X),
     NN is N-1,
     random_string(NN,L).

palindrome(L) :- reverse(L,L).

reverse(L,R) :-
     reverse(L,[],R).
reverse([],L,L).
reverse([A|B],S,R) :-
     reverse(B,[A|S],R).

twoBs([b,b|_]).
twoBs([_|L]) :-
     twoBs(L).

string_is_palindrome(N) :- string_is_palindrome(N,_).
string_is_palindrome(N,L) :- random_string(N,L),palindrome(L).

string_with_bb(N) :- string_with_bb(N,_).
string_with_bb(N,L) :- random_string(N,L),twoBs(L).

len(5).
query(string_is_palindrome(X)) :- len(X).
\end{minted}

\paragraph{Strings (efficient)}

\begin{minted}{prolog}
0.5::pick(N, a) ; 0.5::pick(N,b).

% a palindrome of length N spans positions 1 to N
palindrome(N) :-
      palindrome(1,N).

% base case for even length: left and right crossed
palindrome(A,B) :-
      A > B.
% base case for uneven length: arbitrary middle character
palindrome(N,N) :-
      pick(N,X).
% recursive case: add same character at both ends and move positions towards the middle
palindrome(A,B) :-
      A < B,
      pick(A,X),
      pick(B,X),
      AA is A+1,
      BB is B-1,
      palindrome(AA,BB).

bb(N) :-
      Max is N-1,
      between(1,Max,I),
      pick(I,b),
      II is I+1,
      pick(II,b).

len(30).
query(palindrome(X)) :- len(X).
\end{minted}

\paragraph{Secret Santa}

\section{Formal Reasoning}

\subsection{Definition of Effect to Combine Non-Determinism and
  Sharing}
\label{subsec:appendix:NDSharing}

\begin{minted}{coq}
Module NDSharing.

  Import Container.

  Inductive ND (A : Type) :=
  | choice : option nat -> A -> A -> ND A
  | failed : ND A.

  Inductive Sharing (A : Type) :=
  | share  : nat -> A -> Sharing A.

  Arguments failed {_}.

  Inductive ND__S :=
  | choiceS : option nat -> ND__S
  | failedS : ND__S.

  Inductive Sharing__S :=
  | shareS  : nat -> Sharing__S.

  Definition Sharing__P (s : Sharing__S) := unit.
  Definition ND__P (s : ND__S) :=
    match s with
    | choiceS n => bool
    | failedS   => Empty
    end.

  Definition from_Sharing A (sh : Sharing A) : Ext Sharing__S Sharing__P A :=
    match sh with
    | share n x => ext (shareS n) (fun (p : Sharing__P (shareS n)) => x)
    end.

  Definition from_ND A (nd : ND A) : Ext ND__S ND__P A :=
    match nd with
  | choice n x y => ext (choiceS n) (fun (p : ND__P (choiceS n)) => if p then x else y)
  | failed       => ext failedS (fun (p : ND__P failedS) => match p with end)
  end.

  Definition to_Sharing A (e : Ext Sharing__S Sharing__P A) : Sharing A :=
    match e with
    | ext (shareS n)  pf => share n (pf tt)
    end.

  Definition to_ND A (e : Ext ND__S ND__P A) : ND A :=
    match e with
    | ext (choiceS n) pf => choice n (pf true) (pf false)
    | ext failedS     pf => failed
    end.

  Import Combination.

  Definition Ext__Comb A := Ext (Comb__S ND__S Sharing__S) (Comb__P ND__P Sharing__P) A.

  Definition to__Comb (A : Type) (e : Ext__Comb A) : Comb ND Sharing A :=
    match e with
    | ext (inl s) pf => Inl (to_ND (ext s pf))
    | ext (inr s) pf => Inr (to_Sharing (ext s pf))
    end.

  Definition from__Comb (A : Type) (z : Comb ND Sharing A) : Ext__Comb A :=
    match z with
    | Inl x => let '(ext s pf) := from_ND x in ext (inl s) pf
    | Inr x => let '(ext s pf) := from_Sharing x in ext (inr s) pf
    end.

  Lemma to_from__Comb : forall A (cx : Comb ND Sharing A), to__Comb (from__Comb cx) = cx.
  Proof.
    intros A cx.
    destruct cx as [ [ ] | [ ] ]; reflexivity.
  Qed.

  Lemma from_to__Comb : forall A (e : Ext__Comb A), from__Comb (to__Comb e) = e.
  Proof.
    intros A [s pf].
    destruct s as [ [ n | ] | [ n ] ]; simpl;
      unfold Comb__S; f_equal; extensionality p;
        destruct p; reflexivity.
  Qed.

End NDSharing.
\end{minted}