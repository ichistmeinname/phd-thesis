\chapter{Appendix}
\label{sec:appendix}

The appendix provides an auxiliary proof used in \autoref{ch:permutations}, omitted definitions and type class instances of \autoref{sec:Haskell}, implementations we used for benchmarks comparisons in \autoref{ch:pflp} as well as omitted proof scripts for lemmas discussed in \autoref{ch:reasoning}.

\section{Auxiliary Proof}
\label{sec:appendix:inequation}

The following proof is used for the inequation in \autoref{subsec:sortND}.
We show by induction that for $n \geq 7$, we have $n \leq 2^{\frac{n-1}{2}}$.

\begin{itemize}
\item Case $n=7$.
  \[
    n = 7 < 8 = 2^3 = 2^{\frac{6}{2}}= 2^{\frac{n-1}{2}}
  \]
\item Case $n + 1$ with induction hypothesis $n < 2^{\frac{n-1}{2}}$.
  \[
    n + 1 < n + 2^{\frac{1}{2}} < n \cdot 2^{\frac{1}{2}}< 2^{\frac{n-1}{2}} \cdot 2^{\frac{1}{2}} =  2^{\frac{(n-1) + 1}{2}} = 2^{\frac{(n+1)-1}{2}}
  \]
\end{itemize}

\section{Functor Type Class and Instances}
\label{sec:appendix:functor}

In \autoref{subsec:freeMonad} we used a functor constraint for the type parameter \hinl{f} in order to define a monad instance \hinl{Free}.
The following code completes these examples as it shows the definition of the functor type class and defines instances for the functors we used.

\begin{minted}{haskell}
class Functor f where
  fmap :: (a -> b) ->  f a -> f b
\end{minted}

\begin{minted}{haskell}
instance Functor Zero where
  fmap f z = case z of  

instance Functor One where
  fmap f One = One

instance Functor Choice where
  fmap f (Choice x y) = Choice (f x) (f y)

instance Functor (Const e) where
  fmap f (Const y) = Const y
\end{minted}

\section{Example Programs in Probabilistic Programming Languages}
\label{sec:appendix:ppl}

The following code snippets present the translation of the Curry code discussed in \autoref{sec:applications} to WebPPL and ProbLog.
The code is used to perform the benchmarks that we discuss in the corresponding sections.

\subsection{WebPPL}

\paragraph{Bayesian Network}
\begin{minted}{javascript}
var raining = function() {
    return flip(0.2);
};

var sprinkler = function(r) {
    if (r) {
        return flip(0.01)
    } else {
        return flip(0.4);
    }
};

var grassWet = function(s,r) {
    if (s && r) {
        return flip(0.99);
    } else {
        if (s && !r) {
            return flip(0.9);
        } else {
            if (!s && r) {
                return flip(0.8);
            } else {
                return flip(0.0);
            };
        }
    };
};

var grassModel = function () {
    var r = raining();
    var s = sprinkler(r);
    var g = grassWet(s,r);
    return { isRaining : r, isSprinklerOn : s, isGrassWet : g };
}

var grassWetWhenRaining = function() {
    var g = grassModel();
    return (g.isRaining && g.isGrassWet);
};

\end{minted}

\begin{minted}{javascript}
Infer({ model: grassWetWhenRaining
        , method: 'enumerate'
        , maxRuntimeInMS: Infinity});
\end{minted}

\paragraph{Replicate Die}

\begin{minted}{javascript}
var die = function() {
    return uniformDraw([1,2,3,4,5,6]);
};

var replicateDist = function (n, dist) {
    if (n == 0) {
        return uniformDraw([[]]);
    } else {
        return [dist()].concat(replicateDist(n-1,dist));
    }
};

var allSix = function(n) {
    var list = replicateDist(n,die);
    all(function(x) { isSix(x) }, list);
}

var isSix = function(dist) {
    var x = dist;
    return x == 6 ? true : false;
};

\end{minted}

\begin{minted}{javascript}
Infer({ model: function() { allSix(5) }
        , method: 'enumerate'
        , maxRuntimeInMS: Infinity});
\end{minted}

\paragraph{Strings}

\begin{minted}{javascript}
var pickChar = function () {
    return uniformDraw(['a','b']);
};

var replicateDist = function (n, dist) {
    if (n == 0) {
        return uniformDraw([[]]);
    } else {
        return [dist()].concat(replicateDist(n-1,dist));
    }
};

var randomString = function(n) {
    replicateDist(n, pickChar);
};

var isPalindrome = function(str) {
    return (JSON.stringify(str) == JSON.stringify(str.reverse()));
};

var hasConsecutiveBs = function(str) {
    if (str.length < 2) {
        return false;
    } else {
        return helper(str,0,str.length-1);
    }
}

var helper = function (str,n,max) {
    if (n == max) {
        return false;
    } else {
        if (str[n] == 'b' && str[n+1]  == 'b') {
            return true;
        } else {
            return helper(str,n+1,max);
        }
    }
};
\end{minted}

\paragraph{Strings (efficient)}

\begin{minted}{javascript}
var pickChar = function () {
    return uniformDraw(['a','b']);
};

var palindrome = function(n) {
    return helper(1,n);
};

var helper = function (n,m) {
    if (n > m) {
        return true;
    } else if (n == m) {
        let x = pickChar();
        return true;
    } else {
        let x1 = pickChar();
        let x2 = pickChar();
        if (x1 == x2) {
            return helper(n+1,m-1);
        } else
            return false;
    }
};
\end{minted}

\begin{minted}{javascript}
Infer({ model: function () { isPalindrome(randomString(5)) }
        , method: 'enumerate', maxRuntimeInMS: Infinity});
Infer({ model: function () { hasConsecutiveBs(randomString(5)) }
        , method: 'enumerate', maxRuntimeInMS: Infinity});
Infer({ model: function () { palindrome(5) }
        , method: 'enumerate', maxRuntimeInMS: Infinity});
\end{minted}


\paragraph{Secret Santa}
\begin{minted}{javascript}
  var santaGame = function(n) {
  return fromTo(1,n);
};

var fromTo = function(n,m) {
  if (n > m) {
    return [];
  } else if (n == m) {
    return [n];
  } else {
    return [n].concat(fromTo(n+1,m));
  }
};

var remove = function (x,arr) {
  var remove2 = function (x,arr,i) {
    if (i >= arr.length) {
        return [];
    } else {
      var y = arr[i];
      if (x == y) {
        return remove2(x,arr,i+1);
      } else {
        return [y].concat(remove2(x,arr,i+1));
      }
    }
  }
  return remove2(x,arr,0);
};

var pPicks = function (p,hat) {
  if (hat.length == 0) {
    return { nothing : true }
  } else {
    var x = uniformDraw(hat);
    var hatNew = remove(x,hat);
    return { nothing : false
           , getter : x
           , hatNew : hatNew
           };
  }
};

var pickRound = function(hat) {
  if (hat.length === 0) {
    return {failed : true};
  } else {
    var pickRound2 = function(ps, hat, arrs, n) {
      if (n >= ps.length) {
        return { failed : false
               , assignments : arrs
               };
      } else {
        var giver = ps[n];
        var assgnmnt = pPicks(giver,hat);
        if (assgnmnt.nothing) {
          return { failed : true };
        } else {
          pickRound2( ps
                    , assgnmnt.hatNew
                    , arrs.concat({ giver : giver
                                  , getter : assgnmnt.getter
                                  })
                    , n+1);
        }
      }
    };
    pickRound2(hat,hat,[],0);
  }
};

var pickRound2 = function(hat) {
  if (hat.length === 0) {
    return {failed : true};
  } else {
    var pickRound3 = function(ps, hat, arrs, n) {
      if (n >= ps.length) {
        return { failed : false
               , assignments : arrs
               };
      } else {
        var giver = ps[n];
        var newHat = remove(giver,hat);
        var assgnmnt = pPicks(giver,newHat);
        if (assgnmnt.nothing) {
          return { failed : true
                 , assignments : arrs
                 };
        } else {
          pickRound3( ps
                    , remove(assgnmnt.getter, hat)
                    , arrs.concat({ giver : giver
                                  , getter : assgnmnt.getter
                                  })
                    , n+1);
        }
      }
    };
    pickRound3(hat,hat,[],0);
  }
};

var isInvalid = function(assgnmnt) {
  return (assgnmnt.failed ||
          any( function (a) { a.getter === a.giver }
                            , assgnmnt.assignments));
};
\end{minted}

\begin{minted}{javascript}
Infer({ model: function() { isInvalid(pickRound(santaGame(len))) }
        , method: 'enumerate'
        , maxRuntimeInMS: Infinity});
Infer({ model: function() { isInvalid(pickRound2(santaGame(len))) }
        , method: 'enumerate'
        , maxRuntimeInMS: Infinity});
}
\end{minted}
\subsection{ProbLog}

\paragraph{Bayesian Network}

\begin{minted}{prolog}
0.2  :: raining.
0.01 :: sprinkler :- raining.
0.04 :: sprinkler :- \+raining.
0.8  :: grassWet :- \+sprinkler, raining.
0.9  :: grassWet :- sprinkler, \+raining.
0.99 :: grassWet :- sprinkler, raining.

grassWetWhenRaining :- raining, grassWet.
query(grassWetWhenRaining).
\end{minted}

\paragraph{Replicate Die}
\begin{minted}{prolog}
% We need to add some kind of ID in order to "disable" memoisation.
(1/6)::die(D,1).
(1/6)::die(D,2).
(1/6)::die(D,3).
(1/6)::die(D,4).
(1/6)::die(D,5).
(1/6)::die(D,6).

isSix(N) :- N == 6.
allSix([]).
allSix([X|XS]) :- isSix(X), allSix(XS).

replicateDie(0,[]).
replicateDie(N,[X|XS]) :- N \== 0, die(N,X), N1 is N-1,
                          replicateDie(N1,XS).

dieSix :- die(42,N), isSix(N).
allRepSix(N) :- replicateDie(N,XS), allSix(XS).

query(allRepSix(N)).
\end{minted}

\paragraph{Strings}
\begin{minted}{prolog}
0.5::pick(N, a) ; 0.5::pick(N,b).

random_string(0,[]).
random_string(N,[X|L]) :-
     N > 0,
     pick(N,X),
     NN is N-1,
     random_string(NN,L).

palindrome(L) :- reverse(L,L).

reverse(L,R) :-
     reverse(L,[],R).
reverse([],L,L).
reverse([A|B],S,R) :-
     reverse(B,[A|S],R).

twoBs([b,b|_]).
twoBs([_|L]) :-
     twoBs(L).

string_is_palindrome(N) :- string_is_palindrome(N,_).
string_is_palindrome(N,L) :- random_string(N,L),palindrome(L).

string_with_bb(N) :- string_with_bb(N,_).
string_with_bb(N,L) :- random_string(N,L),twoBs(L).

len(5).
query(string_is_palindrome(X)) :- len(X).
\end{minted}

\paragraph{Strings (efficient)}

\begin{minted}{prolog}
0.5::pick(N, a) ; 0.5::pick(N,b).

% a palindrome of length N spans positions 1 to N
palindrome(N) :- palindrome(1,N).

% base case for even length: left and right crossed
palindrome(A,B) :- A > B.
% base case for uneven length: arbitrary middle character
palindrome(N,N) :- pick(N,X).
% recursive case: add same character at both ends and move
%  positions towards the middle
palindrome(A,B) :- A < B, pick(A,X), pick(B,X),
                AA is A+1, BB is B-1, palindrome(AA,BB).

bb(N) :- Max is N-1, between(1,Max,I), pick(I,b),
         II is I+1, pick(II,b).

len(30).
query(palindrome(X)) :- len(X).
\end{minted}

\paragraph{Secret Santa}
\begin{minted}{prolog}
:- use_module(library(lists)).

% reuse select_uniform as it's not trivial to define
% uniform/2 with the expected behaviour
uniform([X|XS],Y) :- select_uniform(42,[X|XS],Y,ZS).

pPicks(P,Hat,V) :- uniform(Hat,V), V \== P.

pickRound(Hat,Arrs) :- pickRound(Hat,Hat,Arrs).
pickRound([],_,[]).
pickRound([P|Ps], Hat, [(P,V)|Arrs]) :-
  pPicks(P,Hat,V), delete(Hat,V,HatNew), pickRound(Ps,HatNew, Arrs).

ppPicks(P,Hat,just(V)) :- uniform(Hat,V), V \== P.
ppPicks(P,Hat,nothing) :- uniform(Hat,V), V = P.

ppickRound(Hat,Arrs) :- ppickRound(Hat,Hat,Arrs).
ppickRound([],_,[]).
ppickRound([P|Ps], Hat, [failedGame]) :- ppPicks(P,Hat,nothing).
ppickRound([P|Ps], Hat, [(P,V)|Arrs]) :-
  ppPicks(P,Hat,just(V)), delete(Hat,V,HatNew), ppickRound(Ps,HatNew, Arrs).

is_pair((X,Y)).

allValid([]).
allValid([X|Xs]) :- is_pair(X), allValid(Xs).

anyFailed(Xs) :- member(failedGame,Xs).

hat(2,[2,1]).
hat(N,[N|Xs]) :- N > 1, M is N-1, hat(M,Xs).

% clever pick: a person cannot pick herself
% invalid games are just `false`
pickRound2(Hat,Arrs) :- pickRound2(Hat,Hat,Arrs).
pickRound2([],_,[]).
pickRound2([P|Ps], Hat, [(P,V)|Arrs]) :-
  delete(Hat,P,HatTemp), pPicks(P,HatTemp,V), delete(Hat,V,HatNew),
  pickRound2(Ps,HatNew, Arrs).

% clever pick: a person cannot pick herself
% invalid games are tracked as well
ppickRound2(Hat,Arrs) :- ppickRound2(Hat,Hat,Arrs).
ppickRound2([],_,[]).
ppickRound2([P],[P],[failedGame]).
ppickRound2([P|Ps], Hat, [(P,V)|Arrs]) :-
  delete(Hat,P,HatTemp), pPicks(P,HatTemp,V), delete(Hat,V,HatNew),
  ppickRound2(Ps,HatNew, Arrs).

isValid([],true).
isValid([X|Xs],false) :- X == failedGame.
isValid([X|Xs],Bool) :- X \= failedGame, isValid(Xs,Bool).

santa(N,Bool) :- hat(N,Xs), ppickRound(Xs,Arrs), isValid(Arrs,Bool).
santa2(N,Bool) :- hat(N,Xs), ppickRound2(Xs,Arrs), isValid(Arrs,Bool).

query(santa(3,X)).
query(santa2(3,X)).
\end{minted}

\section{Formal Reasoning}